<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[PINGGOD]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://pinggod.com/"/>
  <updated>2016-03-16T11:25:07.000Z</updated>
  <id>http://pinggod.com/</id>
  
  <author>
    <name><![CDATA[Sean Sun]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[洗牌算法]]></title>
    <link href="http://pinggod.com/2016/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://pinggod.com/2016/洗牌算法/</id>
    <published>2016-03-16T05:45:02.000Z</published>
    <updated>2016-03-16T11:25:07.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译自 <a href="https://www.kirupa.com/html5/shuffling_array_js.htm" target="_blank" rel="external">Shuffling an Array in JavaScript</a></p>
</blockquote>
<p>洗牌算法是一个比较形象的术语，本质上让一个数组内的元素随机排列。举例来说，我们有一个如下图所示的数组，数组长度为 9，数组内元素的值顺次分别是 1~9：</p>
<p><img src="/img/shuffle-array-1.png" alt="shffle-array-1"></p>
<p>从上面这个数组入手，我们要做的就是打乱数组内元素的顺序：</p>
<p><img src="/img/shuffle-array-2.png" alt="shffle-array-2"></p>
<a id="more"></a>
<h2 id="代码实现">代码实现</h2><p>维基百科上的 <a href="http://en.wikipedia.org/wiki/Knuth_shuffle" target="_blank" rel="external">Fisher–Yates shuffle</a> 词条对洗牌算法做了详细介绍，下面演示的算法也是基于其中的理论编写的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="keyword">this</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = input.length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>)); </span><br><span class="line">        <span class="keyword">var</span> itemAtIndex = input[randomIndex]; </span><br><span class="line">         </span><br><span class="line">        input[randomIndex] = input[i]; </span><br><span class="line">        input[i] = itemAtIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> tempArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> ]</span><br><span class="line">tempArray.shuffle();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// and the result is...</span></span><br><span class="line">alert(tempArray);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了一个 <code>shffle()</code> 方法，该方法用于随机排列数组内的元素。此外，我们将该方法挂载在了 <code>Array</code> 对象的原型下面，所以任何数组都可以直接调用该方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tempArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> ]</span><br><span class="line">tempArray.shuffle();</span><br></pre></td></tr></table></figure>
<h2 id="工作原理">工作原理</h2><p>看完代码之后，让我们看看它对数组都做了写什么。首先，该方法选中数组的最后一个元素：</p>
<p><img src="/img/shuffle-array-3.png" alt="shffule-array-3"></p>
<p>接下来确定挑选随机元素的范围，从数组的第一个元素到上一步选中的元素都属于这一范围：</p>
<p><img src="/img/shuffle-array-4.png" alt="shffule-array-4"></p>
<p>确定范围后，从中随机挑选一个数，这里假设随机选中的元素为 4：</p>
<p><img src="/img/shuffle-array-5.png" alt="shffule-array-5"></p>
<p>然后交换最后一个元素和随机选中的元素的值：</p>
<p><img src="/img/shuffle-array-6.png" alt="shffule-array-6"></p>
<p>上面的交换完成后，相当于我们完成了对数组最后一个元素的随机处理。接下来选中数组内倒数第二的元素：</p>
<p><img src="/img/shuffle-array-7.png" alt="shffule-array-7"></p>
<p>之所以从后往前处理，是因为这样便于确定随机选择的范围。这次我们假定随机到的元素为 2:</p>
<p><img src="/img/shuffle-array-8.png" alt="shffule-array-8"></p>
<p>接着交换倒数第一个元素和 2 号元素的值，完成对倒数第二个元素随机排列的处理。然后是选中倒数第三个元素，重复之前的操作：</p>
<p><img src="/img/shuffle-array-9.png" alt="shffule-array-9"></p>
<p>剩下的就是一些重复性的工作，不多做介绍了。</p>
<h2 id="分析代码">分析代码</h2><p>在上一节给各位用图例演示了洗牌流程，下面我们从代码本身看看洗牌流程。先从 <code>shuffle</code> 函数说起吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="keyword">this</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = input.length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>)); </span><br><span class="line">        <span class="keyword">var</span> itemAtIndex = input[randomIndex]; </span><br><span class="line">         </span><br><span class="line">        input[randomIndex] = input[i]; </span><br><span class="line">        input[i] = itemAtIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shuffle</code> 函数挂载在 <code>Array</code> 对象的原型之下，便于数组直接调用该函数。在 <code>shuffle</code> 函数内部，<code>this</code> 引用的就是调用该 <code>shuffle</code> 的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我用一个新的变量引用 <code>this</code>，也就是调用 <code>shuffle</code> 函数的数组。下一步，看一下 <code>for</code> 循环内都干了什么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = input.length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>)); </span><br><span class="line">    <span class="keyword">var</span> itemAtIndex = input[randomIndex]; </span><br><span class="line">     </span><br><span class="line">    input[randomIndex] = input[i]; </span><br><span class="line">    input[i] = itemAtIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该循环用于遍历所有数组内的所有元素，并进行随机交换。注意，遍历顺序是从后往前进行的，也就是说从 <code>input.length-1</code> 位置的元素开始，知道遍历到数组中的第一个元素。遍历过程中的位置由变量 <code>i</code> 指定。</p>
<p>这里的变量 <code>i</code> 就是上面图例中被选中的元素：</p>
<p><img src="/img/shuffle-array-3.png" alt="shffule-array-3"></p>
<p>接下来，使用了两行代码在指定范围内挑选一个随机元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>)); </span><br><span class="line"><span class="keyword">var</span> itemAtIndex = input[randomIndex];</span><br></pre></td></tr></table></figure>
<p>变量 <code>randomIndex</code> 存储了一个随机数，该随机数可以用作数组的索引，进而提取一个随机元素。注意，该随机数的最大值并不是数组的长度，而是变量 <code>i</code> 的值。</p>
<p>确定了随机元素的索引之后，用新的变量保存该元素的值，然后交换选中元素和随机元素的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> itemAtIndex = input[randomIndex];</span><br><span class="line">input[randomIndex] = input[i]; </span><br><span class="line">input[i] = itemAtIndex;</span><br></pre></td></tr></table></figure>
<p>在这三行代码中，第一行使用新的变量保存了随机元素的值；第二行将选中元素 <code>input[i]</code> 的值赋给随机元素 <code>input[randomIndex]</code>；第三行就随机元素的值 <code>itemAtIndex</code> 赋给选中元素 <code>input[i]</code>。本质上是一个互换两个元素的值的过程，并不难理解。</p>
<p>至此，循环内的逻辑就介绍完了，剩下的都是重复操作。</p>
<h2 id="随机性测试">随机性测试</h2><p><div id="random-chart" style="width=100%;"></div></p>
<script src="http://cdn.hcharts.cn/jquery/jquery-2.1.4.min.js"></script>
<script src="http://cdn.hcharts.cn/highcharts/highcharts.js"></script>
<script>
    $(function() {
        var sum = [];
        var array = []
        var arrayLength = 21;
        var iterateTimes = 10000;

        Array.prototype.shuffle = function () {
            var arr = this;

            for (var i = arr.length - 1; i >= 0; i--) {
                var randomIndex = Math.floor(Math.random() * (i + 1));
                var randomElemValue = arr[randomIndex];

                arr[randomIndex] = arr[i];
                arr[i] = randomElemValue;
            }
            return arr;
        }

        function init (len) {
            for (var i = 0; i < len; i++) {
                sum[i] = 0;
                array[i] = i;
            }
        }

        function createArray () {
            var arr = [];

            for (var i = 0; i < arrayLength; i++) {
                arr[i] = i;
            }

            return arr;
        }

        function calculateSum (times) {
            for (var i = 0; i < times; i++) {
                var arr = createArray().shuffle();
                for (var j = 0; j < arrayLength; j++) {
                    sum[j] += arr[j];
                }
            }
        }

        init(arrayLength);
        calculateSum(iterateTimes);

        $("#random-chart").highcharts({
            chart: {
                type: 'column'
            },
            title: {
                text: '洗牌的随机性结果'
            },
            xAxis: {
                categories: array
            },
            yAxis: {
                title: {
                    text: '总值'
                }
            },
            series: [{
                name: '不同位置的总值',
                color: '#42b983',
                data: sum
            }]
        });
    });
</script>

<p>上图是使用 Highcharts 制作的随机性测试图表，以可视化的方式校验本文中洗牌算法的随机性。每次刷新页面都会重新计算和生成该图表。</p>
<p>生成上图的数据是这样计算而来的：首先创建一个数组（上图使用的数组为 <code>[0, 1, 2 ... 18, 19, 20]</code>），然后使用本文中的洗牌算法重新排序，排序完成后记录每一个元素的值……以此步骤执行 100000 次，最后对同一索引位置上的数值进行求和。如此执行 10000 次之后，索引之间的总值应该相差不大。</p>
<p>由计算可得：</p>
<p>$$average=\frac{(0+20)\times21\times10000}{2\times21}=100k$$</p>
<h6 id="参考资料">参考资料</h6><ul>
<li><a href="https://www.kirupa.com/html5/shuffling_array_js.htm" target="_blank" rel="external">Shuffling an Array in JavaScript</a></li>
<li><a href="https://bost.ocks.org/mike/shuffle/" target="_blank" rel="external">Fisher–Yates Shuffle</a></li>
<li><a href="https://news.ycombinator.com/item?id=3464607" target="_blank" rel="external">Hacker News: A visual explanation of Fisher–Yates shuffle</a></li>
<li><a href="http://stackoverflow.com/questions/962802/is-it-correct-to-use-javascript-array-sort-method-for-shuffling/962890#962890" target="_blank" rel="external">Stack Overflow: Is it correct to use JavaScript Array.sort() method for shuffling?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译自 <a href="https://www.kirupa.com/html5/shuffling_array_js.htm">Shuffling an Array in JavaScript</a></p>
</blockquote>
<p>洗牌算法是一个比较形象的术语，本质上让一个数组内的元素随机排列。举例来说，我们有一个如下图所示的数组，数组长度为 9，数组内元素的值顺次分别是 1~9：</p>
<p><img src="/img/shuffle-array-1.png" alt="shffle-array-1"></p>
<p>从上面这个数组入手，我们要做的就是打乱数组内元素的顺序：</p>
<p><img src="/img/shuffle-array-2.png" alt="shffle-array-2"></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 21 问]]></title>
    <link href="http://pinggod.com/2016/JavaScript-21-%E9%97%AE/"/>
    <id>http://pinggod.com/2016/JavaScript-21-问/</id>
    <published>2016-03-12T12:22:26.000Z</published>
    <updated>2016-03-12T15:45:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译自：<a href="https://www.codementor.io/javascript/tutorial/21-essential-javascript-tech-interview-practice-questions-answers" target="_blank" rel="external">21 Essential JavaScript Interview Questions</a></p>
</blockquote>
<p>JavaScript 因其历史原因一直存在诸多缺陷，本文所讨论的只是其中的一小部分，适合为初学者答疑解惑，此外文中观点尚存在不足之处，或者对部分问题 ES6 已经纠正和改善。</p>
<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译自：<a href="https://www.codementor.io/javascript/tutorial/21-essential-javascript-tech-interview-practice-questions-answers">21 Essential JavaScript Interview Questions</a></p>
</blockquote>
<p>JavaScript 因其历史原因一直存在诸多缺陷，本文所讨论的只是其中的一小部分，适合为初学者答疑解惑，此外文中观点尚存在不足之处，或者对部分问题 ES6 已经纠正和改善。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016 JavaScript 技术栈展望]]></title>
    <link href="http://pinggod.com/2016/2016-JavaScript-%E6%8A%80%E6%9C%AF%E6%A0%88%E5%B1%95%E6%9C%9B/"/>
    <id>http://pinggod.com/2016/2016-JavaScript-技术栈展望/</id>
    <published>2016-03-11T03:45:31.000Z</published>
    <updated>2016-03-12T12:23:15.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译自 <a href="https://medium.com/javascript-and-opinions/state-of-the-art-javascript-in-2016-ab67fc68eb0b#.iwbk5gf69" target="_blank" rel="external">State of the Art JavaScript in 2016</a></p>
</blockquote>
<p>如果你正在筹划新的前端项目或者重构现有项目，那么你需要认识到现在的前端开发环境已经今非昔比，这其中有太多的选择了：React、Flux、Angular、Aurelia、Mocha、Jasmine、Babel、TypeScript、Flow…… 它们的本意是将开发简单化，却无形中提高了学习成本，也给未来项目的维护带来了不确定性。</p>
<p>好在这一现象正在退热，优胜劣汰，优秀的项目慢慢沉淀下来，开发方式也越来越清晰。有些开发者正在尝试使用基于上述技术的框架进行开发，也在一定程度上减少了学习成本。</p>
<p>本文中主要介绍了一些我在 web 应用开发中所涉及和推崇的技术，其中有一些技术上存在争议，所以我对于每一技术都只做简单的介绍和分析。所有的这些观点都是基于我个人的经验和对社区的接触总结而来的，所以各位还请按需各取所用。</p>
<a id="more"></a>
<h2 id="React">React</h2><p>React 可谓风头正盛一时无两：</p>
<ul>
<li>组件化使应用程序更易于开发和维护</li>
<li>学习曲线平缓，核心 API 简洁清晰，易于学习</li>
<li>JSX 语法不落俗套，充分发挥了 JavaScript 的能量</li>
<li>天生适配 Flux 和 Redux</li>
<li>社区活跃且具有创造力，奉献了诸多优秀的开发工具</li>
<li>单向数据流比双向数据绑定的方式更适合复杂应用程序，质量更高</li>
<li>支持服务端渲染</li>
</ul>
<p>虽然比起 Ember、Aurelia 和 Angular 这些功能丰富的框架，React 不是全能手，但 React 的开发环境更加健壮。就目前而言，使用 React 已经不是一个技术选择，而是一个商业行为，它能提供更高效和更有效的生产力。</p>
<blockquote>
<p>当你想开发移动应用时，因为已经学习了 React 语法，所以可以直接上手 React Native 开发跨平台应用。</p>
</blockquote>
<h2 id="Redux">Redux</h2><p>现在，我们已经具有了开发视图层的能力，接下来，我们需要使用其他工具管理应用程序中的状态和生命周期，在这里推荐的工具就是：Redux。</p>
<p>为了配合 React，Facebook 开发了管理单向数据流的工具 Flux，虽然 Flux 基本上实现了对单项数据流的支持，但是同时也带了其他问题，比如如何保存状态、何处发起 Ajax 请求等等。</p>
<p>为了解决这些问题，又衍生了一系列效仿 Flux 模式的框架：Fluxible、Reflux、Alt、Flummox、Lux、Nuclear、Fluxxor……</p>
<p>目前来说被开发社区广泛支持的一个实现就是 Redux。</p>
<p>在 Redux 中，大多数的组件都是纯函数式的组件，也只有一个集中的存储和资源中心。Redux 的实例方法负责整个数据的操作和维护。相比 Flux 来说，Redux 的思路更加清晰。</p>
<p>更重要的是，Redux 非常易于学习。Redux 的作者 Dan Abramov 是一个优秀的教师，他制作了一系列深入浅出的 Redux 视频教程。通过观看这些视频，即可成为一个 Redux 方面的专家。我曾经见识到一个零基础的 React 团队在短短几周内迅速开发出了测试版产品，且代码非常稳健和老练。</p>
<p>Redux 周边的生态系统和 Redux 本身一样健壮。从神奇的 <a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="external">devtool</a> 到强大的记忆化工具 <a href="https://github.com/reactjs/reselect" target="_blank" rel="external">reselect</a>，Redux 开发社区为开发者提供了应有尽有的工具。</p>
<p>开发者可能会本能地去尝试抽象出一个 Redux 模板，这么做有诸多好处，但请在认清需求的基础上来封装模板，而不要盲目的去尝试。</p>
<h2 id="ES6_和_Babel">ES6 和 Babel</h2><p>是时候抛弃 CoffeeScript 了，这是因为它的诸多特性已在 ES6 中出现类似的语法，而 ES6 是实施标准，代表了 JavaScript 未来的发展方向。</p>
<p>目前最新的浏览器已经支持了 ES6 的大部分特性。Babel 是一个强大的转换工具，用于将 ES6 转换为 ES5。此外，根据目标浏览器可以调整代码转换的程度。</p>
<p>那么是否有类型系统呢？TypeScript 和 Flow 都为 JavaScript 提供了静态类型系统，使用静态类型检查，可以有效捕获错误，减少测试量。目前来说，我建议对此持观望态度。</p>
<p>TypeScript 在尽力让 JavaScript 向 C# 或 Java 的方向发展，但缺少了许多高级的类型系统特性，比如代数数据类型（algebraic data types）。此外，它不能像 Flow 一样有效地处理 null。</p>
<p>相比而言，Flow 更加强大，捕获的错误类型也更多，但难于配置。此外，它对 JavaScript 新特性的支持弱于 Babel，也不支持 Windows 系统。</p>
<p>就我个人的角度而言，在前端开发中类型系统并不是至关重要的一环（此处可能有争议）。在类型系统更加健壮且对 Babel 更友好之前，还是让我们静观其变吧。</p>
<h2 id="ESLint">ESLint</h2><p>另一个无可争议的工具是 ESLint。ESLint 支持 ES6 语法，还提供了 React 插件，已经不单单是一个代码审查工具了。目前来说，JSLint 已经过时了，ESLint 可以替代 JSHint 和 JSCS 独树一帜了。</p>
<p>开发者可以根据自己的需求配置 ESLint，不过在这里我建议根据 <a href="https://github.com/airbnb/javascript" target="_blank" rel="external">AirBNB 的开发规范</a>进行配置，也可以直接使用 <a href="https://www.npmjs.com/package/eslint-config-airbnb" target="_blank" rel="external">ESLint airbnb config</a>。当然这份规范中尚有不足之处，但保持团队整体代码的一致性，可以有效提高代码的可读性。</p>
<p>当你熟悉了 ESLint 之后，建议开发者深入地尝试其中的规则。ESLint 捕获的错误越多，产品的稳定性越高。</p>
<h2 id="NPM，CommonJS_和_ES6_modules">NPM，CommonJS 和 ES6 modules</h2><p>忘记 Bower 吧，用 NPM 接管一切。类似 Browserify 和 Webpack 的构建工具间接提高了 NPM 在 web 开发中的地位。使用 NPM，版本管理将会更加简单，也将更多地与 Node.js 生态系统接触。目前对于 CSS 的处理尚不足够完善。</p>
<p>你可能会考虑如何在部署服务器上执行构建呢？与 Ruby 的 Bundler 有所不同，NPM 使用了通配符检索文件，且第三方包可以在代码开发中以及项目发布前做任意修改。使用 <a href="https://docs.npmjs.com/cli/shrinkwrap" target="_blank" rel="external">shrinkwrap</a> 文件可以冻结项目中的第三方依赖，我建议使用 User 的 shrinkwrap，提高输出的一致性。此外，开发者也可以考虑使用类似 <a href="https://www.npmjs.com/package/sinopia" target="_blank" rel="external">Sinopia</a> 的工具托管自己的私有 NPM 服务器。</p>
<p>Babel 会将 ES6 module 语法转换为 CommonJS。CommonJS 是一种历经实践的语法，这意味着稳定和通用，此外，使用类似 <a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html" target="_blank" rel="external">tree shaking</a> （Webpack 2.0 和 Rollup 已经支持该特性）的机制我们还能实现静态代码分析。</p>
<h2 id="Webpack">Webpack</h2><p>除非你乐意在页面添加数百个脚本标签，否则的话你应该尝试用构建工具来打包页面的资源了。此外，你还需要某些工具让浏览器支持 NPM 第三方包。在这里，我推荐你使用 Webpack。</p>
<p>一年之前对于上述工作，开发者还有诸多工具可以选择，比如基于 JavaScript 的 RequireJS、Browserify 和 Webpack 解决方案，此外还有号称能对 ES6 的模块进行最佳优化的 RollupJS.</p>
<p>在尝试了所有的工具之后，我强烈建议开发者选择 Webpack:</p>
<ul>
<li>通过配置可以应对各种情况</li>
<li>支持主流的模块加载方式（AMD，CommonJS，globals）</li>
<li>内部机制可以修复破损的模块</li>
<li>可以处理 CSS</li>
<li>全面的缓存系统</li>
<li>支持热重载</li>
<li>可以加载大多数的资源</li>
<li>提供高效的<a href="https://github.com/webpack/docs/wiki/optimization" target="_blank" rel="external">性能优化方案</a></li>
</ul>
<p>Webpack 也非常善于处理大型的单页应用，支持代码分割和惰性加载。</p>
<p>但是值得注意的是，Webpack 的学习曲线异常陡峭。不过一旦你学会了它，那么你就掌握了最强大的构建系统。</p>
<p>那么 Gulp 和 Grunt 呢？相比而言，Webpack 更善于处理各类资源。如果你需要执行其他类型的构建任务，那么 Gulp 和 Grunt 还是有用的。对于类似运行 Webpack 的基本任务，我建议直接使用 <a href="https://docs.npmjs.com/cli/run-script" target="_blank" rel="external">NPM 脚本</a>。</p>
<h2 id="Mocha_+_Chai_+_Sinon">Mocha + Chai + Sinon</h2><p>在 JavaScript 中，有大量可选的单元测试工具，每一个都很稳定和健壮。如果你只是用于单元测试，那么现有工具完全可以胜任你的需求。</p>
<p>常见的测试工具有 Jasmine、Mocha、Tape、Ava、Jest 等，它们各有所长。</p>
<p>我对一个测试框架的要求有如下几条：</p>
<ul>
<li>可以在浏览器运行，便于调试</li>
<li>执行速度快</li>
<li>便于处理异步测试</li>
<li>便于在命令行中使用</li>
<li>可以兼容任意断言和数据模拟的第三方库</li>
</ul>
<p>第一条标准就排除了 Ava 和 Jest。</p>
<p>我喜欢 Chai 断言是因为其种类丰富、功能齐全的插件，喜欢 Mocha 是因为其对异步的良好支持。强烈建议使用 <a href="https://github.com/prodatakey/dirty-chai" target="_blank" rel="external">Dirty Chai</a> 避免某些问题。Webpack 的 <a href="https://github.com/webpack/mocha-loader" target="_blank" rel="external">mocha-leader</a> 插件允许开发者自动执行测试。</p>
<p>对于 React 而言，开发者可以参考一下 AirBNB 的 <a href="https://github.com/airbnb/enzyme" target="_blank" rel="external">Enzyme</a> 和 <a href="https://github.com/jquense/teaspoon" target="_blank" rel="external">Teaspoon</a>。</p>
<p>我非常钟爱 Mocha 的特性，如果你想要的只是最基础的功能，可以参考<a href="https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4" target="_blank" rel="external">这篇文章</a>了解一下 Tape。</p>
<h2 id="Lodash">Lodash</h2><p>JavaScript 并没有一个类似 Java 或 .NET 的核心工具库，所以开发者大都会从外部引用一个外部工具库。</p>
<p>目前来说，Lodash 是此类工具中的佼佼者。此外，由于它<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/" target="_blank" rel="external">惰性执行</a>的特性，也让它是目前性能最佳的工具之一。使用 Lodash 时无需引用全部资源，开发者可以按需使用其中的函数。在 4.x 版本中，Lodash 为偏爱函数式编程的开发者提供了一个“函数式开发”模式。</p>
<p>如果你熟悉函数式编程，你可以了解一下 <a href="http://ramdajs.com/0.19.1/index.html" target="_blank" rel="external">Ramda</a>。如果你决定使用这个库，可能需要引用一些 Lodash 函数。</p>
<h2 id="fetch">fetch</h2><p>许多基于 React 的应用程序都不再使用 jQuery 了。除非你正在维护一个陈旧的项目或者用到的第三方库依赖了 jQuery，否则已经没有必要使用它了。</p>
<p>我喜欢让项目保持简洁，在代码中只使用 <a href="http://ramdajs.com/0.19.1/index.html" target="_blank" rel="external">fetch</a> 。fetch 基于 promise，Firefox 和 Chrome 都封装了该接口。对于其他浏览器，则需要提供一个腻子脚本。我建议使用 <a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="external">isomorphic-fetch</a> 在各个浏览器和服务端保持功能的一致性。</p>
<p>当然也可以其他优秀的第三方库异步获取数据，但我觉得 fetch 已经够用了。</p>
<h2 id="同构_JavaScript">同构 JavaScript</h2><p>同构 JavaScript 是指同时运行在客户端和服务端的 JavaScript，常用于在服务端预先渲染页面，提高性能，便于 SEO。使用 React 可以实现同构 JavaScript，但是并不简单，它提高了程序的复杂度，限制了开发者可选的工具和第三方库。</p>
<p>如果你正在构建一个 B2C 的站点，比如电商网站，那么你可能就需要使用同构 JavaScript。不过，对于内部站点或者 B2B 程序，性能就不是最重要的了，则同构 JavaScript 也就不是太重要了。</p>
<h2 id="API">API</h2><p>最近每个人好像都在思考如何处理 API。每个人都在随波逐流的使用 <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">RESTfull API</a>，<a href="https://en.wikipedia.org/wiki/SOAP" target="_blank" rel="external">SOAP</a> 已经成为了过去时。目前业界存在各种 API 协议，比如 HATEOAS、JSON API、HAL、GraphQL 等。</p>
<p>GraphQL 赋予了客户端进行任意查询的能力。搭配 <a href="https://facebook.github.io/relay/" target="_blank" rel="external">Relay</a>，可以更好地处理客户端的状态和缓存。不过，创建 GraphQL 的服务端接口的难度还较大，且大多数的文档都是面向 Node.js 的。</p>
<p>Netflix 的 <a href="https://github.com/Netflix/falcor" target="_blank" rel="external">Falcor</a> 看起来提供了和 GraphQL/Relay 相似的能力，同时还降低了服务端的需求，但它目前尚处于开发者预览状态，尚未应用于实际开发。</p>
<p>所有已知的规范都各有缺陷，有些过于复杂，有些只能处理数据读取而不嗯那个更新，有些和 REST 差异显著。许多开发者选择自己开发，但是还会遇到上述的问题。</p>
<p>我不认为上述有一个完美的解决方案，但我对 API 有一个自己的认知：</p>
<ul>
<li>可预测，遵循一致性协议</li>
<li>支持在一次查询中获取多个实体</li>
<li>支持更新操作</li>
<li>易于调试</li>
<li>易于使用</li>
</ul>
<p>到目前为止，我还没有发现满足上述所有条件的解决方案。</p>
<p>如果你正在使用 RESFful，建议参考 <a href="http://swagger.io/" target="_blank" rel="external">Swagger</a> 来编写 API。</p>
<h2 id="Electron">Electron</h2><p><a href="https://github.com/atom/electron" target="_blank" rel="external">Electron</a> 可以使用前端技术构建桌面程序，GitHub 团队出品的 Atom 编辑器就是基于 Electron 创建的。本质上，Electron 内部封装了一个 Node.js，可以打开 Chrome 窗口渲染 UI，还可以访问操作系统本地的 API，并且没有浏览器中的沙盒机制。开发者可以通过 Electron 打包和分发应用程序。</p>
<p>这是创建跨平台软件最简单的方式，而且还可以利用上述的所有工具。此外，Electron 有完整的文档和活跃的开发社区。</p>
<p>你可能听说过 <a href="http://nwjs.io/" target="_blank" rel="external">nw.js</a> 的大名，虽然它已经存在了多年，但相比来说，Electron 更加稳定和易用。</p>
<p>这里有一个基于 <a href="https://github.com/chentsulin/electron-react-boilerplate" target="_blank" rel="external">Electron、React 和 hot reload 的模板</a>，尝试一下吧。</p>
<h2 id="延伸">延伸</h2><p>下面是一些我在 Twitter 上关注的对象：</p>
<ul>
<li><a href="https://github.com/gaearon" target="_blank" rel="external">Dan Abramov</a>, Redux 的创建者</li>
<li><a href="https://twitter.com/Vjeux" target="_blank" rel="external">Christopher Chedeau</a>, 非常活跃的 React 开发者，现就职与 Facebook</li>
<li><a href="https://github.com/jeffmo" target="_blank" rel="external">Jeff Morrison</a>, Flow 的核心贡献者之一</li>
<li><a href="https://twitter.com/sebmarkbage" target="_blank" rel="external">Sebastian Markbåge</a>, React 的创建者之一</li>
<li><a href="https://twitter.com/floydophone" target="_blank" rel="external">Pete Hunt</a></li>
<li><a href="https://twitter.com/reactjs" target="_blank" rel="external">React</a></li>
<li>更多值得关注的对象请参考 <a href="https://twitter.com/oguzbilgic/lists/react-influencers" target="_blank" rel="external">React Influencers</a></li>
</ul>
<p>建议阅读 Pate Hunt 的 <a href="https://github.com/petehunt/react-howto" target="_blank" rel="external">Learning React</a>!</p>
<p>Dan Abramov 发布一系列的视频教程 <a href="https://egghead.io/series/getting-started-with-redux" target="_blank" rel="external">Getting started with Redux</a>，强烈推荐！此外，Dan 还发布过一个<a href="https://medium.com/@dan_abramov/my-react-list-862227952a8c#.740o0wzee" target="_blank" rel="external">关注列表</a>，比上述更加详细。</p>
<p>Mark Erikson 的 <a href="https://github.com/markerikson/react-redux-links" target="_blank" rel="external">React/Redux links</a> 集合也是很好的学习材料。</p>
<h2 id="按需使用">按需使用</h2><p>JavaScript 的生态环境发展迅速，正日益强大起来。React 的最佳实践正在固化，周边工具的职责和能力也日益清晰。</p>
<p>最重要的事情就是要牢记：保持简洁，按需使用。</p>
<p>如果你的应用程序只有两三屏，那么就无需使用路由系统；如果你正在创建一个单页应用，那么甚至不需要 Redux，只需要 React 自己的 state 属性即可；如果你正在创建一个简单的 CRUD 程序，那么你就不需要使用 Relay；如果你正在学习 ES6，并不需要深入地了解 Async/Await 或装饰器；如果你刚刚开始学习 React，并不需要使用热重载和服务端渲染；如果你刚刚接触 Webpack，你就不需要分离代码和合并多个资源；如果你刚刚学习 Redux，你不需要理解使用 Redux-Form 和 Redux-Sagas。</p>
<p>保持简洁，每次只做一件事！</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译自 <a href="https://medium.com/javascript-and-opinions/state-of-the-art-javascript-in-2016-ab67fc68eb0b#.iwbk5gf69">State of the Art JavaScript in 2016</a></p>
</blockquote>
<p>如果你正在筹划新的前端项目或者重构现有项目，那么你需要认识到现在的前端开发环境已经今非昔比，这其中有太多的选择了：React、Flux、Angular、Aurelia、Mocha、Jasmine、Babel、TypeScript、Flow…… 它们的本意是将开发简单化，却无形中提高了学习成本，也给未来项目的维护带来了不确定性。</p>
<p>好在这一现象正在退热，优胜劣汰，优秀的项目慢慢沉淀下来，开发方式也越来越清晰。有些开发者正在尝试使用基于上述技术的框架进行开发，也在一定程度上减少了学习成本。</p>
<p>本文中主要介绍了一些我在 web 应用开发中所涉及和推崇的技术，其中有一些技术上存在争议，所以我对于每一技术都只做简单的介绍和分析。所有的这些观点都是基于我个人的经验和对社区的接触总结而来的，所以各位还请按需各取所用。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能优化的十二个方面]]></title>
    <link href="http://pinggod.com/2016/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%8D%81%E4%BA%8C%E4%B8%AA%E6%96%B9%E9%9D%A2/"/>
    <id>http://pinggod.com/2016/性能优化的十二个方面/</id>
    <published>2016-03-04T12:37:34.000Z</published>
    <updated>2016-03-04T12:50:06.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译自：<a href="https://auth0.com/blog/2016/02/22/12-steps-to-a-faster-web-app/" target="_blank" rel="external">12 steps to a faster web app</a></p>
</blockquote>
<p>现在，web app 日益重视用户的交互体验，了解性能优化的方式则可以有效提高用户体验。阅读和实践下面的性能优化技巧，可以帮你改善应用的流畅度、渲染时间和其他方面的性能表现。</p>
<a id="more"></a>
<h2 id="概述">概述</h2><p>对 web app 进行性能优化是一份冗杂沉重的工作，这不仅是因为构建一个 web app 需要前后端协作，而且需要多方面的技术栈：数据库、后端、前端，需要运行在多种平台：iOS，安卓，Chrome，Firefox，Edge。这太复杂了！不过，还是有一些历经实践的通用方式可以用来优化 web app 的性能。在接下来的小节中，我们将逐步介绍相关的细节。</p>
<blockquote>
<p>一份来自 Bing 的研究表明，页面加载时间每增加 10ms，每年就会减少 $250k 的收入。</p>
</blockquote>
<h4 id="过早优化">过早优化</h4><p>性能优化的难点在于找出开发中值得优化的地方。Donald Knuth 说过一句经典的话：“过早的优化是一切罪恶的根源”。这句话背后的意思是说：花费大量时间改善 1% 的性能毫无意义。同时，某些优化方案反倒影响了可读性或可维护性，甚至引入了新的问题。换言之，性能优化不应该被视为“榨干应用程序性能的方法”，而应该视为“对性能和收益的平衡性所进行的探索”。在践行以下优化技巧时一定要牢记，盲目优化会影响生产效率，甚至得不偿失。最好的方式是使用分析工具来查找性能瓶颈，并在性能优化和开发效率、可维护性等方面保持平衡。</p>
<blockquote>
<p>开发者浪费了大量的时间去思考或者担心程序的执行速度，但实际上从调试和后期维护的角度看，这些优化措施往往会带来严重的负面影响。我们应该着重 97% 的运行表现：过早的性能优化是一切罪恶的根源。当然，我们也不应该放弃 3% 的痛点。</p>
</blockquote>
<h2 id="1-_文件压缩和模块打包">1. 文件压缩和模块打包</h2><p>JavaScript 通常是直接使用源码的方式分发的，而源码解析起来往往要慢于字节码。对于小脚本来说，两者解析的速度并不大，但对于大的应用程序来说，则会明显影响应用程序的启动速度。解决这一痛点，正是 <a href="https://auth0.com/blog/2015/10/14/7-things-you-should-know-about-web-assembly/" target="_blank" rel="external">WebAssembly</a> 的出发点之一，它将大幅改善程序的启动速度。文件压缩是剔除文件中无用字符的流程，虽然处理后的代码丧失了可读性，但提高了浏览器的解析速度。</p>
<p>另一方面，模块打包可以将不同的脚本合并为一个脚本，从而降低 HTTP 请求，减少资源加载时间。通常来说，这种工作都会交给相应的工具来处理，比如 <a href="https://webpack.github.io/" target="_blank" rel="external">Webpack</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"Sample "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">    insert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压缩之后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">o</span>)</span>&#123;<span class="keyword">if</span>(e[o])<span class="keyword">return</span> e[o].exports;<span class="keyword">var</span> n=e[o]=&#123;exports:&#123;&#125;,id:o,loaded:!<span class="number">1</span>&#125;;<span class="keyword">return</span> r[o].call(n.exports,n,n.exports,t),n.loaded=!<span class="number">0</span>,n.exports&#125;<span class="keyword">var</span> e=&#123;&#125;;<span class="keyword">return</span> t.m=r,t.c=e,t.p=<span class="string">""</span>,t(<span class="number">0</span>)&#125;([<span class="function"><span class="keyword">function</span>(<span class="params">r,t</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">r</span>)</span>&#123;<span class="built_in">document</span>.write(<span class="string">"Sample "</span>+r)&#125;<span class="keyword">for</span>(<span class="keyword">var</span> o=<span class="number">0</span>;<span class="number">30</span>&gt;o;++o)e(o)&#125;]);</span><br><span class="line"><span class="comment">//# sourceMappingURL=bundle.min.js.map</span></span><br></pre></td></tr></table></figure>
<h4 id="深度打包">深度打包</h4><p>使用 Webpack，我们也可以压缩 CSS 和合并图片，进一步改善程序的启动速度。更多有关 Webpack 的信息请参考<a href="http://webpack.github.io/docs/" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="2-_按需加载">2. 按需加载</h2><p>按需加载资源或者说惰性加载资源（特别是图片）对优化 web app 的性能有很大帮助。对于图片较多的页面，使用惰性加载通常有以下三点好处：</p>
<ul>
<li>减少并发请求，缓解服务器压力，提高加载速度</li>
<li>减少浏览器的内存占用率</li>
<li>降低服务器的负载</li>
</ul>
<p>图片或其他资源惰性加载的方案一般是，在程序启动时加载首屏资源，在页面滚动时持续加载即将进入视口的资源。由于这种方法往往需要与页面结构和开发方式相协调，所以常常使用现有的插件和扩展来实现惰性加载。举例来说，<a href="https://github.com/loktar00/react-lazy-load" target="_blank" rel="external">react-lazy-load</a> 是一个基于 React 的图片惰性加载插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = () =&gt; (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">    Scroll to load images.</span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"filler"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">LazyLoad</span> <span class="attribute">height</span>=<span class="value">&#123;762&#125;</span> <span class="attribute">offsetVertical</span>=<span class="value">&#123;300&#125;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">'http://apod.nasa.gov/apod/image/1502/HDR_MVMQ20Feb2015ouellet1024.jpg'</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">LazyLoad</span>&gt;</span></span><br><span class="line">    (...)</span></span><br></pre></td></tr></table></figure>
<p>一个典型的按需加载实例就是谷歌的<a href="https://www.google.com/search?site=&amp;tbm=isch&amp;source=hp&amp;biw=1366&amp;bih=707&amp;q=parrots&amp;oq=parrots&amp;gs_l=img.12...0.0.0.4086.0.0.0.0.0.0.0.0..0.0....0...1ac..64.img..0.0.0.UJrFBFKkWMA" target="_blank" rel="external">图片搜索工具</a>，点击这一链接并滚动页面，打开开发者工具注意资源的加载时间。</p>
<h2 id="3-_array-ids">3. array-ids</h2><p>如果你正在使用 React / Ember / Angular 或者其他操作 DOM 的第三方库，那么使用 array-ids（或者是 Angular 1.x 中的 <code>track-by</code> 特性）可以有效提高页面性能，对动态网站的性能优化尤为突出。从最新的基准测试中我们也可以看出其中的优势：<a href="https://auth0.com/blog/2016/01/11/updated-and-improved-more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/" target="_blank" rel="external">More Benchmarks: Virtual DOM vs Angular 1 &amp; 2 vs Mithril.js vs cito.js vs The Rest (Updated and Improved!)</a>。</p>
<p><img src="https://cdn.auth0.com/blog/newdombenchs2/usedheap.svg" alt="https://cdn.auth0.com/blog/newdombenchs2/usedheap.svg"></p>
<p>其背后的核心概念就是尽可能多地重复利用现有节点。Array-ids 便于 DOM 操作引擎根据获取到的 DOM 节点与真实的节点相匹配。如果没有 array-id 或者 track-by，大多数第三方库都会简单粗暴的删除节点然后再创建节点，这会严重影响程序的执行速度。</p>
<h2 id="4-_缓存">4. 缓存</h2><p>缓存常用来存储频繁调用的数据，当缓存后的数据再次被调用时，就可以由缓存直接提供数据，提高数据的响应速度。通常来说，一个 web app 都是由多个组件构成的，在这些组件中都能发现缓存的影子。比如动态内容服务器和客户端之间使用的缓存，通过减少通用请求降低服务器负载，可以改善页面的响应时间；比如代码中的缓存处理，可以优化某些通用的脚本访问模式。此外，还有数据库缓存和长进程缓存等。</p>
<p>简而言之，缓存是改善应用程序响应速度和降低 CPU 负载的有效方式。在一个开发体系中，最难的不是如何使用缓存，而是找出哪里适合使用缓存。对于这一问题，我还是建议使用事件分析工具（profiler）：找出性能瓶颈，检测缓存是否成功，测试缓存是否容易失效……这些问题都需要历经实践才能得出有效的结论。</p>
<p>使用缓存可以优化资源加载，比如，使用 <a href="https://addyosmani.com/basket.js/" target="_blank" rel="external">basket.js</a> 利用本地存储缓存应用的脚本，在第二次调用资源时可以迅速从本地存储中获得相应的资源。</p>
<p>Amazon CloudFront 是现在比较流行的一项缓存服务。CloudFront 的工作机制类似内容分发网络（CDN），可以为动态内容设置缓存。</p>
<h2 id="5-_HTTP/2">5. HTTP/2</h2><p>目前，已经有越来越多的浏览器支持 HTTP/2。HTTP/2 的优势在于它与服务器的并发连接，比如，如果需要加载的小型资源（前提是你不对资源进行打包）比较多，HTTP/2 在响应时间和性能上都要远远优胜于 HTTP/1。你可以点击 <a href="https://http2.akamai.com/demo" target="_blank" rel="external">Akamai 的 HTTP/2 示例</a> 查看两者的区别。</p>
<p><img src="https://cdn.auth0.com/blog/fasterweb/http2demo.png" alt="https://cdn.auth0.com/blog/fasterweb/http2demo.png"></p>
<h2 id="6-_性能剖析">6. 性能剖析</h2><p>性能剖析是应用程序进行性能优化的重要步骤。如上文所说，盲目地优化应用程序往往会降低生产力、产生新的痛点且难以维护。性能剖析的作用就是要找出应用程序中潜在的风险区域。</p>
<p>对 web 应用程序来说，响应速度是一个非常重要的衡量指标，所以开发者都会尽可能地去提高资源的加载速度和页面的渲染速度。Chrome 浏览器提供了一系列优秀的性能剖析工具，其中最常用的就是开发者工具中的 timeline 和 network，善用它们可以准确定位有关响应速度的风险区域。</p>
<p><img src="https://cdn.auth0.com/blog/fasterweb/timeline.png" alt="https://cdn.auth0.com/blog/fasterweb/timeline.png"></p>
<p>timeline 面板便于快速查找耗时操作。</p>
<p><img src="https://cdn.auth0.com/blog/fasterweb/network.png" alt="https://cdn.auth0.com/blog/fasterweb/network.png"></p>
<p>network 面板便于定位由请求时间和串行加载引起的响应速度问题。</p>
<p>此外，如果合理分析内存的使用率，也将有效提高应用程序的性能。如果你的页面中有大量的视觉元素（比如动态的表格）或者大量的交互元素（比如游戏），那么对内存使用的剖析就可以有效减少卡顿，提高帧速。如果你想了解如何在 Chrome 开发者工具中进行内存剖析，请参考这篇文章：<a href="https://auth0.com/blog/2016/01/26/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="external">《4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them 》</a>。</p>
<p>Chrome 开发者工具也可以对 CPU 的使用进行剖析，更多详细信息请参考来自谷歌文档的这篇文章：<a href="https://developer.chrome.com/devtools/docs/cpu-profiling" target="_blank" rel="external">《 Profiling JavaScript Performance》</a>。</p>
<p><img src="https://cdn.auth0.com/blog/fasterweb/cpu.png" alt="https://cdn.auth0.com/blog/fasterweb/cpu.png"></p>
<p>找出性能的核心痛点，才能让你更加高效地进行性能优化。</p>
<p>相对而言，对后端进行性能剖析稍显困难。一般而言，从最耗时的请求入手查找相应的服务器是个不错的方法。这里并没有推荐任何有关后端的性能剖析工具，这是因为具体的剖析工具要视具体的后端技术栈而定。</p>
<h4 id="算法">算法</h4><p>在大多数情况下，选择更高效的算法可以比局部优化获得更佳的收益。从某种意义上说，对 CPU 和内存进行性能剖析有助于帮助开发者找出应用程序中较大的性能瓶颈。如果这些瓶颈并不是由代码的错误引起的，那很有可能就是算法的问题。</p>
<h2 id="7-_负载均衡">7. 负载均衡</h2><p>在上文的缓存一节中，简单提到了内容分发网络（CDN）的概念。根据服务器或者地理区域分发负载可以有效提高资源的响应速度，这一优势在处理并发链接时尤为明显。</p>
<p>简而言之，负载均衡类似于一种轮询方案，基于反向代理服务器 <a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank" rel="external">nginx</a> 或者成熟的分发网络（比如 <a href="https://www.cloudflare.com/" target="_blank" rel="external">Cloudflare</a> 和 <a href="https://aws.amazon.com/cloudfront/" target="_blank" rel="external">Amazon CloudFront</a> 构建。</p>
<p><img src="https://cdn.auth0.com/blog/fasterweb/diagram.png" alt="https://cdn.auth0.com/blog/fasterweb/diagram.png"></p>
<p>为了实现负载均衡，需要将动态内容和静态内容进行分离，便于执行并行连接。换言之，串行访问削弱了负载均衡检索最佳路径并进行分发的能力。此外，并行加载资源还可以加快应用程序的启动速度。</p>
<p>负载均衡也可以构建的很精细。如果数据模型不能够很好地与最终的一致性算法或缓存保持良好的匹配关系，那么必将导致诸多问题。幸运的是，大多数的应用程序所请求的数据都是一个缩减集，该缩减集本身具有较高级别的一致性。如果你的应用程序还没有具备这样的能力，那么你需要考虑重构它了。</p>
<h2 id="8-_同构_JavaScript">8. 同构 JavaScript</h2><p>对于 web 应用程序来说，一个增强用户体验的法门就是减少启动时间或者减少首屏渲染时间，这一点对于需要在客户端执行大量逻辑操作的单页应用尤为重要。在客户端执行的逻辑操作越多，通常意味着需要在首屏渲染前加载更多的资源。同构 JavaScript 就是用来解决这一问题的：JavaScript 可以同时在客户端和服务端执行，所以可以在服务端渲染出来首屏，然后将其发送给客户端，再由客户端的 JavaScript 接手剩下的逻辑处理。这一方案限制了服务端只能基于 JavaScript 框架，但可以提高用户体验。目前，在 <a href="https://www.meteor.com/" target="_blank" rel="external">Meteor.js</a> 中已经可以直接使用这一方式了。此外，在 <a href="https://github.com/DavidWells/isomorphic-react-example" target="_blank" rel="external">React</a> 框架中也可以采用这种方式，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react/addons'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactApp = React.createFactory(<span class="built_in">require</span>(<span class="string">'../components/ReactApp'</span>).ReactApp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// React.renderToString takes your component</span></span><br><span class="line">        <span class="comment">// and generates the markup</span></span><br><span class="line">        <span class="keyword">var</span> reactHtml = React.renderToString(ReactApp(&#123;&#125;));</span><br><span class="line">        <span class="comment">// Output html rendered by react</span></span><br><span class="line">        <span class="comment">// console.log(myAppHtml);</span></span><br><span class="line">        res.render(<span class="string">'index.ejs'</span>, &#123;reactOutput: reactHtml&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是 Meteor.js 的简单示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Meteor.isClient) &#123;</span><br><span class="line">  Template.hello.greeting = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Welcome to myapp."</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Template.hello.events(&#123;</span><br><span class="line">    <span class="string">'click input'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// template data, if any, is available in 'this'</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">console</span> !== <span class="string">'undefined'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"You pressed the button"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Meteor.isServer) &#123;</span><br><span class="line">  Meteor.startup(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// code to run on server at startup</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你开发的是大中型复杂应用且支持同构发布，那么可以尝试一下这种方式，效果很可能令人震撼。</p>
<h2 id="9-_索引">9. 索引</h2><p>如果数据库查询占据了太多的执行时间，那么你应该考虑优化数据库的执行速度了。每种数据库和数据模型都各有特色。数据库优化有多种方向：数据模型、数据库类型以及其他配置，所以优化起来并不简单。不过，我们还是有一些通用的优化技巧，比如说：索引。索引根据数据库的数据创建快速访问的数据结构，改善对特定数据的检索速度。现在大多数的数据库都支持索引功能，</p>
<p>在使用索引优化数据库之前，你应该研究当前应用程序的访问模式，分析最常用到的查询是什么，哪一个键或者字段会被频繁查询等等。</p>
<h2 id="10-_编译工具">10. 编译工具</h2><p>JavaScript 技术栈日益复杂，这也推动了语言本身的进步。不幸的是，JavaScript 的发展目前还要受限于用户的访问环境。虽然 ECMAScript 2015 已经对 JavaScript 做出了诸多改进，但是开发者尚不能直接遵循这一规范的代码。针对这一问题，也就衍生出了诸多编译工具，这些工具常用于将 ECMAScript 2015 的代码转换为 ECMAScript 5 的代码。此外，模块打包和文件压缩也加入到了编译过程，最终用于生成线上版本的代码。这些工具将代码转换为了一个受限的版本，间接影响到了最终代码的执行效率。谷歌开发者 Paul Irish 测试了代码转换对性能和文件大小的影响，详情请<a href="https://github.com/paulirish/The-cost-of-transpiling-es2015-in-2016" target="_blank" rel="external">点击链接</a>。虽然大多数情况下影响甚微，但这些差异仍然值得引起注意，因为随着应用程序的复杂大增高，这些差异也将日益增大。</p>
<h2 id="11-_阻塞渲染">11. 阻塞渲染</h2><p>JavaScript 和 CSS 资源的加载都会阻塞页面的渲染过程。通过某些技巧，开发者可以尽快加载 JavaScript 和 CSS 资源，从而让浏览器尽快显示网站的内容。</p>
<p>对 CSS 来说，本质上符合当前页面媒体属性的 CSS 规则会具有较高的处理优先级。页面的媒体属性由 CSS 的媒体查询进行匹配。媒体查询通知浏览器哪一个 CSS 脚本针对哪一种媒体属性。举例来说，相对于当前屏幕显示的 CSS，用于打印的 CSS 的优先级较低。</p>
<p>可以为 <code>&lt;link&gt;</code> 标签设置与媒体查询有关的属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">media</span>=<span class="value">"only screen and (max-device-width: 480px)"</span> <span class="attribute">href</span>=<span class="value">"mobile-device.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>对 JavaScript 来说，关键是恰当地使用内嵌 JavaScript（即在 HTML 中的 JavaScript）。内嵌 JavaScript 应该尽可能简短，且不能阻塞对页面其他部分的阻塞。换言之，位于 HTML 文档树之中的内嵌 JavaScript 会阻塞 HTML 脚本的解析，强制解析引擎直到脚本执行完成才能继续解析。如果 HTML 树中有大量这种阻塞脚本或者阻塞时间过长，势必严重破坏应用程序的用户体验。内嵌 JavaScript 有助于防止网络获取过多的脚本。对于反复用到的脚本，或者体积较大的脚本，不建议使用内联形式。</p>
<p>一种有效防止 JavaScript 阻塞 HTML 解析的方法是以异步的方式加载 <code>&lt;script&gt;</code> 标签。这种方式限制了我们队 DOM 的访问（无法使用 <code>document.write</code>)，但可以让浏览器在解析和渲染页面的时候无需考虑 JavaScript 的执行状态。换言之，为了获取最佳的启动速度，应该确保所有非必需的脚本都要以异步的形式加载：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"async.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="12-_servce_workers_和_stream">12. servce workers 和 stream</h2><p>Jake Archibald 的<a href="https://jakearchibald.com/2016/streams-ftw/#streaming-results" target="_blank" rel="external">最新文章</a> 对提高渲染速度提出了一个很有意思的方案：结合 service workers 和 stream 进行页面渲染。结果相当令人信服：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Cjo9iq8k-bc" frameborder="0" allowfullscreen></iframe>

<p>不幸的是，这一技巧所用到的 API 尚在变化之中，所以还不能应用于实际开发中。这一技巧的核心是在网站和客户端之间存放一个 service worker。service worker 可以用于缓存数据（比如网站的头部等不常变动的部分），避免网络查找失败。如果缓存数据丢失，可以通过 stream 快速获取。</p>
<h2 id="扩展阅读">扩展阅读</h2><p>更多有关性能优化的信息和工具请参考以下链接：</p>
<p><a href="https://github.com/paulirish/The-cost-of-transpiling-es2015-in-2016" target="_blank" rel="external">Best Practices for Speeding up Your Website - Yahoo Developer Network</a><br><a href="http://yslow.org/" target="_blank" rel="external">YSlow - a tool that checks for Yahoo’s recommended optimizations</a><br><a href="https://developers.google.com/speed/docs/insights/rules" target="_blank" rel="external">PageSpeed Insights - Google Developers</a><br><a href="https://developers.google.com/speed/pagespeed/" target="_blank" rel="external">PageSpeed Tools - Google Developers</a><br><a href="http://blogs.msdn.com/b/ie/archive/2014/10/08/http-2-the-long-awaited-sequel.aspx" target="_blank" rel="external">HTTP/2: The Long-Awaited Sequel</a></p>
<h2 id="结论">结论</h2><p>随着应用程序变得越来越庞大和复杂，性能优化在 web 开发中的地位也越来越重要。针对性的性能优化至关重要，有助于降低时间成本和维护成本。web 应用程序历经发展，其作用已经不再是单一的内容展现，学习通用的性能优化模式，可以将一个难以使用的应用程序转为一个易于上手的工具。没有任何规则是绝对的，只有不断研究和剖析技术栈的深层次逻辑，才能合理进行性能优化。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译自：<a href="https://auth0.com/blog/2016/02/22/12-steps-to-a-faster-web-app/">12 steps to a faster web app</a></p>
</blockquote>
<p>现在，web app 日益重视用户的交互体验，了解性能优化的方式则可以有效提高用户体验。阅读和实践下面的性能优化技巧，可以帮你改善应用的流畅度、渲染时间和其他方面的性能表现。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lazy Loading Images on the Web]]></title>
    <link href="http://pinggod.com/2016/Lazy-loading-images-on-the-web/"/>
    <id>http://pinggod.com/2016/Lazy-loading-images-on-the-web/</id>
    <published>2016-02-17T04:00:04.000Z</published>
    <updated>2016-02-24T05:31:50.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Summarized from <a href="http://developer.telerik.com/featured/lazy-loading-images-on-the-web/" target="_blank" rel="external">《Lazy Loading Images on the Web》</a>.</p>
</blockquote>
<p>Lazy loading images on the web means only download images which are in or near the viewport, and don’t load any other images that visitors will not likely see. To accomplish this effect, we just need a little bit of JavaScript.</p>
<p>At its most basic implementation always need to do:</p>
<ul>
<li>Build HTML with special data attribute</li>
<li>Watch changes to the viewport or scrolling</li>
<li>Swap the data attribute to src attribute</li>
</ul>
<a id="more"></a>
<h2 id="Plain_JavaScript">Plain JavaScript</h2><p>The first step is creating HTML element with data attribute:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">data-src</span>=<span class="value">"path/to/source"</span> <span class="attribute">alt</span>=<span class="value">""</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Second, using <code>getBoundingClientRect()</code> to test whether an image is within the viewport:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isElementInViewport</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rect = el.getBoundingClientRect();</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        rect.top &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        rect.left &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        rect.bottom &lt;= (<span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight) &amp;&amp;</span><br><span class="line">        rect.right &lt;= (<span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Last, geting all of images that we want to lazy load and swap the <code>data-src</code> value to <code>src</code> value:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//these handlers will be removed once the images have loaded</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, lazyLoadImages);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, lazyLoadImages);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, lazyLoadImages);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, lazyLoadImages);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoadImages</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">"#main-wrapper img[data-src]"</span>),</span><br><span class="line">        item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load images that have entered the viewport</span></span><br><span class="line">    [].forEach.call(images, <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isElementInViewport(item)) &#123;</span><br><span class="line">            item.setAttribute(<span class="string">"src"</span>,item.getAttribute(<span class="string">"data-src"</span>));</span><br><span class="line">            item.removeAttribute(<span class="string">"data-src"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if all the images are loaded, stop calling the handler</span></span><br><span class="line">    <span class="keyword">if</span> (images.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">"DOMContentLoaded"</span>, lazyLoadImages);</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">"load"</span>, lazyLoadImages);</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">"resize"</span>, lazyLoadImages);</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">"scroll"</span>, lazyLoadImages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Plugin_&amp;&amp;_Library">Plugin &amp;&amp; Library</h2><p>The following is some jquery plugins or libraries that can do similarly works:</p>
<ul>
<li><a href="https://github.com/tuupola/jquery_lazyload" target="_blank" rel="external">https://github.com/tuupola/jquery_lazyload</a></li>
<li><a href="http://dinbror.dk/blazy/" target="_blank" rel="external">http://dinbror.dk/blazy/</a></li>
<li><a href="http://luis-almeida.github.io/unveil/" target="_blank" rel="external">http://luis-almeida.github.io/unveil/</a></li>
<li><a href="https://github.com/ressio/lazy-load-xt" target="_blank" rel="external">https://github.com/ressio/lazy-load-xt</a></li>
</ul>
<h2 id="Responsive_images_service">Responsive images service</h2><p>Why we need this? Using this service to get responsive images. For example, we can upload a huge image in backend and download appropriate image based on the device’s screen size and pixel density to compresse response size.</p>
<blockquote>
<p>Before generating different dimensions images, it’s better to use image compression tool to reduce file size, such like <a href="https://tinypng.com/" target="_blank" rel="external">https://tinypng.com/</a>. </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Summarized from <a href="http://developer.telerik.com/featured/lazy-loading-images-on-the-web/">《Lazy Loading Images on the Web》</a>.</p>
</blockquote>
<p>Lazy loading images on the web means only download images which are in or near the viewport, and don’t load any other images that visitors will not likely see. To accomplish this effect, we just need a little bit of JavaScript.</p>
<p>At its most basic implementation always need to do:</p>
<ul>
<li>Build HTML with special data attribute</li>
<li>Watch changes to the viewport or scrolling</li>
<li>Swap the data attribute to src attribute</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML5 Canvas]]></title>
    <link href="http://pinggod.com/2016/HTML5-canvas/"/>
    <id>http://pinggod.com/2016/HTML5-canvas/</id>
    <published>2016-02-16T05:17:10.000Z</published>
    <updated>2016-02-28T14:39:46.000Z</updated>
    <content type="html"><![CDATA[<p>Canvas 是 HTML5 新引进的特性，通过 Canvas 技术可以使用 JavaScript 在浏览器中绘制图形。目前主流浏览器（IE9+）都支持该特性。创建一个最简单的 canvas 只需要两步，第一步是创建一个 canvas 标签： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">canvas</span> <span class="attribute">id</span>=<span class="value">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="title">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来使用 JavaScript 获取 canvas 的上下文：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#canvas'</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>大功告成！</p>
<h2 id="修改大小">修改大小</h2><p>canvas 画布的默认尺寸为 300px * 150px，如果想要修改该尺寸，可以在 canvas 标签上添加 width 和 height 属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">canvas</span> <span class="attribute">id</span>=<span class="value">"canvas"</span> <span class="attribute">width</span>=<span class="value">"500"</span> <span class="attribute">height</span>=<span class="value">"500"</span>&gt;</span><span class="tag">&lt;/<span class="title">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>width 和 height 属性不仅仅指定了画布的大小，而且同时制定了画布的分辨率。另一个值得注意的是，不用给这两个属性值添加单位。如果画布的尺寸不确定，还可以使用 JavaScript 进行控制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.width = <span class="number">500</span>;</span><br><span class="line">canvas.height = <span class="number">500</span>;</span><br></pre></td></tr></table></figure>
<h2 id="画线">画线</h2><p>在 canvas 中画线只需要三行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// move context to position (100, 100)</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// draw a line from current position of context to (500, 500)</span></span><br><span class="line">ctx.lineTo(<span class="number">500</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// all above was not executed util calling stroke or fill method</span></span><br><span class="line">ctx.stroke()</span><br></pre></td></tr></table></figure>
<p>下面是常用的 context 方法：</p>
<ul>
<li><code>lienWidth</code>, 设置线段的粗细</li>
<li><code>lineCap</code>, 设置线段两端的样式： <code>butt(default)</code> / <code>round</code> / <code>square</code></li>
<li><code>lineJoin</code>, 设置两条线段连接处的样式：<code>miter(default)</code> / <code>bevel</code> / <code>round</code></li>
<li><code>strokeStyle</code>, 设置线段的颜色</li>
<li><code>stroke</code>，绘制线段</li>
<li><code>fillStyle</code>, 设置填充区域的颜色</li>
<li><code>fill</code>, 填充一段区域</li>
</ul>
<blockquote>
<p>使用 <code>beginPath()</code> 和 <code>closePath()</code> 可以绘制多条独立的线段：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath() </span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">500</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.fillStyle = <span class="string">"green"</span>;</span><br><span class="line">ctx.fill();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">"yellow"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="绘制矩形">绘制矩形</h2><p><code>ctx.rect(x, y, width, height)</code> 方法可以用来绘制一个矩形:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cxt.beginPath();</span><br><span class="line">cxt.rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">cxt.closePath();</span><br><span class="line"></span><br><span class="line">cxt.lineWidth = <span class="number">10</span>;</span><br><span class="line">cxt.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">cxt.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line"></span><br><span class="line">cxt.fill();</span><br><span class="line">cxt.stroke();</span><br></pre></td></tr></table></figure>
<p>下面是两个更简洁的矩形绘制方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cxt.lineWidth = <span class="number">10</span>;</span><br><span class="line">cxt.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">cxt.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line"></span><br><span class="line">cxt.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">cxt.strokeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h2 id="画圆">画圆</h2><p><code>ctx.arc(x, y, r, startAngle, endAngle, anticlockwise)</code> 方法可以用来绘制一个圆形，圆形位于 (x, y)，半径为 r，起始点为 <code>startAngle</code>，终点为 <code>endAngle</code>，<code>anticlockwise</code> 决定旋转方向，默认值为顺时针方向。</p>
<canvas id="arc-canvas-demo"></canvas>

<style>
#arc-canvas-demo {
    display: block;
    width: 100px;
    height: 100px;
    margin: 0 auto;
}
</style>

<script>
(function() {
    "use strict";
    var canvas = document.querySelector('#arc-canvas-demo');
    var ctx = canvas.getContext('2d');
    if (ctx) {
        canvas.width = 100;
        canvas.height = 100;
        ctx.beginPath();
        ctx.arc(50, 50, 50, 0, 1.5 * Math.PI);
        ctx.closePath()
        ctx.lineWidth = 1;
        ctx.fillStyle = "#42b983";
        ctx.fill();
    }
    else {
        canvas.innerHTML = "Update your browser to enjoy canvas :) !"
    }
})();
</script>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">1.5</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">ctx.closePath()</span><br><span class="line">ctx.lineWidth = <span class="number">1</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">"#42b983"</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ctx.clearrect(xTopLeft, yTopLeft, xBottomRight, yBottomRight)</code> 方法可以用来清除特定区域。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Canvas 是 HTML5 新引进的特性，通过 Canvas 技术可以使用 JavaScript 在浏览器中绘制图形。目前主流浏览器（IE9+）都支持该特性。创建一个最简单的 canvas 只需要两步，第一步是创建一个 canvas 标签： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">canvas</span> <span class="attribute">id</span>=<span class="value">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="title">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来使用 JavaScript 获取 canvas 的上下文：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#canvas'</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tmux]]></title>
    <link href="http://pinggod.com/2016/Tmux/"/>
    <id>http://pinggod.com/2016/Tmux/</id>
    <published>2016-02-13T05:09:06.000Z</published>
    <updated>2016-02-13T10:45:07.000Z</updated>
    <content type="html"><![CDATA[<p>Recently, I am learning some different programming languages which exciting and a little bit tired. Why tired? Coding, testing code and taking notes always need two or three panes in one shell window for each programming language every time, and this is where tmux comes in.</p>
<p><img src="/img/tmux-structure.png" alt="tmux-demo"></p>
<blockquote>
<p>Tmux is a terminal multiplexer, and it lets developers switch easily between programs in one termial, detach them and reattach them to a different terminal. </p>
</blockquote>
<a id="more"></a>
<h2 id="Key_bindings">Key bindings</h2><p>The GitHub repo <a href="https://github.com/gpakosz/.tmux" target="_blank" rel="external">.tmux</a> is a pretty and versatile self-contained tmux configuration which I am using. <code>C-a</code> is the prefix key provided by this repo, while we can keep use default <code>C-b</code> prefix. The following tables show common key bindings which come into play with prefix key, from session to pane:</p>
<p><strong>SESSION KEY BINGDINGS</strong></p>
<ul>
<li><code>tmux ls</code>，显示所有 session</li>
<li><code>tmux new -s session-name</code>，新建 session</li>
<li><code>tmux attach -t session-name</code>，进入 session</li>
<li><code>tmux kill-session -t session-name</code>，关闭 session</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Key</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-f</td>
<td style="text-align:left">find session</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:left">hang-up session</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:left">reload configuration</td>
</tr>
</tbody>
</table>
<p><strong>WINDOW KEY BINGDINGS</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Key</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:left">create new window</td>
</tr>
<tr>
<td style="text-align:center">,</td>
<td style="text-align:left">rename current window</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:left">list all windows</td>
</tr>
<tr>
<td style="text-align:center">f</td>
<td style="text-align:left">find window</td>
</tr>
<tr>
<td style="text-align:center">0~9</td>
<td style="text-align:left">switch window according to serial number</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:left">exit tmux and close current window</td>
</tr>
<tr>
<td style="text-align:center">space</td>
<td style="text-align:left">adjust layout</td>
</tr>
</tbody>
</table>
<p><strong>PANE KEY BINGDINGS</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Key</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">create new pane with horizontal direction</td>
</tr>
<tr>
<td style="text-align:center">“</td>
<td style="text-align:left">create new pane with vertical direction</td>
</tr>
<tr>
<td style="text-align:center">hjkl</td>
<td style="text-align:left">switch pane</td>
</tr>
<tr>
<td style="text-align:center">HJKL</td>
<td style="text-align:left">adjust layout size of panes</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:left">cycle panes</td>
</tr>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:left">display serial number of panes</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:left">close current pane</td>
</tr>
<tr>
<td style="text-align:center">{/}</td>
<td style="text-align:left">switch postion of panes</td>
</tr>
<tr>
<td style="text-align:center">Enter</td>
<td style="text-align:left">enter copy-mode</td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:left">clear pane and history</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>Recently, I am learning some different programming languages which exciting and a little bit tired. Why tired? Coding, testing code and taking notes always need two or three panes in one shell window for each programming language every time, and this is where tmux comes in.</p>
<p><img src="/img/tmux-structure.png" alt="tmux-demo"></p>
<blockquote>
<p>Tmux is a terminal multiplexer, and it lets developers switch easily between programs in one termial, detach them and reattach them to a different terminal. </p>
</blockquote>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Truthy and Falsy]]></title>
    <link href="http://pinggod.com/2016/Truthy-and-Falsy/"/>
    <id>http://pinggod.com/2016/Truthy-and-Falsy/</id>
    <published>2016-02-12T02:30:54.000Z</published>
    <updated>2016-02-17T05:16:21.000Z</updated>
    <content type="html"><![CDATA[<p>Truty value and falsy value is a little bit different from Boolean value. In JavaScript, the truthy value is strict equal to <code>true</code> when evaluated in a Boolean context, and the falsy value is evaluted to <code>false</code>.</p>
<p>The following value is common falsy value:</p>
<ul>
<li>false</li>
<li>null</li>
<li>undefined</li>
<li>0</li>
<li>NaN</li>
<li>‘’</li>
<li>document.all</li>
</ul>
<a id="more"></a>
<p>All value are truthy value except falsy value:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!!&#123;&#125; === <span class="literal">true</span></span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">!!<span class="built_in">document</span>.all === <span class="literal">false</span></span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<h6 id="Reference">Reference</h6><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" target="_blank" rel="external">MDN - Truthy</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" target="_blank" rel="external">MDN - Falsy</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Truty value and falsy value is a little bit different from Boolean value. In JavaScript, the truthy value is strict equal to <code>true</code> when evaluated in a Boolean context, and the falsy value is evaluted to <code>false</code>.</p>
<p>The following value is common falsy value:</p>
<ul>
<li>false</li>
<li>null</li>
<li>undefined</li>
<li>0</li>
<li>NaN</li>
<li>‘’</li>
<li>document.all</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mongodb]]></title>
    <link href="http://pinggod.com/2016/mongodb/"/>
    <id>http://pinggod.com/2016/mongodb/</id>
    <published>2016-01-28T07:58:12.000Z</published>
    <updated>2016-02-09T13:52:13.000Z</updated>
    <content type="html"><![CDATA[<p>Mongodb 提供了 Homebrew 的安装方式，安装过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install mongodb</span><br><span class="line">mkdir -p /data/db</span><br><span class="line">chmod u+rw /data/db</span><br><span class="line">mongod</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Mongodb 安装完全后，在 bin 文件夹下有以下可执行程序：</p>
<ul>
<li><code>mongod</code>，mongodb 的执行和部署程序</li>
<li><code>mongo</code>，连接 mongodb 服务器的客户端</li>
<li><code>mongoimport / mongoexport</code>，mongodb 数据导入导出程序</li>
<li><code>mongoreestore / mongodump</code>，mongodb 二进制数据导入导出程序，常用做数据备份和恢复</li>
<li><code>mongooplog</code>，操作日志记录程序</li>
<li><code>mongostat</code>，mongodb 状态监控和查询程序</li>
</ul>
<p>Mongodb 数据库的简单组成结构及分工职责：</p>
<ul>
<li><code>data</code>，存储数据库的数据文件</li>
<li><code>log</code>，存储数据库的日志文件</li>
<li><code>bin</code>，存储数据库的可执行文件</li>
<li><code>conf</code>，存储数据库的配置文件</li>
</ul>
<p>创建一个轻量的 Mongodb 数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir mongodb-in-action</span><br><span class="line"><span class="built_in">cd</span> mongodb-in-action</span><br><span class="line">mkdir data <span class="built_in">log</span> conf bin</span><br><span class="line">cp /usr/<span class="built_in">local</span>/Cellar/mongodb/<span class="number">3.2</span>.<span class="number">1</span>/bin/&#123;mongod,mongo&#125; ./bin/</span><br><span class="line">touch conf/mongod.conf</span><br></pre></td></tr></table></figure>
<p><code>conf/mongod.conf</code> 是这个数据库的配置文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">dbpath = data</span><br><span class="line">logpath = <span class="built_in">log</span>/mongod.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否启用后台进程</span></span><br><span class="line">fork = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>然后使用指定的配置文件启动 Mongodb 服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/mongod <span class="operator">-f</span> ./conf/mongod.conf</span><br></pre></td></tr></table></figure>
<p>接下来我们使用 <code>mongo</code> 连接数据库，连接之前查看 <code>mongo --help</code> 信息：</p>
<ul>
<li>查看第二行的 <code>usage</code> 了解使用方式</li>
<li>查看第三行开始的示例了解连接格式</li>
<li>查看 options 字段下的内容了解可用参数</li>
<li>查看 Authentication Options 字段下的内容了解认证登录的方式</li>
</ul>
<p>接下来连接 <code>mongodb-in-action</code> 的 test 数据库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/mongo <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">12345</span>/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>在 mongo 客户端中关闭 mongodb 数据库：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.shutdownServer()</span><br></pre></td></tr></table></figure>
<h2 id="基本操作">基本操作</h2><p>Mongodb 数据库的常用操作：</p>
<ul>
<li><code>show dbs</code>，显示所有数据库</li>
<li><code>use dbname</code>，切换到 dbname 数据库</li>
<li><code>db.dropDatabase()</code>，删除当前数据库</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示集合</span></span><br><span class="line">show collections</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单插入数据</span></span><br><span class="line">db.imooc_collections.insert(&#123; x: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单查询数据</span></span><br><span class="line">db.imooc_collections.find()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Javascript 语法插入多条数据</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    db.imooc_collections.insert(&#123; x: i * <span class="number">5</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计数据量</span></span><br><span class="line">db.imooc_collections.find().count()</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip() 跳过数据</span></span><br><span class="line"><span class="comment">// limit() 限制返回的数据长度</span></span><br><span class="line"><span class="comment">// sort() 数据排序</span></span><br><span class="line">db.imooc_collections.find().skip(<span class="number">3</span>).limit(<span class="number">2</span>).sort(&#123;x:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单更新数据</span></span><br><span class="line">db.imooc_collections.update( &#123;x: <span class="number">1</span>&#125;, &#123;x: <span class="number">999</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 $set 操作符进行局部更新</span></span><br><span class="line">db.imooc_collections.insert( &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span>&#125; )</span><br><span class="line">db.imooc_collections.update( &#123; y: <span class="number">2</span> &#125;, &#123; $set: &#123; z: <span class="number">0</span> &#125; &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mongodb 默认更新找到的第一条数据</span></span><br><span class="line"><span class="comment">// 同时更新多条数据需要是，第二个 JSON 参数必须是 $set </span></span><br><span class="line"><span class="comment">// 第三个参数表示匹配不到数据时自动插入更新数据</span></span><br><span class="line"><span class="comment">// 第四个参数表示是否同时更新多条记录</span></span><br><span class="line">db.imooc_collections.update( &#123; x: <span class="number">999</span> &#125;, &#123; $set: &#123; x: <span class="number">321</span> &#125; &#125;, <span class="literal">false</span>, <span class="literal">true</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据使用 remove()，该方法参数不能为空</span></span><br><span class="line">db.imooc_collections.remove( &#123;x: <span class="number">0</span>&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除整个集合或者表</span></span><br><span class="line">db.imooc_collections.drop()</span><br></pre></td></tr></table></figure>
<h2 id="索引">索引</h2><p>索引是对数据库单列或多列进行排序的结构，使用索引可以快速访问数据库中的特定信息。Mongodb 中的索引主要分为以下几种：</p>
<ul>
<li>_id 索引。_id 索引是大多数集合默认创建的索引类型，对于每一个插入的数据，Mongodb 都会自动生成一条唯一的 _id 字段</li>
<li>单键索引，单键索引是最普通的索引，值为单一的值，比如字符串、数值或日期，不会自动创建</li>
<li>多键索引，与单键索引不同的地方就在于它的值可以是复合类型数据</li>
<li>复合索引，用于有多个查询条件的情景中</li>
<li>过期索引，指在特定时间后会过期的索引，索引过期后，相应的数据也会被删除，常用于存储登录信息、存储日志等数据。存储在过期索引字段的值必须是指定的事件类型（ISODate 或者 ISODate 数组)</li>
<li>全文索引，对字符串和字符串数组创建全文可搜索的索引</li>
<li>地理位置索引，</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看字段是否存在</span></span><br><span class="line">db.imooc_collections.find(&#123; x: &#123; $exists: <span class="literal">true</span> &#125; &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前集合的所有索引</span></span><br><span class="line">db.imooc_collections.getIndexes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单键索引</span></span><br><span class="line">db.imooc_collections.ensureIndex(&#123; x: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多键索引</span></span><br><span class="line"><span class="comment">// 如果插入的是数组，默认添加多键索引</span></span><br><span class="line">db.imooc_collections.insert(&#123; x: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建复合索引</span></span><br><span class="line">db.imooc_collections.ensureIndex(&#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建过期数据</span></span><br><span class="line">db.imooc_collections.insert(&#123; x: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建过期索引</span></span><br><span class="line">db.imooc_collections.ensureIndex(&#123; x: <span class="number">1</span> &#125;, &#123; expireAfterSeconds: <span class="number">10</span> &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建全文索引</span></span><br><span class="line">db.articles.ensureIndex(&#123; key: <span class="string">"text"</span> &#125;)</span><br><span class="line">db.articles.ensureIndex(&#123; k_1: <span class="string">"text"</span>, k_2: <span class="string">"text"</span> &#125;)</span><br><span class="line">db.articles.ensureIndex(&#123; <span class="string">"$**"</span>: <span class="string">"text"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全文索引示例</span></span><br><span class="line">db.article.insert(&#123; <span class="string">"article"</span>: <span class="string">"aa bb cc"</span> &#125;)</span><br><span class="line">db.article.insert(&#123; <span class="string">"article"</span>: <span class="string">"aa bb cc dd"</span> &#125;)</span><br><span class="line">db.article.insert(&#123; <span class="string">"article"</span>: <span class="string">"aa bb cc dd ee"</span> &#125;)</span><br><span class="line">db.article.find(&#123; $text: &#123; $search: <span class="string">"cc"</span> &#125; &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全文索引相似度查询</span></span><br><span class="line">db.article.find(&#123; </span><br><span class="line">        $text: &#123; $search: <span class="string">"aa bb"</span> &#125; </span><br><span class="line">    &#125;, &#123; </span><br><span class="line">        score: &#123; $meta: <span class="string">"textScore"</span> &#125; </span><br><span class="line">&#125;)</span><br><span class="line">.sort(&#123; </span><br><span class="line">    score: &#123; $meta: <span class="string">"textScore"</span> &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>全文索引支持相似度查询，相似度查询的格式是在查询条件后添加字段：<code>{ score: { $meta: &quot;textScore&quot; } }</code>，配合 sort 方法可以根据相似度对搜索结果进行排序。全文查找的注意点：</p>
<ul>
<li><code>$search: &quot;aa bb cc&quot;</code>，查询匹配 aa/bb/cc 其中之一的项</li>
<li><code>$search: &quot;aa bb -cc&quot;</code>，查询匹配 aa/bb 其中之一但不包含 cc 的项</li>
<li><code>$search: &quot;\&quot;aa\&quot; \&quot;bb\&quot;&quot;</code>，查询同时包含 aa/bb 的项</li>
</ul>
<p>索引的四个重要特性，这四个特性也是 ensureIndex() 的四个可选参数：</p>
<ul>
<li>名字</li>
<li>唯一性</li>
<li>稀疏性</li>
<li>是否定时删除</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.imooc.ensureIndex(</span><br><span class="line">    &#123; x: <span class="number">1</span> &#125;, </span><br><span class="line">    &#123; name: <span class="string">"xIndex"</span> &#125;,</span><br><span class="line">    &#123; unique: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; sparse: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; expireAfterSconds: <span class="number">10</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="地理位置索引">地理位置索引</h2><p>地址位置索引用于在 mongodb 中存储位置信息，创建后，各个位置之间可以相互检索。地理位置索引分为两类：2d 索引，用于存储和查找平面上的点；2dsphere 索引，用于存储和查找球面上的点。查找方式主要有两种：查找距离某个点一定距离内的点；查找包含在某个区域中的点。</p>
<p>在 2d 索引中指定区域有以下三种格式：</p>
<ol>
<li><code>$box: [ [lx, ly], [rx, ry] ]</code>，指定矩形</li>
<li><code>$center: [ [x, y], r ]</code>，指定圆形</li>
<li><code>$polygon: [ [x1, y1], [x2, y2], [x3, y3] ]</code>，指定多边形</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建地理位置数据</span></span><br><span class="line">db.localindex.insert(&#123; w: [<span class="number">1</span>,<span class="number">1</span>] &#125;)</span><br><span class="line">db.localindex.insert(&#123; w: [<span class="number">1</span>,<span class="number">2</span>] &#125;)</span><br><span class="line">db.localindex.insert(&#123; w: [<span class="number">2</span>,<span class="number">2</span>] &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 2d 索引</span></span><br><span class="line">db.localindex.ensureIndex(&#123; w: <span class="string">"2d"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 [1, 1] 查询附近的点</span></span><br><span class="line"><span class="comment">// 匹配的点和 [1, 1] 的最大距离为 10</span></span><br><span class="line">db.localindex.find(&#123; w: &#123; $near: [<span class="number">1</span>, <span class="number">1</span>], $maxDistance: <span class="number">10</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在矩形区域内查找某个点</span></span><br><span class="line">db.localindex.find(&#123; w: &#123; $geoWithin: &#123; $box: [ [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1.5</span>, <span class="number">2.5</span>] ] &#125; &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在圆形区域内查找某个点</span></span><br><span class="line">db.localindex.find(&#123; w: &#123; $geoWithin: &#123; $center: [ [<span class="number">1</span>,<span class="number">1</span>], <span class="number">1</span> ] &#125; &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在多边形区域内查找某个点</span></span><br><span class="line">db.localindex.find(&#123;w: &#123;$geoWithin: &#123;$polygon: [[<span class="number">0</span>, <span class="number">0</span>],[<span class="number">1</span>, <span class="number">0</span>],[<span class="number">1</span>, <span class="number">3</span>]]&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 2dsphere 索引</span></span><br><span class="line">db.localindex.ensureIndex(&#123; w: <span class="string">"2dsphere &#125;)</span></span><br></pre></td></tr></table></figure>
<h2 id="索引构建分析">索引构建分析</h2><p>评判索引构建情况的四种工具：</p>
<ol>
<li>mongostat</li>
<li>profile 集合</li>
<li>日志</li>
<li>explain</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Mongodb 提供了 Homebrew 的安装方式，安装过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install mongodb</span><br><span class="line">mkdir -p /data/db</span><br><span class="line">chmod u+rw /data/db</span><br><span class="line">mongod</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Counters]]></title>
    <link href="http://pinggod.com/2016/CSS-Counters/"/>
    <id>http://pinggod.com/2016/CSS-Counters/</id>
    <published>2016-01-25T04:23:35.000Z</published>
    <updated>2016-01-26T04:31:20.000Z</updated>
    <content type="html"><![CDATA[<p>Several years ago, a question was rasied by someone on Weibo: how to code the module of calculating commodity price, which plays a big role in Taobao commodity detail pages. Usually at the detail page, the commodity has many options, such like size and color. The amount will change real time when users change their options. This question is not noly business-oriented, but also has many solving methods. JS came to my mind first at the time.</p>
<p>The last two weeks, I’m digesting technical posts which collected in Pocket and Weibo over past three years. There are many Best Practice in it, such like CSS Counters which the rest is going to say. </p>
<a id="more"></a>
<p>CSS Counters is proposed in CSS2.1, so not only modern browsers, but also IE8+ support it. CSS Counters is a auto-counter, and it should coordinate with pseudo-classes <code>::before</code> and <code>::after</code> to use。</p>
<h2 id="Property">Property</h2><p>CSS Counters have a series of property or method to use:</p>
<ul>
<li><code>counter-reset</code>, used to initialize a counter. It receives two parameters: the first is a string identifier, and the second is a optional number which used to initialize counter’s default value.   </li>
<li><code>counter-increment</code>, used to increse the counter’s value, and it receives a optional number parameter. If the optional parameter exsits, the counter will plus it instead of the default value one.</li>
<li><code>counter()</code>, used to get counter’s result in the <code>content</code> property.</li>
</ul>
<h2 id="Usage">Usage</h2><p>As metioned above, we could use counter-reset property to defined a counter. Look at the following html structure:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>And styles:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span><span class="value">: li-counter <span class="number">10</span>;</span></span><br><span class="line">    <span class="tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">counter-increment</span><span class="value">: li-counter <span class="number">2</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">p</span><span class="pseudo">::before</span> &#123;</span><br><span class="line">        <span class="attribute">content</span><span class="value">: <span class="function">counter</span>(li-counter);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Based on above code fragments, counter called “li-counter” was created, and its initial value is 10. At the li tag, counter-increment comes in and increse the counter’s vlaue. Finally, p tag was created with pseudo-class <code>::before</code> to display the counter’s end result.</p>
<h2 id="Example">Example</h2><div class="counter-wrap"><ul class="row"><li class="price-10"><input type="radio" name="color" id="white"><label for="white">White(+10)</label></li><li class="price-13"><input type="radio" name="color" id="red"><label for="red">Red(+13)</label></li><li class="price-15"><input type="radio" name="color" id="green"><label for="green">Green(+15)</label></li></ul><ul class="row"><li class="price-4"><input type="radio" name="size" id="small"><label for="small">Small(+4)</label></li><li class="price-8"><input type="radio" name="size" id="large"><label for="large">Large(+8)</label></li></ul><ul class="row"><li class="price-total"></li></ul></div>

<style>
@charset "UTF-8";
.counter-wrap {
  width: 360px;
  margin: 0 auto;
  counter-reset: price 10;
}

.counter-wrap ul.row {
  margin: 2px 2px 2px 0;
  padding: 0;
  list-style-type: none;
}

.counter-wrap li {
  display: inline-block;
  margin: 10px 2px;
  text-align: center;
}

.counter-wrap input {
  position: absolute;
  clip: rect(0 0 0 0);
}

.counter-wrap label {
  padding: 10px 16px;
  color: white;
  background-color: #79BD8F;
  border-radius: 5px;
}

.counter-wrap input:checked + label {
  background-color: #F06161;
}

.counter-wrap input#small:checked {
  counter-increment: price 4;
}

.counter-wrap input#large:checked {
  counter-increment: price 8;
}

.counter-wrap input#white:checked {
  counter-increment: price 10;
}

.counter-wrap input#red:checked {
  counter-increment: price 13;
}

.counter-wrap input#green:checked {
  counter-increment: price 15;
}

.counter-wrap li.price-total {
  padding: 10px 16px;
  background-color: #BEEB9F;
  border-radius: 5px;
}
.counter-wrap li.price-total::before {
  content: "$" counter(price);
  color: #D83C65;
  font-weight: bold;
}
</style>

<p>As you can see, here is a simple commodity form with multiple options. If you click colors or sizes, the amount will change real time. With this approach, code is cleaner and more robust.</p>
<p>For more infomation about this example, you could look over my Codepen playground via this <a href="http://codepen.io/pinggod/pen/JGpVNx?editors=1100" target="_blank" rel="external">link</a>.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Several years ago, a question was rasied by someone on Weibo: how to code the module of calculating commodity price, which plays a big role in Taobao commodity detail pages. Usually at the detail page, the commodity has many options, such like size and color. The amount will change real time when users change their options. This question is not noly business-oriented, but also has many solving methods. JS came to my mind first at the time.</p>
<p>The last two weeks, I’m digesting technical posts which collected in Pocket and Weibo over past three years. There are many Best Practice in it, such like CSS Counters which the rest is going to say. </p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[WEB 开发者必看的技术站点]]></title>
    <link href="http://pinggod.com/2015/%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E7%9C%8B%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AB%99%E7%82%B9/"/>
    <id>http://pinggod.com/2015/开发者必看的技术站点/</id>
    <published>2015-12-31T06:49:13.000Z</published>
    <updated>2016-01-25T04:24:19.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文总结自 Quora 上的一个问答：<a href="https://www.quora.com/What-are-the-top-10-websites-a-web-developer-must-see" target="_blank" rel="external">What are the top 10 websites a web developer must see</a>。</p>
</blockquote>
<p>读专业书、看教程视频、浏览技术博客、参加讲座分享……这些提高技能的途径各有优劣，相比较而言，博客或者说技术网站可以最快接触前沿技术、分享技术实践，所以，除了依赖谷歌反馈的词条，我们还可以主动收集一些优秀的技术站点，便于自己了解、参与和实践业界最活跃的技术。</p>
<a id="more"></a>
<ol>
<li><p><a href="https://github.com" target="_blank" rel="external">GitHub</a> —— 当下最流行的版本管理工具，云集了世界上最优秀的开发者。在 GitHub 开源之风盛行，我喜欢在这里关注各类优秀项目，也喜欢在这里查找各种工具，比如需要某个 alfred 的插件，在这里搜一下也许就能找到，如果遇到了问题，和开发者反馈一下也不是什么难事。最近喜欢浏览 trending 和 follow 大神，便于了解业界动态，顺便细化下自己的技术栈。</p>
</li>
<li><p><a href="http://alistapart.com/" target="_blank" rel="external">A List Apart</a>—— 我想给这个网站定义几个头衔，比如顶级、前沿、经典、最具影响力之类等等。这个网站创办十八年了（from 1998），专注对前端方向的探索，每一篇文章都是深入思考的结晶。典型的文章就是<a href="http://alistapart.com/article/responsive-web-design" target="_blank" rel="external">《Responsive Web Design》</a>，发表之后迅速启发了业界的开发思维，打开了响应式设计的大门。</p>
</li>
<li><p><a href="https://developer.mozilla.org" target="_blank" rel="external">MDN</a> —— Mozilla 开发者网络知识库，权威、全面的 WEB 文档，支持多种语言，示例丰富。</p>
</li>
<li><p><a href="http://stackoverflow.com/" target="_blank" rel="external">Stack Overflow</a> —— 活跃的技术问答社区。一般问题都有开发者问过了，如果找不到，换一换关键字，最后的方式才应该是提问。作为开发者，为了使用 Stack Overflow 也应该给自己准备一个翻墙工具，永远不要闭门造车般的解决问题。</p>
</li>
<li><p><a href="http://caniuse.com/" target="_blank" rel="external">Can I Use</a> —— 如果你有兼容性问题，先来这里看看浏览器的支持情况吧。</p>
</li>
<li><p><a href="https://css-tricks.com/" target="_blank" rel="external">CSS-Tricks</a> —— 这里发表所有和 CSS 有关的技巧和教程，当然如果你想来这里找点黑科技，也是有的。</p>
</li>
<li><p><a href="http://tympanus.net/codrops/" target="_blank" rel="external">Codrops</a> —— 如果有一天我可以靠理想生活，那我肯定要先实践一番 Codrops 上的教程，这些教程的效果绝对出彩，这也是前端吸引我的魅力所在。</p>
</li>
<li><p><a href="http://codepen.io/" target="_blank" rel="external">CodePen</a> —— 在线 WEB 开发工具。一方面我们可以在这里快速实践自己的灵感，另一方面当我们的调试遇到困境，在这里搭一个 DEMO 详细描述下问题，然后发给有经验的人，绝对是最佳的问答礼仪。</p>
</li>
<li><p><a href="https://dribbble.com/" target="_blank" rel="external">Dribble</a> —— 作为前端开发者，要求我们必须具备一定的审美水平，来 Dribble 看看吧，你会重新燃起创造力的激情，比如用 WEB 技术实践几个 Driible 的原型图，那一定帅得不行不行的。</p>
</li>
<li><p><a href="http://csszengarden.com/" target="_blank" rel="external">CSS Zen Garden（CSS 禅意花园）</a>—— 现在网站的效果越来风格化，无论是简约还是拟物都十分精致，相比而言，来自上个年代的 CSS 禅意花园已经显得并不是很出彩了，但实际上其中还有很多重要的东西值得学习，建议各位读一读<a href="http://book.douban.com/subject/2052176/" target="_blank" rel="external"> CSS 禅意花园</a>这本书，看一下作者对各个主题的分析，了解从设计立意到编码开发的诸多思考。</p>
</li>
</ol>
<p>下面这些网站的内容大都涵盖了从 WEB 到设计、从图形到动效、从数据到运维的方方面面，是非常全面的技术站点：</p>
<ol>
<li><p><a href="https://dzone.com/" target="_blank" rel="external">DZone</a> —— Programming, Web Development, and DevOps news, tutorials and tools for beginners to experts. Hundreds of free publications, over 1M members, totally free.</p>
</li>
<li><p><a href="http://www.smashingmagazine.com/" target="_blank" rel="external">Smashing Magazine</a> —— Smashing Magazine is an online magazine for professional Web designers and developers, with a focus on useful techniques, best practices and valuable resources.</p>
</li>
<li><p><a href="http://www.sitepoint.com/" target="_blank" rel="external">SitePoint</a> —— Learn Web Design &amp; Development with SitePoint tutorials, courses and books - HTML5, CSS3, JavaScript, PHP, mobile app development, Responsive Web Design.</p>
</li>
<li><p><a href="http://www.codeproject.com/" target="_blank" rel="external">CodeProject</a> —— Free source code and tutorials for Software developers and Architects.; Updated: 2 Jan 2016.</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文总结自 Quora 上的一个问答：<a href="https://www.quora.com/What-are-the-top-10-websites-a-web-developer-must-see">What are the top 10 websites a web developer must see</a>。</p>
</blockquote>
<p>读专业书、看教程视频、浏览技术博客、参加讲座分享……这些提高技能的途径各有优劣，相比较而言，博客或者说技术网站可以最快接触前沿技术、分享技术实践，所以，除了依赖谷歌反馈的词条，我们还可以主动收集一些优秀的技术站点，便于自己了解、参与和实践业界最活跃的技术。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac Tool Kit]]></title>
    <link href="http://pinggod.com/2015/mac-tool-kit/"/>
    <id>http://pinggod.com/2015/mac-tool-kit/</id>
    <published>2015-12-26T10:17:00.000Z</published>
    <updated>2016-03-13T15:55:00.000Z</updated>
    <content type="html"><![CDATA[<p>这会是一篇持续更新的文章，用于记录我在 mac 中常用的开发工具。过去的一年（2015）里，我使用 mac 作为开发的主力平台，在上面折腾过各类软件，以实现最高的开发效率和最舒适的开发环境。一切都是为了开发成果服务，脱离结果强调过程不是我支持的态度，简而言之，这些都是一些增益技巧。</p>
<p>文中工具的排序规则（核心是优先安装具有依赖关系的软件）：</p>
<ol>
<li>从常用工具中随机选择一个工具作为 random seed</li>
<li>根据 random seed 的配置过程进行上溯，上溯到的目标工具排在 random seed 之前</li>
<li>如果上溯到的系统工具不常用，以常用工具替换，比如 chrome 替换 safari</li>
<li>random seed 可组合使用的工具排在 random seed 之后</li>
<li>random seed 中包含的插件在 random seed 中以列表的形式列出</li>
<li>每次接触新工具，将 random seed 设为该工具，循环执行 2、3、4 过程</li>
<li>其他工具根据肌肉对键盘的非条件反射随机排列</li>
</ol>
<p><img src="/img/mac-tool-kit.png" alt="mac tool kit 排列方法 2015-12-27.png"></p>
<a id="more"></a>
<h2 id="preparation">preparation</h2><p>在选择下文中的工具时，主要有两点参考标准：</p>
<ul>
<li>快速，指响应速度和切换速度，或者可以提高这两点的工具。目前键盘操作是无冲突下最快速的控制方式，所以这也是围绕速度进行评估的关键点。</li>
<li>界面有设计亮点，这纯属前端职业病</li>
</ul>
<div class="tip"><br>    初始化 mac 之后，依次进入系统偏好设置 -&gt; 键盘 -&gt; 修饰键，将 Caps Lock 键映射为 Control 键，别问为什么，用心去体会吧 —— Casp Lock 的功能价值与它在键盘布局中所占有的重要位置极度不相符。<br></div>

<h2 id="applications_list">applications list</h2><ol>
<li><p><a href="https://www.iterm2.com/downloads.html" target="_blank" rel="external">iTerm2</a>，终端工具，替代系统自带的终端，主题 <a href="https://github.com/zenorocha/dracula-theme" target="_blank" rel="external">dracula-theme</a>。</p>
<ul>
<li>Xcode command Line Tool，Homebrew 的依赖，可通过 <code>xcode-select --install</code> 命令或者安装 Xcode 来完成</li>
<li><a href="https://github.com/Flowerowl/ici" target="_blank" rel="external">ici</a>，终端词典，基于爱词霸词库 </li>
</ul>
</li>
<li><p><a href="https://developer.apple.com/cn/xcode/downloads/" target="_blank" rel="external">Xcode</a>，苹果产品开发环境，</p>
</li>
<li><p><a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a>，OS X 的包管理工具：</p>
<ul>
<li><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>，node 版本管理工具</li>
<li><a href="https://github.com/nodejs/node" target="_blank" rel="external">node</a>，运行在服务端的 JavaScript，使用 nvm 统一管理</li>
<li><a href="https://tmux.github.io/" target="_blank" rel="external">tmux</a>，终端复用工具</li>
<li><a href="http://mama.indstate.edu/users/ice/tree/" target="_blank" rel="external">tree</a>，树状结构目录</li>
<li><a href="https://www.python.org" target="_blank" rel="external">python / python3</a>，python 开发环境</li>
<li><a href="http://nginx.org/" target="_blank" rel="external">nginx</a>，反向代理服务器</li>
<li><a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external">httpie</a>，替代 curl 的 HTTP 终端工具</li>
<li><a href="https://asciinema.org/" target="_blank" rel="external">asciinema</a>，终端录屏工具</li>
</ul>
</li>
<li><p><a href="http://caskroom.io/" target="_blank" rel="external">Homebrew Cask</a>，使用 hombrew 安装，可用于安装 OS X 应用：</p>
<ul>
<li><a href="http://caskroom.io/search" target="_blank" rel="external">haskell platform</a>，haskell 开发环境</li>
</ul>
</li>
<li><p><a href="http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html" target="_blank" rel="external">Chrome / Chrome Canary</a>，插件众多，开发调试便利，平时也比较依赖谷歌体系内的东西。插件：</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/github-old-header/bbencfiifelhglgknaheifiekmjndlek" target="_blank" rel="external">GitHub Old Header</a>，在顶部导航区提供一个指向个人页面的链接</li>
<li><a href="https://chrome.google.com/webstore/detail/http-status/cknfnacbckhfpjahnmkblajcpledpfnp" target="_blank" rel="external">HTTP status</a>，在地址栏显示 HTTTP 状态码</li>
<li><a href="https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=zh-CN" target="_blank" rel="external">JSON Formatter</a>，格式化浏览器预览到的 JSON 数据</li>
<li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=zh-CN" target="_blank" rel="external">Octotree</a>，为 GitHub 仓库提供一个树状结构目录</li>
<li><a href="https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj?hl=zh-CN" target="_blank" rel="external">Save to Pocket</a>，右键保存到 Pocket</li>
</ul>
</li>
<li><p><a href="http://www.sublimetext.com/3" target="_blank" rel="external">Sublime Text 3</a>，编辑器，适用多平台响应迅速扩展能力强。插件：</p>
<ul>
<li><a href="https://packagecontrol.io/installation#st3" target="_blank" rel="external">Package Control</a>，Sublime 扩展插件的安装和管理工具</li>
<li><a href="https://packagecontrol.io/packages/DashDoc" target="_blank" rel="external">DashDoc</a>，调用 Dash</li>
<li><a href="http://emmet.io/" target="_blank" rel="external">Emmet</a>，前端开发工具集</li>
<li><a href="https://packagecontrol.io/packages/BracketHighlighter" target="_blank" rel="external">BracketHighlighter</a>，标签和符号的高亮工具</li>
<li><a href="https://packagecontrol.io/packages/SideBarEnhancements" target="_blank" rel="external">SideBarEnhancements</a>，侧边栏功能扩展插件</li>
<li><a href="https://github.com/equinusocio/material-theme" target="_blank" rel="external">Material Theme</a>，谷歌 material 风格的简洁主题</li>
<li><a href="https://packagecontrol.io/packages/Babel" target="_blank" rel="external">Babel</a>，JSX 和 ES6 的高亮插件，不具有编译功能</li>
<li><a href="https://packagecontrol.io/packages/DocBlockr" target="_blank" rel="external">DocBlockr</a>，Javascript, PHP, CoffeeScript, Actionscript, C &amp; C++ 规范化注释</li>
</ul>
</li>
<li><p><a href="https://kapeli.com/dash" target="_blank" rel="external">Dash</a>，开发文档、代码片段管理工具</p>
</li>
<li><p><a href="https://www.alfredapp.com/" target="_blank" rel="external">alfred</a>，必备辅助工具，提高工作效率，不要让双手离开键盘</p>
</li>
<li><p><a href="https://getpocket.com/" target="_blank" rel="external">Pocket</a>，离线阅读工具，也被用来做知识管理</p>
</li>
<li><p><a href="http://snip.qq.com/" target="_blank" rel="external">Snip</a>，滚动截屏必备工具</p>
</li>
<li><p><a href="http://realmacsoftware.com/ember/" target="_blank" rel="external">Ember</a>，图库管理，可以订阅 dribbble popular。</p>
</li>
<li><p><a href="https://products.office.com/zh-cn/mac/microsoft-office-for-mac" target="_blank" rel="external">Microsoft office</a>，我喜欢用 PowerPoint 来做流程图、序列图……</p>
</li>
<li><p><a href="http://www.irradiatedsoftware.com/sizeup/" target="_blank" rel="external">SizeUp</a>，管理应用程序窗口的位置和大小</p>
</li>
</ol>
<h2 id="host_configuration">host configuration</h2><p>最近在熟悉云主机的使用，下面是配置过程：</p>
<ol>
<li><p>ssh root 账号登录云主机，通过 <code>passwd</code> 命令更改主机密码，至于怎样设置结构复杂的密码，建议参考文章<a href="http://www.hello-code.com/diary/201409/2223.html" target="_blank" rel="external">《每一个程序员都有一颗当诗人的心》</a>。</p>
</li>
<li><p>使用 root 账号创建普通用户：<code>adduser sean</code>、<code>passwd sean</code>，然后为新用户配置权限，通过 <code>visudo</code> 命令添加 <code>sean ALL=(ALL) ALL</code> 配置信息，完成后退出 root 账户，使用普通账户登录云主机，比如这里的 sean。</p>
</li>
<li><p>安装常用工具：</p>
<ul>
<li><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a></li>
<li><a href="https://github.com/amix/vimrc" target="_blank" rel="external">amix/vimrc</a></li>
<li><a href="https://github.com/bling/vim-airline" target="_blank" rel="external">bling/vim-airline</a></li>
<li><a href="https://github.com/powerline/fonts" target="_blank" rel="external">powerline/fonts</a></li>
<li><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a></li>
<li><a href="https://github.com/nodejs/node" target="_blank" rel="external">node</a></li>
<li><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="external">node:tldr</a></li>
<li><a href="https://packages.debian.org/search?keywords=tree" target="_blank" rel="external">apt-get:tree</a></li>
</ul>
</li>
</ol>
<h2 id="tldr">tldr</h2><p>不断地在中英文间进行切换也是非常低效率的操作，所以，初步设定在 2016 年底脱离非业务开发下对中文输入的依赖——不过我最喜欢的哲学思维还是先秦百家交叉融汇出的框架。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这会是一篇持续更新的文章，用于记录我在 mac 中常用的开发工具。过去的一年（2015）里，我使用 mac 作为开发的主力平台，在上面折腾过各类软件，以实现最高的开发效率和最舒适的开发环境。一切都是为了开发成果服务，脱离结果强调过程不是我支持的态度，简而言之，这些都是一些增益技巧。</p>
<p>文中工具的排序规则（核心是优先安装具有依赖关系的软件）：</p>
<ol>
<li>从常用工具中随机选择一个工具作为 random seed</li>
<li>根据 random seed 的配置过程进行上溯，上溯到的目标工具排在 random seed 之前</li>
<li>如果上溯到的系统工具不常用，以常用工具替换，比如 chrome 替换 safari</li>
<li>random seed 可组合使用的工具排在 random seed 之后</li>
<li>random seed 中包含的插件在 random seed 中以列表的形式列出</li>
<li>每次接触新工具，将 random seed 设为该工具，循环执行 2、3、4 过程</li>
<li>其他工具根据肌肉对键盘的非条件反射随机排列</li>
</ol>
<p><img src="/img/mac-tool-kit.png" alt="mac tool kit 排列方法 2015-12-27.png"></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES2015]]></title>
    <link href="http://pinggod.com/2015/ES2015/"/>
    <id>http://pinggod.com/2015/ES2015/</id>
    <published>2015-12-15T06:07:10.000Z</published>
    <updated>2016-02-01T01:01:27.000Z</updated>
    <content type="html"><![CDATA[<p>ES2015 是最新的 JavaScript 语法规范，也是前端工程化高速发展所催化出的产物。JS 的不成熟一直为人诟病，前端的高速发展又离不开 JS，所以这次激进的变革显得十分必要。</p>
<p>虽然 ES2015 规范发布了，但是要原生的运行在浏览器上还是受到诸多因素的肘制，比如各版本浏览器的用户量、浏览器厂商对新特性的支持度等等。目前的权宜之计是使用 Babel 之类的编译器将 ES2015 代码转换为 ES5，所以下文中的 ES2015 代码也暂时以 Babel 的解析结果为准。各版本浏览器对 ES2015（ES6）、ES2016（ES7）的支持度可以参考这里：<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">ES2015 兼容性列表</a>。</p>
<a id="more"></a>
<h2 id="块级作用域和变量声明">块级作用域和变量声明</h2><p>ES6 新增了以花括号 <code>{}</code> 为标志的块级作用域，用以增强代码的稳健性。在 ES6 之前，JS 中只有全局作用域和函数作用域（eval 作用域？我没用过），这种设计有多种弊端，比如最常见的循环变量泄露为全局变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]());</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>虽然循环结束了，但是 i 的值在全局作用域内仍然有效，进而形成了一系列的错误。对于这种错误，最常见的处理方式是使用立即执行函数（Immediately-Invoked Function Expression）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>这里用到的立即执行函数实际上是将<a href="http://pinggod.com/2015/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/">求值策略</a>从延迟求值转变为了预先求值，但仍然不够优雅和健壮。在 ES2015 中，通过使用 <code>let</code> 来声明循环变量同样可以解决这个问题，而且方式更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]());</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p><code>let</code> 和 <code>const</code> 是 ES2015 新增的变量声明指令：let 用来声明变量，const 用来声明常量。当使用 let 和 const 声明变量时，所声明的变量只在当前的块级作用域内有效，这一点是与 var 的本质差别，也是上述代码生效的基础。对于 var 时代的各种诡异特性，现在 let 和 const 做了一些修改：</p>
<ul>
<li>let 和 const 声明的变量不存在变量提升</li>
<li>let 和 const 声明的变量不允许在同一作用域内重复声明多次</li>
<li>let 和 const 声明的变量必须先声明后使用，否则抛出 ReferenceError</li>
</ul>
<p>从块级作用域的开始到 let 和 const 变量声明的区域被称为临时死区（temporal dead zone），意指此处调用未声明的 let 和 const 变量一定报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    temp = <span class="string">'abc'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// blablablabla</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该行代码之前都属于变量 temp 的 temporal dead zone</span></span><br><span class="line">    <span class="comment">// 意指在此之前不可使用变量 temp</span></span><br><span class="line">    <span class="keyword">let</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tip"><br>    在浏览器环境下，使用 var 声明的全局变量都会挂载在全局对象 window 下面。ES 2015 规定，使用 var 和 function 声明的全局变量仍然挂载在全局对象下面，但是 let、const 和 class 声明的全局变量则不属于全局对象。<br></div>


<h2 id="解构赋值">解构赋值</h2><p>解构赋值是 ES2015 提供的一种语法糖操作，常用于简化对数组和对象的数据提取。可以使用解构赋值的数据类型包括：</p>
<ul>
<li>对象</li>
<li>字符串</li>
<li>数值和布尔值（自动转换为对象，然后调用 toString() ）</li>
<li>数组，以及具有 Iterator 结构的数据结构，比如 Set 等</li>
</ul>
<p>下面我们通过一些实例来看一下解构赋值的使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 交换两个数的值</span></span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取 JSON 数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">JSON</span> = &#123;</span><br><span class="line">    id: <span class="number">12345</span>,</span><br><span class="line">    status: <span class="string">'OK'</span>,</span><br><span class="line">    data: [<span class="number">123</span>, <span class="number">456</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; id, status, data &#125; = <span class="built_in">JSON</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 按需加载模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; Route, DefaultRoute, HistoryLocation &#125; = ReactRouter; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从函数返回多个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStyle</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> font = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> border = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> position = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> &#123; font, border, position &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    font: fontStyle,</span><br><span class="line">    border: borderStyle,</span><br><span class="line">    position: positionStyle</span><br><span class="line">&#125; = handleStyle();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解构赋值可以以 <code>[x = &#39;0&#39;] = [y]</code> 的形式设置默认值，当 y 不存在时，x 的值就是 0；如果 y 不存在且没有设置默认值，则会被自动赋值为 undefined。</p>
</blockquote>
<h2 id="字符串">字符串</h2><p>在 JS 内部，字符以 16 位 2 字节的格式存储，这种表示法的范围限制为 \u0000-\uFFFF，对于超出范围的字符（\u20BB7），会被解析为两个字符四个字节（\u20BB\u0007）。ES2015 增强了对 Unicode 的支持，提出了一种新的字符表示方法：\u{20BB7}。</p>
<p>对于新的字符表示形式 <code>\u{codePoint}</code>，传统的字符串方法已经不适用了，所以 ES2015 提出了一系列新的方法来替代，它们可以正确识别编码大于 \uFFFF 的字符：</p>
<ul>
<li>at()，对应 charAt()，返回指定位置的字符</li>
<li>codePointAt()，对应 charCodeAt()，返回指定位置字符的编码</li>
<li>String.fromCodePoint()，对应 String.fromCharCode()，返回指定编码所对应的字符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'\u20BB7'</span></span><br><span class="line"><span class="comment">// =&gt; '₻7'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span></span><br><span class="line"><span class="comment">// =&gt; '𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.charAt(<span class="number">0</span>)   </span><br><span class="line"><span class="comment">// =&gt; '�'</span></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.at(<span class="number">0</span>)       </span><br><span class="line"><span class="comment">// =&gt; "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// =&gt; 20BB7</span></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.codePointAt(<span class="number">1</span>).toString(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// =&gt; DFB7</span></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// =&gt; DFB7</span></span><br><span class="line"></span><br><span class="line"><span class="string">'a\u&#123;20BB7&#125;b'</span>.length</span><br><span class="line"><span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'a\u&#123;20BB7&#125;b'</span>).length</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>ES2015 规范中规定字符串实现了 Iterator 接口，用于 for … of 遍历，此外，增加了一些工具类方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"abcdefghi"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串 str 是否以参数字符串开头</span></span><br><span class="line">str.startsWith(<span class="string">'abc'</span>);</span><br><span class="line"><span class="comment">// 判断字符串 str 是否包含参数字符串</span></span><br><span class="line">str.includes(<span class="string">'def'</span>);</span><br><span class="line"><span class="comment">// 判断字符串 str 是否以参数字符串结尾</span></span><br><span class="line">str.endsWith(<span class="string">'ghi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成重复字符串</span></span><br><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; 'xxx'</span></span><br></pre></td></tr></table></figure>
<p>字符串的另一个强力扩展是：模板字符串和标签模板。模板字符串（template string）类似于其他编程语言中的字符串插值，以反引号（`）为标志，字符串中的插值部分使用 <code>${}</code> 包裹：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// =&gt; '3 + 4 = 7'</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数的函数名之后紧跟一个模板字符串，那么这个函数就会被用来处理这个模板字符串，这个功能被称为<code>标签模板（tagged template）</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是一个数组</span></span><br><span class="line"><span class="comment">// 数组的元素是被插值部分分隔的字符串</span></span><br><span class="line"><span class="comment">// 第二个及以后的参数代表模板字符串中插值部分的值</span></span><br><span class="line"><span class="comment">// 可以使用参数扩展语法将其包裹到一个变量中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strs);</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// =&gt; [""," + "," = ",""]</span></span><br><span class="line"><span class="comment">// =&gt; [3,4,7]</span></span><br></pre></td></tr></table></figure>
<p>标签模板的一个实际运用就是过滤 HTML 字符串，提高安全性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeHTML</span> (<span class="params">strs, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    strs.forEach( (str, index) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="built_in">String</span>(values[index]);</span><br><span class="line"></span><br><span class="line">        result += str;</span><br><span class="line">        <span class="keyword">if</span> ( temp ) &#123;</span><br><span class="line">            result += temp.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">                          .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'$lt;'</span>)</span><br><span class="line">                          .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gc;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="string">'&lt;html tag&gt;'</span>;</span><br><span class="line"><span class="keyword">const</span> msg = safeHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;user&#125;</span> has sent you a msg.&lt;/p&gt;`</span>;</span><br><span class="line"><span class="comment">// =&gt; &lt;p&gt;$lt;html tag&amp;gc; has sent you a msg.&lt;/p&gt;undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="数值">数值</h2><p>数值部分，一个是在 Number 对象上丰富了一些工具函数</p>
<ul>
<li>Nubmer.isNaN()</li>
<li>Number.isFinite()</li>
<li>Number.parseInt()</li>
<li>Nubmer.parseFloat()</li>
<li>Nnmber.isInteger()</li>
<li>Number.EPSILON，极小量常量，在数值比对时，如果小于极小量，则判断两数相等</li>
<li>Number.isSafeInteger()，安全范围指（-2^53，2^53）</li>
<li>Number.MAX_SAFE_INTEGER</li>
<li>Number.MIN_SAFE_INTEGER</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseFloat === <span class="built_in">Number</span>.parseFloat</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt === <span class="built_in">Number</span>.parseInt</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// =&gt; 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span> &lt; <span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>二是在 Math 对象上扩展了一些数学函数：</p>
<ul>
<li>Math.trunc()，去除浮点数的小数部分</li>
<li>Math.sign()，判断数值是正数、负数还是零</li>
<li>Math.cbrt()，计算一个数值的立方根</li>
<li>Math.clz32()，返回一个数值的 32 位无符号整数形式前前导零的个数</li>
<li>Math.imul()</li>
<li>Math.fround()</li>
<li>Math.hypot()</li>
<li>Math.expn1()</li>
<li>Math.log1p()</li>
<li>Math.log10()</li>
<li>Math.log2()</li>
<li>Math.sinh()</li>
<li>Math.cosh()</li>
<li>Math.tanh()</li>
<li>Math.asinh()</li>
<li>Math.acosh()</li>
<li>Math.atanh()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">3.1415926</span>);</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// =&gt; 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2><p>在函数中，参数对象 arguments 是一个具有 length 属性的对象，这一类对象被称为类数组对象（array-like object），常见的类数组对象包括 arguments 对象和 DOM 操作返回的 NodeList 集合，对于此类类数组对象，我们往往希望可以将其转换为数组，方便调用数组的方法对数据进行处理。在 ES6 中有一个方法专门用于转换类数组对象为真正的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="string">'0'</span>: <span class="string">'a'</span>, length: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.from(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// =&gt; [ "a", undefined ]</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可知，对象中的 length 属性确定了转换后数组的长度，索引不匹配的位置返回 undefined，此外 Array.from() 还接受第二个参数，用于对 obj 数据进行 map 处理。此外，对于 ES6 新增的 Set 和 Map 数据结构，也可以使用 Array.from() 转换为数组。</p>
<p>在前面我们遇到了字符串编码大于 \uFFFF 时，字符长度会被误判的问题，这种情况下可以使用 Array.from() 将字符串转换为数组，获取数组的长度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span>.length</span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">"𠮷"</span>).length;</span><br><span class="line"><span class="comment">// =&gt;  1</span></span><br></pre></td></tr></table></figure>
<p>数组的构造函数 Array() 一直存在行为不确定的问题（一个参数表示新建数组长度，多个参数表示新建数组的组成元素），对此 ES6 提出了 Array.of() 方法来构建数组。Array.of() 方法接收任意多个参数，这些参数就是返回数组的元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">'a'</span>, &#123;&#125;, [], <span class="built_in">Symbol</span>())</span><br><span class="line"><span class="comment">// =&gt; [ 1, "a", Object, Array[0], Symbol() ]</span></span><br></pre></td></tr></table></figure>
<p>在众多的数组方法中，有那么一类方法非常值得警惕，这类方法的危险性在于，它们可以修改数组自身的数据，常见方法有：<strong>pop() / push() / shift() / unshift() / reverse() / sort() / splice()</strong>。在 ES6 中也存在两个可以修改数组自身的方法：copyWithin() 和 fill()：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copyWithin(arrayStart[, copyStart, copyEnd])</span></span><br><span class="line"><span class="comment">// arrayStart: 从数组的该位置开始修改数据</span></span><br><span class="line"><span class="comment">// copyStart: 从数组的该位置开始取数据</span></span><br><span class="line"><span class="comment">// copyEnd: 从数组的该位置停止取数据</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// =&gt; [ 4, 2, 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fill(num, start, end) 方法可以用于数据重置</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].fill(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// =&gt; [ 1, 2, 3, 0, 5 ]</span></span><br></pre></td></tr></table></figure>
<p>新增的 find() 和 some() 类似，都需要一个回调函数对遍历到的元素进行判断，不同点在于，find() 返回符合条件的第一个值，some() 则是在遇到复合条件的元素时返回 true；另一个新增的 findIndex() 与 indexOf() 类似，用于在数组中查找特定值的索引，不同之处在于 findIndex() 接收一个回调函数，indexOf() 接收的是一个值，此外，findIndex() 配合 Object.is 可以发现 NaN：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>].indexOf(y =&gt; <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// =&gt; -1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>].findIndex(y =&gt; <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>此外，我们还可以使用 includes() 方法来判断是否存在：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>对于数组的遍历，ES6 提供了更精细的方法 entries() / keys() / values()，分别是对键值对、键和值的遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> value <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 'a'</span></span><br><span class="line"><span class="comment">// =&gt; 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, value]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; [ 0, "a" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ 1, "b" ]</span></span><br></pre></td></tr></table></figure>
<p>最后，值得一提的是，babel 编译已经支持了数组推导式（ES7），这一推到式在 Haskell 和 python 中都有实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> years = [ <span class="number">1954</span>, <span class="number">1974</span>, <span class="number">1990</span>, <span class="number">2006</span>, <span class="number">2010</span>, <span class="number">2014</span> ];</span><br><span class="line"><span class="keyword">const</span> array = [ <span class="keyword">for</span> ( year <span class="keyword">of</span> years ) <span class="keyword">if</span> ( year &gt; <span class="number">1990</span> ) <span class="keyword">if</span> ( year &lt; <span class="number">2014</span> ) year ];</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"><span class="comment">// =&gt; [ 2006, 2010 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2><p>先看一个示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"> x, y = 2, ...z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`x = <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`y = <span class="subst">$&#123;y&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`z = <span class="subst">$&#123;z&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// =&gt; x = 1</span></span><br><span class="line"><span class="comment">// =&gt; y = 2</span></span><br><span class="line"><span class="comment">// =&gt; z = 2,3,5,8,13</span></span><br><span class="line"></span><br><span class="line">consoel.log(f.length);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>这个示例中聚合了很多 ES6 在函数方面的特性，第一处是 <code>y = 2</code>，这种形式定义了函数参数的默认值，所以这里的 y 相当于一个默认值参数；第二处是 <code>...z</code>，这里的 z 被称为 rest 参数，用于存放函数中多余的参数，该参数往往可以用来替代 arguments 对象，因为它天生就是数组类型；第三处是传参时的 undefined，如果我们想跳过某个参数，需要显示的将该参数赋值为 undefined，使用 null 的话没有效果；第四处就是 func.length，这里的 length 表示普通参数的数量，如果我们测试 arugments.length，会发现结果为 7，因为这里的 arguments.length 表示的是传入参数的数量；最后一处不是很明显，但是很重要，就是普通参数、默认值参数和 rest 参数的位置顺序。</p>
<p>进一步还可以配合对象解构来传参：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://meituan.com'</span>, &#123;&#125;);</span><br><span class="line"><span class="comment">// =&gt; 'GET'</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://meituan.com'</span>);</span><br><span class="line"><span class="comment">// =&gt; Cannot read property 'body' of undefined</span></span><br></pre></td></tr></table></figure>
<p>第二个 fetch 的问题在于不能省略第二个参数，如果要省略参数，可以设置双重默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125; </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://meituan.com'</span>);</span><br><span class="line"><span class="comment">// =&gt; 'GET'</span></span><br></pre></td></tr></table></figure>
<p>rest 参数 <code>...rest</code> 用于将参数打包成数组，通过扩展运算符 <code>...</code>，可以执行逆运算，将数组（babel 也支持对类数对象的转换）转换为以分号分隔的参数序列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">0</span>, ...rest, <span class="number">21</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// =&gt; [0,1,1,2,3,5,8,13,21]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际运用</span></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<p>接下来是比较亮眼的箭头函数<code>=&gt;</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">k, v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; k: v &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> f = (k, v) =&gt; ( &#123; k: v &#125; );</span><br></pre></td></tr></table></figure>
<p>看到箭头函数的第一感官就是：简洁。另一个重要的点在于，箭头函数绑定了 this 对象，其特点如下：</p>
<ol>
<li>this 对象的指向是可变，但在箭头函数中，它固定的志向定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以用于构造函数</li>
<li>不可以使用 arguments 对象，可以使用 rest 参数代替</li>
<li>不能用作 Generator 函数，所以不能使用 yield 命令</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout( () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"id:"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call( &#123; id: <span class="number">42</span> &#125; );</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>
<p>之所以 this 的指向是固定的，根据 babel 的实现来说，是因为箭头函数内并没有 this 对象，无论箭头函数嵌套多少层，它都是指向定时所在的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"id:"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo.call( &#123; id: <span class="number">42</span> &#125; )()()();</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel 编译结果</span></span><br><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"id:"</span>, _this.id);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo.call(&#123; id: <span class="number">42</span> &#125;)()()();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES7 提出了函数绑定的概念，使用双冒号 <code>::</code> 来替代 call/apply/bind 的调用，目前 babel 已经支持该特性，双冒号左侧是一个对象，右侧是一个函数，实现以左边对象为上下文对象的右边函数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; id: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj::f();</span><br><span class="line"><span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>最后，讲讲尾函数调用的优化问题。在函数式编程中，如果某个函数的最后一步是函数调用过程，那么这一过程就成为尾调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数并不是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面示例相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    g(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数调用过程是不断入栈出栈的过程，由于尾调用是最后一步操作，所以不需要保存外层函数的调用，这被称为尾调用优化，即只保留内层函数的调用帧，这种优化的好处是如果函数都是尾调用，那么就可以优化到每次尾调用都只保留一层调用，大大节省内存，这就是尾调用优化的意义。</p>
<p>函数调用自身的过程，成为递归，如果尾调用自身，则称为尾递归。下面是一个阶乘函数，没有使用尾递归，最多需要保存 n 个调用记录，复杂度为 O(n)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n === <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorial( n - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// =&gt; 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用尾递归改写，只保留一个调用记录，复杂度 O(1)</span></span><br><span class="line"><span class="comment">// Babel 检测到尾调用时使用 while 循环执行函数体</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// =&gt; 120</span></span><br></pre></td></tr></table></figure>
<p>鉴于尾调用优化的在性能上的良好表现，EMCAScript 明确规定，所有 ECMAScript 的实现都应该实现“尾调用优化”。</p>
<blockquote>
<p>为了确保最后一步调用自身实现尾递归优化，就需要把函数内部用到的变量转换为函数的参数，比如上面的 total，不过这样的处理方式并不容易理解，优化方式有两种，一种是函数柯里化，另一种方式就是使用默认值参数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// =&gt; 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = 1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="对象">对象</h2><p>ES6 在编码的简洁性上做了很多工作，比如上面的箭头函数，比如下面的对象声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; foo &#125;;</span><br><span class="line"><span class="comment">// 相当于 obj = &#123; foo: foo &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    getSth ( x, y ) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;;</span><br><span class="line">        <span class="comment">// 相当于 return &#123; x: x, y: y &#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相当于 getSth: function ( x, y ) &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES2015 新增了一个 Object.is() 方法来比较两个值是否相等，主要解决两方面的问题：一是 <code>==</code> 比较时的数据类型自动转换，一是 <code>===</code> 比较时 NaN 不等于自身、<code>+0</code> 等于 <code>-0</code> 的问题。Object.is() 实现的原则是：只要两个值一样，就应该相等（Same-value equality）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span></span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>);</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>;</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>Object.assign(target, source1, source2)</code> 用于将 source1/source2… 的属性拷贝到 target 中，遇到同名属性自动覆盖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> o1 = &#123; </span><br><span class="line">    id: <span class="number">123</span>, </span><br><span class="line">    meta: &#123; </span><br><span class="line">        age: <span class="number">1</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123; </span><br><span class="line">    meta: &#123;</span><br><span class="line">        age: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, o1, o2);</span><br><span class="line">target</span><br><span class="line"><span class="comment">// =&gt; &#123;"id":123,"meta":&#123;"age":2&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，一共有六种方法可以遍历对象的属性：</p>
<ol>
<li><code>for...in</code>，循环遍历对象自身的和集成的可枚举属性（不包含 Symbol 属性）</li>
<li><code>object.keys(obj)</code>，返回一个数组，包括自身所有可枚举属性（不含 Symbol 属性和继承属性）</li>
<li><code>Object.getOwnPropertyNames(obj)</code>，返回一个数组，包含对象自身的所有属性（不含Symbol属性，包括不可枚举属性）</li>
<li><code>Object.getOwnPropertySymbols(obj)</code>，返回一个数组，包含对象自身的所有Symbol属性</li>
<li><code>Reflect.ownKeys(obj)</code>，返回一个数组，包含对象自身的所有属性，包括 Symbol 和不可枚举属性</li>
<li><code>Reflect.enumerate(obj)</code> 返回一个 Iterator 对象，结果与 <code>for...in</code> 相同</li>
</ol>
<p>以上六种遍历方法，都遵守同样的遍历次序：</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, b:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, a:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br></pre></td></tr></table></figure>
<p><code>__proto__</code> 是一个没有正式规范，被浏览器广泛支持的属性，ES6 提供了新的方法来代替对该属性的操作：<code>Object.setPrototypeOf()</code> / <code>Object.getPrototypeOf()</code> / <code>Object.create()</code>。</p>
<h2 id="Symbol">Symbol</h2><p>Symbol 是 ES2015 加入的第七种数据类型，它与 undefined/null/boolean/string/number 都是原始数据类型，Symbol 用来实现一种独一无二的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s;</span><br><span class="line"><span class="comment">// =&gt; 'symbol'</span></span><br><span class="line"></span><br><span class="line">s1.toString();</span><br><span class="line"><span class="comment">// =&gt; 'Symbol(foo)'</span></span><br><span class="line"></span><br><span class="line">s2 === s1;</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
<p>Symbol 独一无二的特性非常适合作为对象的属性名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    [s]: <span class="string">'Hi'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.s</span><br><span class="line"><span class="comment">// =&gt; 'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>[s]</span><br><span class="line"><span class="comment">// =&gt; 'hi'</span></span><br></pre></td></tr></table></figure>
<p>在对使用 Symbol 作为属性名的对象进行遍历时，Symbol 属性不会出现在 for…in、for…of 循环中，也不会出现在 Object.keys()、Object.getOwnPropertyNames() 的返回值中。虽然如此，Symbol 并不是私有属性，可以通过 Object.getOwnPropertySymbols() 来获取指定对象的所有 Symbol 属性名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'baz'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="number">123</span>,</span><br><span class="line">    [s2]: <span class="string">'abc'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ss = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="comment">// [ Symbol(foo), Symbol(baz) ]</span></span><br></pre></td></tr></table></figure>
<p>要获取相同的 Symbol，可以调用系统的 Symbol.for()，该方法接受一个字符串作为参数，它会检测是否存在以该字符串参数名称的 Symbol 值，找到就返回，没有就创建：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2;</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>上面示例中用作参数的字符串又被成为 Symbol 的 key，使用 Symbol.keyFor() 可以查看这个 key:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s);</span><br><span class="line"><span class="comment">// =&gt; 'foo'</span></span><br></pre></td></tr></table></figure>
<h2 id="Proxy_and_Reflect">Proxy and Reflect</h2><p>Proxy，顾名思义，用于代替特定对象与外界进行交互的对象，简称代理对象:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.xxx</span><br><span class="line"><span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// =&gt; 'getting xxx'</span></span><br></pre></td></tr></table></figure>
<p>Proxy 的拦截操作概览：</p>
<ul>
<li>get()，拦截属性的读取</li>
<li>set()，拦截属性的设置</li>
<li>has()，拦截 propKey in proxy 操作</li>
<li>deleteProperty()，拦截 delete proxy[propKey] 操作</li>
<li>enumerate()，拦截 for ( let x in proxy ) 操作</li>
<li>ownKeys()</li>
<li>getOwnPropertyDescriptor()</li>
<li>defineProperty()</li>
<li>preventExtensions()</li>
<li>getPrototypeOf()</li>
<li>isExtensible()</li>
<li>setPrototypeOf()</li>
<li>apply()</li>
<li>construct()</li>
</ul>
<p>使用 Proxy.revocable() 可以创建一个可撤销拦截的代理对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line"><span class="built_in">console</span>.log(proxy);</span><br><span class="line"><span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>
<p>Reflect 对象的设计初衷：</p>
<ol>
<li>将 object 对象上明显属于语言内部的方法（Object.defineProperty）放到 Reflect 对象上</li>
<li>修改某些 Object 对象的返回结果，使其更可控，比如 Object.defineProperty() 在无法定义属性时会抛出错误，而 Reflect.defineProperty() 则会返回 false</li>
<li>让 Object 操作统一为函数行为，比如 name in obj 和 delete obj[name]，使用 Reflect.has() 和 Reflect.deleteProperty() 来执行</li>
<li>Reflect 对象的方法和 Proxy 对象的方法一一对应，两者高度统一，方便 Proxy 对象调用对应的 Reflect 方法 —— 不管 Proxy 怎么拦截和修改，总可以在 Reflect 上获取默认行为</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object 操作对比 Reflect 操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, prop, attr);</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, prop, attr)) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Set_and_Map">Set and Map</h2><p>ES2015 提供的 Set 数据结构是数组的一个约束，两者的差别就在于 Set 中没有重复值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set 的参数必须实现了 iterator 接口</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"><span class="comment">// =&gt; [ 1, 2, "2" ]</span></span><br></pre></td></tr></table></figure>
<p>Set 实例绑定的方法可以分为两类：数据操作方法和成员遍历方法：</p>
<p><img src="/img/es2015-set-methods.png" alt="set methods"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line">set.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">set</span><br><span class="line"><span class="comment">// =&gt; [1, 2]</span></span><br><span class="line"></span><br><span class="line">set.has(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">set.delete(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">set.clear();</span><br><span class="line"></span><br><span class="line">set</span><br><span class="line"><span class="comment">// =&gt; []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>在遍历时，由于 Set 结构没有键名，只有键值，所以 keys() 和 values() 的返回值一致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">of</span> set.keys() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; red</span></span><br><span class="line"><span class="comment">// =&gt; green</span></span><br><span class="line"><span class="comment">// =&gt; blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> value <span class="keyword">of</span> set.values() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; red</span></span><br><span class="line"><span class="comment">// =&gt; green</span></span><br><span class="line"><span class="comment">// =&gt; blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> [key, value] <span class="keyword">of</span> set.entries() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, value]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; ["red","red"]</span></span><br><span class="line"><span class="comment">// =&gt; ["green","green"]</span></span><br><span class="line"><span class="comment">// =&gt; ["blue","blue"]</span></span><br></pre></td></tr></table></figure>
<p>下面是一个 Set 结构的实例，用来求取两个 Set 结构的并交差集：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">const</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...x, ...y]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">const</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>([...x].filter( x =&gt; y.has(x) ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">const</span> diffset = <span class="keyword">new</span> <span class="built_in">Set</span>([...x].filter( x =&gt; !y.has(x) ));</span><br></pre></td></tr></table></figure>
<p>WeakSet 结构和 Set 结构相似，也是不重复值的集合，差异在于两个地方：一是 WeakSet 内部的元素只能是对象，二是 WeakSet 内部的对象是弱引用，垃圾回收机制不考虑 WeakSet 中对象的引用计数。</p>
<p>由于 WeakSet 结构的对象是弱引用，随时可能消失，所以没有 size 属性，也无法进行遍历，只具有 Set 结构中的三个操作方法：add() / delete() / has()。</p>
<p>Map 结构是对现有 Object 对象的扩展，Object 中的 key 只能是字符串和 Symbol（ES2015 新增），Map 中的 key 可以是任意数据类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123; id: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line">map.set(obj, <span class="string">'hi'</span>);</span><br><span class="line">map.get(obj);</span><br><span class="line"><span class="comment">// =&gt; 'hi'</span></span><br><span class="line"></span><br><span class="line">map.has(obj);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">map.delete(obj);</span><br><span class="line">map.has(obj);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key 绑定内存地址</span></span><br><span class="line">map.set(&#123;&#125;, <span class="string">'object'</span>);</span><br><span class="line">map.get(&#123;&#125;);</span><br><span class="line"><span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>
<p>下面在 Map 初始化的时候传入一个二维数组创建 Map：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">'three'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">of</span> map.keys() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> value <span class="keyword">of</span> map.values() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; one</span></span><br><span class="line"><span class="comment">// =&gt; two</span></span><br><span class="line"><span class="comment">// =&gt; three</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, value]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; [1,"one"]</span></span><br><span class="line"><span class="comment">// =&gt; [2,"two"]</span></span><br><span class="line"><span class="comment">// =&gt; [3,"three"]</span></span><br></pre></td></tr></table></figure>
<p>WeakMap 是弱引用的 Map 结构，而且 WeakMap 只能以对象作为键值，不接受其他类型的值作为键名。</p>
<h2 id="Iterator">Iterator</h2><p>现在，JS 中表示集合的数据结构包括 String、Array、Object、Map、Set、WeakMap、WeakSet 七种数据结构。Iterator 提供了一种接口，为各种不同的数据结构提供统一的接口，任何数据结构只要部署了 Iterator 结构，就可以完成遍历操作，目前，String、Array、Map 和 Set 是默认部署了该接口的数据结构，Array-like object 可以通过 Array.from() 转换为 Array 使用该接口。</p>
<p>Iterator 的作用主要有三点：</p>
<ul>
<li>为数据结构提供统一的访问接口</li>
<li>使得数据接口的成员可以按照某种次序排列</li>
<li>供 for…of 使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> it = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 3, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>凡是数据结构原生部署了 Symbol.iterator 属性，则具备 Iterator 接口，调用该接口，就可以得到一个遍历器对象。遍历器对象调用 next() 方法一次可以得到数据结构的所有成员，next() 返回一个对象，包括 value 和 done 属性。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性上，部署该属性的数据结构都被认为是可遍历的。在某些场合会自动调用遍历器接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line">[x, y] = [x, y]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// =&gt; [ "h", "e", "l", "l", "o" ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line"><span class="keyword">for</span> ... <span class="keyword">of</span></span><br><span class="line"><span class="built_in">Array</span>.from()</span><br><span class="line"><span class="built_in">Map</span>() / <span class="built_in">Set</span>() / <span class="built_in">WeakMap</span>() / <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="built_in">Promise</span>.all()</span><br><span class="line">Promis.race()</span><br><span class="line"></span><br><span class="line"><span class="comment">// yield*</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 3, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>遍历语法的发展：</p>
<ul>
<li>for 遍历，语法繁琐</li>
<li>forEach()，不能使用 break、continue、return 退出循环</li>
<li>for…in，为对象设计，遍历数组时会自动将索引转换为字符串</li>
<li>for…of，修复上述问题，可以遍历实现 iterator 接口的数据接口，不支持对普通对象的遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">in</span> arr ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, arr[key]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; [ "0", "a" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ "1", "b" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ "2", "c" ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> [key, value] <span class="keyword">of</span> arr.entries() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, value]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// =&gt; [ 0, "a" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ 1, "b" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ 2, "c" ]</span></span><br></pre></td></tr></table></figure>
<h2 id="Generator">Generator</h2><p>Generator 函数是 ES2015 提供的一种异步编程解决方案。可以将 Generator 视为一个有限状态机，内部封装了多个状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 3, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>Generator 函数返回的遍历器对象需要调用 next 函数才会遍历到下一个内部状态，并且通过函数内部的 yield 命名挂起函数。遍历器对象 next 方法的运行逻辑：</p>
<ol>
<li>执行 next 函数，遇到 yield 命令挂起函数的执行，并且返回 yield 命令后表达式的值，作为返回的遍历器对象的 value 属性</li>
<li>继续执行 next 函数，直到遇到下一个 yield，然后挂起函数</li>
<li>如果没有再遇到 return，就运行到函数结束。函数结束时如果有 return，返回 return 后面表达式的值作为返回对象的 value 属性</li>
<li>如果没有 return 表达式，则返回对象的 value 属性为 undefined</li>
</ol>
<p><img src="/img/es2015-generator-yield.png" alt="es2015-generator-yield"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: true, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>Generator 函数返回的对象都部署了 Iterator 接口 [Symbol.iterator]，所以，我们可以使用 for…of 循环来遍历 Generator 函数，当返回对象的 done 属性为 true 时，循环自动中止：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> v <span class="keyword">of</span> gen() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>Generator 返回的对象附带两个方法：throw() 和 return，用于手动抛出异常和结束 Generator 函数。</p>
<p>如果要在 Generator 函数内调用另外一个 Generator 函数，需要使用 <code>yield*</code>，实际上如果 yield 后面跟的是一个遍历器对象，都可以使用 <code>yield*</code> 来解析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 等同于 </span></span><br><span class="line">    <span class="comment">// yield 2;</span></span><br><span class="line">    <span class="comment">// yield 3;</span></span><br><span class="line">    <span class="comment">// yield 4;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果对象的某个属性是 Generator 函数，形式上有所不同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    * gen () &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = obj.gen();</span><br><span class="line"></span><br><span class="line">g.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>前面有数组推导，Generator 函数也有推导，Generator 函数推导的优势在于它是惰性求值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bigArr</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ret = ( <span class="keyword">for</span> ( n <span class="keyword">of</span> bigArr() ) <span class="keyword">if</span> ( n &lt; <span class="number">10</span> ) n * n );</span><br><span class="line"></span><br><span class="line">[...ret]</span><br><span class="line"><span class="comment">// =&gt; [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]</span></span><br></pre></td></tr></table></figure>
<p>下面是使用 Generator 函数实现的一个状态机：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">        <span class="keyword">yield</span> _;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'on'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> _;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'off'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// on</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// off</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// on</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>JS 解析引擎是单线程，只能保持一个调用栈，为了保持多个任务独立的调用栈，引入了协程。Generator 函数是 ES2015 对协程的实现，但不是完整的实现，完整的协程应该可以通过任何函数实现暂停，但是只有 Generator 函数的调用者才能结束 Generator 函数。</p>
<p>如果将 Generator 函数当做协程，可以将多个需要写作的任务都写成 Generator 函数，使用 yield 命令交换控制权。</p>
<h2 id="Promise">Promise</h2><p>在 ES2015 之前，Promise 早有实现，ES2015 规范统一了 Promise 的用法。Promise 对象共有三个状态：Pending、Resolved 和 Rejected。Promise 对象的状态只能从 Pending 变为 Resolved 或者从 Pending 变为 Rejected。</p>
<p>Promise 对象存在的价值是将异步操作以同步操作的流程表达出来，避免层层嵌套的回调函数，并且提供了统一的接口，便于控制异步操作。不过，Promise 也存在一些缺点：</p>
<ul>
<li>创建后立即执行，无法中途取消</li>
<li>如果不设置回调函数，无法抛出内部错误</li>
<li>处于 Pending 状态时，无法获得具体状态（刚刚开始还是即将完成）</li>
</ul>
<p>ES2015 规定，Promise 对象是一个构造函数，用于生成 Promise 实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( (resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>, <span class="string">'done'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then((value) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1000ms 后</span></span><br><span class="line"><span class="comment">// =&gt; 'done'</span></span><br></pre></td></tr></table></figure>
<p>Promise 实例具有两个方法：then(resolved，rejected) 和 catch()。catch() 相当于是 <code>.them(null, rejected)</code> 的缩写，用于指定发生错误时的回调函数。</p>
<p>Promise 对象本身还有四个方法：all()、race()、resolve()、reject()。Promise.all() 方法接收包含多个 Promise 实例的一个数组，打包封装成一个 Promise 实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line"><span class="comment">// p 的状态取决于 p1、p2、p3</span></span><br><span class="line"><span class="comment">// p1、p2、p3 全部 resolved 时，p resolved</span></span><br><span class="line"><span class="comment">// p1、p2、p3 有一个 rejected，p rejected</span></span><br></pre></td></tr></table></figure>
<p>Promise.race() 同样打包多个返回一个 Promise 实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line"><span class="comment">// 与 Promise.all() 的不同之处在于，</span></span><br><span class="line"><span class="comment">// p 的状态取决于 p1、p2、p3 中状态最先发生变化的那个</span></span><br></pre></td></tr></table></figure>
<p>Promise.resolve() 方法用于将现有对象转换为 Promise 对象；Promise.reject() 方法返回一个 Promise 实例，该实例的默认状态就是 rejected。</p>
<p>ES2015 的 Promise API 并不是很多，可以根据自己的开发需要部署特定的方法，比如我们可以部署两个比较常用的方法：done() 和 finally()。Promise 实例以 then() 或 catch() 方法作为结尾方法时，如果结尾方法抛出错误，是有可能无法捕捉到的，所以可以实现一个 done 方法置于回调链的结尾，保证抛出的任何方法都能被捕获：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">            setTimeout(() =&gt; &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>finally() 方法用于指定回调链的最终操作，与 done 方法的区别在于，它接受一个普通的回调函数作为参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器使用 Promise 处理请求，使用 finally 关掉服务器</span></span><br><span class="line">server.listen(<span class="number">0</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    .finally(server.stop);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">        value  =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">        reason =&gt; P.resolve(callback()).then(() =&gt; &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Async">Async</h2><p>我们有回调函数、Promise 以及 Generator 这三种异步编程方式了，为什么在此之外还要提供 Async 函数？因为它们本身还有一些问题：</p>
<ul>
<li>回调函数的最大问题是回调嵌套</li>
<li>Promise 解决了回调嵌套的问题，但是被 then 方法包装后的代码存在冗余问题，语义和理解性较差</li>
<li>Generator 的代码写起来非常像同步代码，如果去除 yield 命令，简直就是同步代码，但是它失去了 Promise 可以自动执行的特性，所以它的缺点就是需要创建一个自动执行函数（Thunk 函数），或者使用三方模块（co），总之要驱动它自执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Callback Hell</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> finalCallback </span>) </span>&#123;</span><br><span class="line">    request.get(url1, <span class="function"><span class="keyword">function</span>(<span class="params">err1, res1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err1) <span class="keyword">return</span> finalCallback(err1);</span><br><span class="line">        </span><br><span class="line">        request.post(url2, <span class="function"><span class="keyword">function</span>(<span class="params">err2, res2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err2) <span class="keyword">return</span> finalCallback(err2);</span><br><span class="line">            </span><br><span class="line">            request.put(url3, <span class="function"><span class="keyword">function</span>(<span class="params">err3, res3</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err3) <span class="keyword">return</span> finalCallback(err3);</span><br><span class="line">                </span><br><span class="line">                request.del(url4, <span class="function"><span class="keyword">function</span>(<span class="params">err4, res4</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err4) <span class="keyword">return</span> finalCallback(err4);</span><br><span class="line">                    </span><br><span class="line">                    finalCallback(<span class="literal">null</span>, <span class="string">"whew all done"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request.getAsync(url1)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">res1</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> request.postAsync(url2);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">res2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> request.putAsync(url3);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">res3</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> request.delAsync(url4);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">res4</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"whew all done"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator</span></span><br><span class="line"><span class="keyword">import</span> co <span class="keyword">from</span> <span class="string">'co'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">yield</span> request.getAsync(url1);</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">yield</span> request.getAsync(url2);</span><br><span class="line">    <span class="keyword">const</span> res3 = <span class="keyword">yield</span> request.getAsync(url3);</span><br><span class="line">    <span class="keyword">const</span> res4 = <span class="keyword">yield</span> request.getAsync(url4);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"whew all done"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(gen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> request.getAsync(url1);</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> request.getAsync(url2);</span><br><span class="line">    <span class="keyword">const</span> res3 = <span class="keyword">await</span> request.getAsync(url3);</span><br><span class="line">    <span class="keyword">const</span> res4 = <span class="keyword">await</span> request.getAsync(url4);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"whew all done"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器的惰性求值往往是将参数放入临时函数中实现的，在求值时调用这个临时函数，这个临时函数叫做 Thunk 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">temp</span> (<span class="params"> v </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp( x + <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">temp</span> (<span class="params"> v </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thunk() + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JS 中，Thunk 函数要做的是将多参数函数转换为单参数函数，且只接受回调函数作为参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>任何函数，只要参数是回调函数，就能写成 Thunk 函数的形式，下面是一个简单的 Thunk 函数转换器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">            args.push(callback);</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之所以要提 Thunk 函数，是因为它可以驱动 Generator 函数自执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = fn();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>ES7 提供了 Async 函数，它相当于是 Generator 函数的语法糖。下面使用两种函数读取文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">cosnt readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator 函数</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async</span></span><br><span class="line">cosnt asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    cosnt f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    cosnt f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先，两者在语法上有所不同，但这不是最重要的，重要的是一下三点：</p>
<ol>
<li>Async 函数内置自动执行器，而 Generator 需要自己写自动执行函数或者使用第三方库，比如 co</li>
<li>更广的适应性，co 模块约定 yield 后面只能是 Thunk 函数或者是 Promise 对象，而 Async 函数的 await 后面可以使用 Promise 对象或原始值类型（此时等于同步操作）</li>
<li>Async 的返回值是 Promise 对象，这比 Generator 返回的 Iterator 对象要更方便一些，可以使用 then() 来制定下一步的操作逻辑</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve) =&gt; &#123;</span><br><span class="line">        setTimeout(resolve, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>await 命令后面跟着一个 Promise 对象，运行结果可能是 rejected，需要使用 try…catch 来捕获异常：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> P();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> P().catch( err =&gt; <span class="built_in">console</span>.log(err) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Class">Class</h2><p>JS 传统的原型继承等方式和其他语言差异较大，造成了一定的学习难度。ES2015 提供了和其他语言相仿的面向对象语法，引入了 Class 的概念，用作对象的模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor( x, y ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInfo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`( <span class="subst">$&#123;this.x&#125;</span>, <span class="subst">$&#123;this.y&#125;</span> )`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">p.getInfo();</span><br><span class="line"><span class="comment">// =&gt; ( 3, 4 )</span></span><br></pre></td></tr></table></figure>
<p>上例中的 constructor 是构造方法，this 代表实例对象。constructor 方法是类的默认方法，使用 new 命令生成对象实例时，自动调用盖房，如果没有显示定义该方法，就会自动添加一个空的 constructor 方法，constructor 方法默认返回类的实例对象，该返回值完全是可以修改的。</p>
<p>Class 之间使用 extends 关键字实现继承，这种写法比 ES5 要简洁很多：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor( x, y ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInfo () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`( <span class="subst">$&#123;this.x&#125;</span>, <span class="subst">$&#123;this.y&#125;</span> )`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor ( x, y, color ) &#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInfo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="keyword">super</span>.getInfo() + <span class="string">` is <span class="subst">$&#123;this.color&#125;</span>`</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cp = <span class="keyword">new</span> ColorPoint( <span class="number">3</span>, <span class="number">4</span>, <span class="string">'red'</span> );</span><br><span class="line">cp.getInfo();</span><br><span class="line"><span class="comment">// =&gt; ( 3, 4 ) is red</span></span><br></pre></td></tr></table></figure>
<p>在继承类的构造函数中出现了 super()，它指代父类的 this 对象。子类必须在 constructor 中调用 super 方法，否则新建实例会报错，这是因为子类没有自己的 this 对象，而是使用继承自父类的 this 对象，一切都是基于对这个 this 的加工处理，如果不调用 super()，就得不到 this 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cp = <span class="keyword">new</span> ColorPoint();</span><br><span class="line"><span class="comment">// =&gt; Babel: 'this' is not allowed before super()</span></span><br><span class="line"><span class="comment">// =&gt; Firefox: ReferenceError: |this| used uninitialized in ColorPoint class constructor</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES5 的原型继承，实质是先创造子类的实例对象 this，然后再讲父类的方法添加到 this 上。ES6 的继承机制则是相反的，实质是先创造父类的实例对象 this（调用 super() ），然后在用子类的构造函数修改 this。</p>
</blockquote>
<p>类相当于实例的原型，类中定义的方法都会被实例所继承，如果不想让实例继承继承某个方法，可以通过 static 关键字设置类的静态方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    static getInfo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">Foo.getInfo();</span><br><span class="line"><span class="comment">// =&gt; 'foo'</span></span><br><span class="line">f.getInfo();</span><br><span class="line"><span class="comment">// =&gt; TypeError: f.getInfo is not a function</span></span><br></pre></td></tr></table></figure>
<p>ES2015 规定类内部只有静态方法，没有静态属性，ES2016 有一个静态属性的提案，目前 Babel 已经支持：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    position = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    static color = <span class="string">'red'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new 是从类生成实例的命令，ES2015 的 new 命令增加了一个 <code>new.target</code> 的属性，表示 new 引用的构造函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">new</span>.target === Point ) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'right'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'wrong'</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line"><span class="comment">// =&gt; right</span></span><br><span class="line">Point.call(p, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// =&gt; Babel: wrong</span></span><br><span class="line"><span class="comment">// =&gt; Firefox: TypeError: class constructors must be invoked with |new|</span></span><br></pre></td></tr></table></figure>
<p>在子类继承父类时，new.target 返回的是子类，利用这个特点，可以写出不能独立使用、必须继承后才能使用的类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Shape();</span><br><span class="line"><span class="comment">// =&gt; Error: 本类不能实例化</span></span><br></pre></td></tr></table></figure>
<h2 id="Decorator">Decorator</h2><p>ES2016 的 Decorator 相当于设计模式中的装饰模式，所以下文就以装饰器来指代 Decorator。与上面提到的 Proxy（代理者，代理模式）不同，装饰器的核心作用是增强被装饰者的功能，而代理对象的作用是管理外界对被代理者的访问权限。装饰器只能用于类和类的方法，不能用于函数，因为编译时存在函数提升。修饰漆对类的行为的改变，是代码编译时发生的，而不是运行时，这意味着，修饰漆能在编译阶段运行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLS</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> CLS();</span><br><span class="line">obj.foo();</span><br><span class="line"><span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>
<p>装饰器函数可以接收三个参数：目标函数、属性名和属性的描述对象。上例代码通过装饰器 mixins，为指定类添加了指定的方法。装饰器的一个实际应用就是注释:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> <span class="keyword">extends</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    entree = <span class="string">'steak'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dinner = <span class="keyword">new</span> Meal();</span><br><span class="line">dinner.entree = <span class="string">'salmon'</span>;</span><br><span class="line"><span class="comment">// Cannot assign to read only property 'entree' of [object Object]</span></span><br></pre></td></tr></table></figure>
<p>除了注释功能，装饰器还能用作类型检查，长期来看，它将成为 JavaScript 代码静态分析的重要工具。</p>
<h2 id="Module">Module</h2><p>在 ES2015 之前，社区中主要有 CommonJS 和 AMD 两种模块加载方式，ES2015 提出了自己的模块功能，其设计思想是尽量的静态化，在编译时确定模块的依赖关系、输入输出变量。</p>
<p>ES2015 module 主要由两个命令组成：<code>export</code> 和 <code>import</code>。export 用于提供对外接口，import 用于引用外部模块。每个模块都是独立的文件，外部无法直接获取模块文件的变量，只能通过 export 对外输出变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出变量</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出函数和类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>export 定义了外部接口之后，可以使用 import 命令在其他模块中加载：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 as 命令重命名引入的变量</span></span><br><span class="line"><span class="comment">// import 语法存在变量提升，最好置于文件顶部</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar <span class="keyword">as</span> baz &#125; <span class="keyword">from</span> <span class="string">'./modulename'</span>;</span><br></pre></td></tr></table></figure>
<p>从上面 import 的示例中，我们发现当需要引入外部模块时，必须明确知道模块内部的变量名，这是非常不友好的方式。<code>export default</code> 命令就是为了解决这个问题存在的，其作用是为模块指定默认的输出内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 'export-default.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'import-default.js'</span></span><br><span class="line">immport customName from <span class="string">'./export-default.js'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="建议使用的特性">建议使用的特性</h2><h6 id="参考资料">参考资料</h6><ul>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript6 入门</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="external">MDN JavaScript</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>ES2015 是最新的 JavaScript 语法规范，也是前端工程化高速发展所催化出的产物。JS 的不成熟一直为人诟病，前端的高速发展又离不开 JS，所以这次激进的变革显得十分必要。</p>
<p>虽然 ES2015 规范发布了，但是要原生的运行在浏览器上还是受到诸多因素的肘制，比如各版本浏览器的用户量、浏览器厂商对新特性的支持度等等。目前的权宜之计是使用 Babel 之类的编译器将 ES2015 代码转换为 ES5，所以下文中的 ES2015 代码也暂时以 Babel 的解析结果为准。各版本浏览器对 ES2015（ES6）、ES2016（ES7）的支持度可以参考这里：<a href="http://kangax.github.io/compat-table/es6/">ES2015 兼容性列表</a>。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[求值策略]]></title>
    <link href="http://pinggod.com/2015/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/"/>
    <id>http://pinggod.com/2015/求值策略/</id>
    <published>2015-12-10T05:43:07.000Z</published>
    <updated>2015-12-15T09:15:01.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>须知参差多态乃是幸福本源。</p>
</blockquote>
<p>求值策略所要解决的问题是：何时求值。之所以要控制求值的时间，往往是出于对内存占用和执行效率的考虑。在维基百科的求值策略词条中，列出了五种求值策略：</p>
<ul>
<li>预先求值，表达式绑定到变量时，立即求值并附加给变量</li>
<li>延迟求值，表达式绑定到变量后，并不求值，直到变量被调用时才求值</li>
<li>局部求值，又称柯里化</li>
<li>分布求值，map/reduce，典型应用是分布式计算</li>
<li>短路求值，与 (&amp;&amp;) 、或 (||) 逻辑运算</li>
</ul>
<p>顾名思义，预先求值和延迟求值是一对对立的求值策略。在下面的 js 代码段中，声明了变量 x，x 赋值后又被调用了三次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> + <span class="number">3</span> * (<span class="number">1</span> + <span class="number">5</span> ^ <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">func(x);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在 1 处，变量 x 完成了声明和赋值等初始化工作，它的值由表达式 (5 + 3 * (1 + 5 ^ 2)) 决定。在 2 处，console.log() 函数调用了变量 x 两次。让我们暂时忽略 js 编译器的求值策略，从个人主观的理性思维来思考一下：面对预先求值和延迟求值，你会怎么选择呢？</p>
<p>做出选择之前，我们需要对变量 x 有一个复杂度的认知：如果表达式的复杂度高，那么该表达式所占用的内存空间也就越高，在变量 x 和表达式解绑前这段内存空间都无法释放掉，意味着 x 的间接内存占用了越高，此外，高复杂度也意味着较长的执行时间，所以复杂度和内存占用、执行效率至少是一种线性相关。</p>
<p>如此说来，那么我们应该选择预先求值的求值策略，这样的好处是：变量 x 初始化时表达式立即计算，x 被重新赋值为 83，重新赋值后表达式所占用的内存空间被释放掉，达到了节省内存空间的目的；多次调用变量 x 时，x 的值已经是可以直接用于运算的数值，而不是需要计算的表达式，减少了重复运算，提高了执行效率。</p>
<p>如果事情按照上面描述的美好愿景发展的话，就没有延迟求值策略出现的必要了。在 3 处，我们向函数 func() 传递了变量 x。这里的 func() 类似于一个黑盒，我们不了解其内部的处理机制，也无法确定 x 是否会被使用。这个时候延迟求值的价值就体现出来了，如果变量 x 在函数内部没有被使用，就不会执行求值，避免了预先求值所要执行的求值运算。</p>
<p>随着表达式的复杂度逐渐提高，预先求值和延迟求值在内存占用、执行效率上的差异就会愈发明显。所以根据数据类型的复杂度，js 将数据类型分为原始值和引用值，传递参数时，原始值按值传递，引用值按引用传递。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>须知参差多态乃是幸福本源。</p>
</blockquote>
<p>求值策略所要解决的问题是：何时求值。之所以要控制求值的时间，往往是出于对内存占用和执行效率的考虑。在维基百科的求值策略词条中，列出了五种求值策略：</p>
<ul>
<li>预先求值，表达式绑定到变量时，立即求值并附加给变量</li>
<li>延迟求值，表达式绑定到变量后，并不求值，直到变量被调用时才求值</li>
<li>局部求值，又称柯里化</li>
<li>分布求值，map/reduce，典型应用是分布式计算</li>
<li>短路求值，与 (&amp;&amp;) 、或 (||) 逻辑运算</li>
</ul>
<p>顾名思义，预先求值和延迟求值是一对对立的求值策略。在下面的 js 代码段中，声明了变量 x，x 赋值后又被调用了三次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> + <span class="number">3</span> * (<span class="number">1</span> + <span class="number">5</span> ^ <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">func(x);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Inline* and Absolute]]></title>
    <link href="http://pinggod.com/2015/inline-and-absolute/"/>
    <id>http://pinggod.com/2015/inline-and-absolute/</id>
    <published>2015-12-06T03:32:17.000Z</published>
    <updated>2015-12-27T09:31:08.000Z</updated>
    <content type="html"><![CDATA[<p>在一个容器中，所有元素都是 inline / inline-block 类型，此时可以使用 absolute + margin 的方式实现相对定位，而且相对定位的位置就是脱离文档流之前的位置。</p>
<p><img src="/img/inline-and-absolute.png" alt="absolute and margin"></p>
<a id="more"></a>
<h6 id="在线示例">在线示例</h6><ul>
<li><a href="http://codepen.io/pinggod/pen/WrNJmE" target="_blank" rel="external">absolute and marign</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在一个容器中，所有元素都是 inline / inline-block 类型，此时可以使用 absolute + margin 的方式实现相对定位，而且相对定位的位置就是脱离文档流之前的位置。</p>
<p><img src="/img/inline-and-absolute.png" alt="absolute and margin"></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pug]]></title>
    <link href="http://pinggod.com/2015/Pug/"/>
    <id>http://pinggod.com/2015/Pug/</id>
    <published>2015-12-03T05:24:27.000Z</published>
    <updated>2015-12-28T09:57:24.000Z</updated>
    <content type="html"><![CDATA[<div class="tip"><br>    由于商标版权问题，Jade 已经改名为了 Pug，详见 <a href="https://github.com/pugjs/jade/issues/2184" target="_blank" rel="external">issue</a>。<br></div>

<p>如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Pug 也会是你的菜。Pug 类似于 Python，都采用了对缩进敏感的语法形式，比如下面这段代码创建了一个无序列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ul(<span class="class"><span class="keyword">class</span></span>=<span class="string">"inline"</span>)</span><br><span class="line">    li  Item C</span><br><span class="line">    li  Item A</span><br><span class="line">    li  Item B</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="属性">属性</h2><p>Pug 的另一大特点就是和 JavaScript 的融合度很高，比如设置属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">- <span class="keyword">var</span> authenticated = <span class="literal">true</span></span><br><span class="line">body(<span class="class"><span class="keyword">class</span></span>= authenticated ? <span class="string">'authed'</span> : <span class="string">'anon'</span>)</span><br><span class="line">- <span class="keyword">var</span> currentUrl = <span class="string">'/about'</span></span><br><span class="line">a(<span class="class"><span class="keyword">class</span></span>=&#123;active: currentUrl === <span class="string">'/'</span>&#125; href=<span class="string">'/'</span>) Home</span><br><span class="line">a(<span class="class"><span class="keyword">class</span></span>=&#123;active: currentUrl === <span class="string">'/about'</span>&#125; href=<span class="string">'/about'</span>) About</span><br></pre></td></tr></table></figure>
<p>此外，给标签设置行内样式时，需要以对象的形式赋值给 style：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a(style=&#123;color: <span class="string">'red'</span>, background: <span class="string">'green'</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="插值">插值</h2><p>Pug 提供了字符串插值和标签插值。其中，字符串插值由于要考虑到安全性问题，所以又分成了转义和不转义两种情况：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 转义插值 #&#123;&#125;</span><br><span class="line">- var theGreat = "&lt;span&gt;escape!&lt;/span&gt;";</span><br><span class="line">p This will be safe: #&#123;theGreat&#125;</span><br><span class="line"></span><br><span class="line">// 不转义插值 !&#123;&#125;</span><br><span class="line">- var theGreat = "&lt;span&gt;escape!&lt;/span&gt;";</span><br><span class="line">p This will be safe: !&#123;theGreat&#125;</span><br><span class="line"></span><br><span class="line">// 标签插值</span><br><span class="line">p #[a(href="Pug-lang.com") Pug]</span><br></pre></td></tr></table></figure>
<p>编译结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 转义插值 #&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>This will be safe: &amp;lt;span&amp;gt;escape!&amp;lt;/span&amp;gt;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 不转义插值 !&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>This will be safe: <span class="tag">&lt;<span class="title">span</span>&gt;</span>escape!<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签插值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"Pug-lang.com"</span>&gt;</span>Pug<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑语句">逻辑语句</h2><p>Pug 提供了条件、分支、循环、遍历四种逻辑语句，这四种语句继承自 JavaScript，只是语法上有些差异:</p>
<ul>
<li>条件语句：if … else if … else</li>
<li>分支语句：case … when … default</li>
<li>循环语句：while</li>
<li>遍历数组：each $elem in [elem…]</li>
<li>遍历对象：each $key, $value in {key: value}</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 分支语句</span><br><span class="line">- var friends = 10</span><br><span class="line">case friends</span><br><span class="line">    when 0</span><br><span class="line">        p you have no friends</span><br><span class="line">    when 1</span><br><span class="line">        p you have a friend</span><br><span class="line">    default</span><br><span class="line">        p you have #&#123;friends&#125; friends</span><br></pre></td></tr></table></figure>
<h2 id="mixin">mixin</h2><p>Pug 和 Sass 都提供了 mixin 语法来实现代码的复用，两者语法也很相似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mixin list(id, ...items)</span><br><span class="line">    ul(id=id)</span><br><span class="line">        each item <span class="keyword">in</span> items</span><br><span class="line">            li= item</span><br><span class="line"></span><br><span class="line">+list(<span class="string">'my-list'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>mixin 一般放在独立的文件中，需要使用 <code>include</code> 指令导入到其他文件中。</p>
<h2 id="extends">extends</h2><p><code>extends</code> 是 Pug 的模板继承语法，通过 <code>extends filename.Pug</code> 可以将模板文件导入到其他文件中。继承机制基本上是一个复制代码片段的过程，为了能够动态修改其中的部分内容，Pug 提供了 <code>block</code> 语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明 block</span></span><br><span class="line">block content</span><br><span class="line">    p Hello</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 block</span></span><br><span class="line"><span class="comment">// 同名重新赋值</span></span><br><span class="line">block content</span><br><span class="line">    p Hi</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置追加</span></span><br><span class="line">block append content</span><br><span class="line">    p APPEND</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置追加</span></span><br><span class="line">block prepend content</span><br><span class="line">    p PREPEND</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<div class="tip"><br>    由于商标版权问题，Jade 已经改名为了 Pug，详见 <a href="https://github.com/pugjs/jade/issues/2184">issue</a>。<br></div>

<p>如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Pug 也会是你的菜。Pug 类似于 Python，都采用了对缩进敏感的语法形式，比如下面这段代码创建了一个无序列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ul(<span class="class"><span class="keyword">class</span></span>=<span class="string">"inline"</span>)</span><br><span class="line">    li  Item C</span><br><span class="line">    li  Item A</span><br><span class="line">    li  Item B</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Flexbox]]></title>
    <link href="http://pinggod.com/2015/CSS-Flexbox/"/>
    <id>http://pinggod.com/2015/CSS-Flexbox/</id>
    <published>2015-12-02T02:42:39.000Z</published>
    <updated>2015-12-27T09:32:02.000Z</updated>
    <content type="html"><![CDATA[<p>如果你正在学习使用 CSS 布局，推荐来 <a href="http://zh.learnlayout.com/toc.html" target="_blank" rel="external">learnlayout</a> 了解一下这些年前端所用到的各类布局手法。这里之所以使用“手法”一词，意指其中多少有些偏激取巧，比如使用浮动（float）来定位、使用 margin 来伸缩空间等等。</p>
<p>float、margin 本不应该用于布局，只是囿于早期的 CSS 布局模块发展缓慢且不合时宜，促使开发者另辟蹊径，借助其他样式来模拟布局效果。最近几年随着浏览器对布局模块的支持度越来越高，Flexible Box Layout（Flexbox）、Grid Layout、Multiple Column Layout 也逐渐为开发者所接受，其中以 Flexbox 的兼容性最好，拥护者也随之水涨船高。</p>
<p>就个人感受而言，未来的布局方式会归纳为两类：一类是纯粹使用浏览器兼容性高的布局模块，比如 Flexbox，这也是未来的发展趋势；另一类是使用预处理器或者框架自定义的布局模块，这只是目前的缓兵过渡之计。</p>
<a id="more"></a>
<p>在几个月前，我曾经使用过一段时间的 <a href="http://susy.oddbird.net/" target="_blank" rel="external">Susy</a>。 Susy 是基于 Sass 的一款布局框架，其核心是使用非布局样式来模拟布局效果，最大的优点在于封装布局样式之后提供了一套简洁明了的布局接口。比如，在下面的 Sass 代码中，<code>.contianer</code> 被附加了一套容器样式，嵌套在其中的 <code>item</code> 占据总体宽度的 4 / 10。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="class">.container</span> &#123;</span><br><span class="line">    <span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> container</span>;</span>  </span><br><span class="line">    <span class="class">.item</span> &#123;</span><br><span class="line">        <span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> span</span>(<span class="number">4</span><span class="preprocessor"> of</span><span class="preprocessor"> 10</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Susy 的理念是帮助开发者规避数学计算，所以它有一条大快人心的口号：YOUR MARKUP, YOUR DESIGN, YOUR OPINIONS, OUR MATH。</p>
</blockquote>
<h2 id="Flexbox">Flexbox</h2><p>在数学计算的问题上，我觉得 Flexbox 和 Susy 有异曲同工之妙，只是相比起来，原生的 Flexbox 更加简捷。在 Flexbox 中有两个核心元素：<code>container</code> 和 <code>item</code>，所有的样式也是围绕这两类元素计算的。下图中有两条红线，分别代表在水平方向和垂直方向进行布局的基线。</p>
<p><img src="/img/flexbox.png" alt="Flexbox"></p>
<p>Flexbox 中的 contianer 元素需要解决两个问题：自身的类型以及内部 item 的排列方式。通过 <code>display: flex</code> 和 <code>display: inline-flex</code> 可以将 container 声明为块级或者行内块级，从而确定了 container 自身的类型。使用以下属性则可以确定 container 内部 item 的排列方式：</p>
<ul>
<li>flex-flow：flex-direction 和 flex-wrap 的缩写</li>
<li>flex-direction：决定 item 的排列方向</li>
<li>flex-wrap：决定 item 的溢出容器后的处理方式</li>
<li>justify-content：决定 item 在水平方向上的对齐方式</li>
<li>align-item：决定 item 在垂直方向上的对齐方式</li>
<li>align-content：决定多个 main axis 在垂直方向上的对齐方式</li>
</ul>
<p><img src="/img/flexbox-container.png" alt="flex-container"></p>
<p>item 元素需要解决的问题集中于自身上，包括自身在 container 中的顺序、缩放、对齐方式。使用以下属性可以设置 item 自身的布局样式：</p>
<ul>
<li>order：决定 item 的顺序，默认值为 0，值越小越靠前</li>
<li>flex：flex-grow、flex-shrink 和 flex-basis 的缩写</li>
<li>flex-grow：决定 item 的放大比例，默认值为 0，0 表示不放大</li>
<li>flex-shrink：决定 item 的缩小比例，默认值为 1，0 表示不缩小</li>
<li>flex-basis：浏览器分配 container 剩余空间时，决定 item 获得的比重</li>
<li>align-self: 决定自身在垂直方向的对齐方式</li>
</ul>
<p><img src="/img/flexbox-cell.png" alt="flex-item"></p>
<h2 id="box-sizing">box-sizing</h2><p>话外提一下 <code>box-sizing</code>， 该属性用于声明 <code>width</code> 和 <code>height</code> 的约束范围：<code>border-box</code> 表示边框、内边距和内容块的宽高计入容器宽高；<code>content-box</code> 表示只有内容块的宽高计入容器宽高。此外，该属性可继承，可以通过设置 body 的 box-sizing 统一约束容器的宽高。</p>
<h2 id="FlexFroggy">FlexFroggy</h2><p>这是一个寓教于乐的 Flexbox 布局小游戏，难度中下，很有意思：<a href="http://flexboxfroggy.com" target="_blank" rel="external">http://flexboxfroggy.com</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果你正在学习使用 CSS 布局，推荐来 <a href="http://zh.learnlayout.com/toc.html">learnlayout</a> 了解一下这些年前端所用到的各类布局手法。这里之所以使用“手法”一词，意指其中多少有些偏激取巧，比如使用浮动（float）来定位、使用 margin 来伸缩空间等等。</p>
<p>float、margin 本不应该用于布局，只是囿于早期的 CSS 布局模块发展缓慢且不合时宜，促使开发者另辟蹊径，借助其他样式来模拟布局效果。最近几年随着浏览器对布局模块的支持度越来越高，Flexible Box Layout（Flexbox）、Grid Layout、Multiple Column Layout 也逐渐为开发者所接受，其中以 Flexbox 的兼容性最好，拥护者也随之水涨船高。</p>
<p>就个人感受而言，未来的布局方式会归纳为两类：一类是纯粹使用浏览器兼容性高的布局模块，比如 Flexbox，这也是未来的发展趋势；另一类是使用预处理器或者框架自定义的布局模块，这只是目前的缓兵过渡之计。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Void and Undefined]]></title>
    <link href="http://pinggod.com/2015/void-and-undefined/"/>
    <id>http://pinggod.com/2015/void-and-undefined/</id>
    <published>2015-11-30T12:18:37.000Z</published>
    <updated>2015-12-15T09:15:01.000Z</updated>
    <content type="html"><![CDATA[<p>一直以来，<code>undefined</code> 都不是 JavaScript 的关键字或保留字，这意味着我们可以修改 window.undefined 的值。由于 undefined 会被频繁调用作为比较运算的操作数，所以在 ES5 规范之后，window.undefined 被定义为不可写、不可配置的属性。常见的 undefined 列述如下:</p>
<ul>
<li>变量声明后未赋值，则变量会被自动赋值为 undefined</li>
<li>函数中定义了一些形参，如果传入的实参少于预定义的形参，那么有一些形参就会匹配不到实参，继而会被自动赋值为 undefined</li>
<li>没有返回值的函数，默认返回 undefined</li>
</ul>
<p><code>void (expression)</code>，void 作为一个运算符，无论表达式的内容是什么，只要跟在 void 之后都会被调用执行，执行完毕后 void 操作符返回 undefined。简而言之，使用 void 运算符有三种用处：生成 undefined；让函数立即执行；充当 <code>javascript:</code> 协议的 URI。</p>
<a id="more"></a>
<h2 id="生成_undefined">生成 undefined</h2><p>使用 <code>void 0</code> 生成 undefined 的做法由来已久，既减少了在原形链上查找 window.undefined 的时间，也避免了误用被修改过的 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkLogin</span> (<span class="params">loginName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loginName === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Wrong!'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkLogin();</span><br><span class="line"><span class="comment">// =&gt; 'Wrong!'</span></span><br></pre></td></tr></table></figure>
<h2 id="立即执行函数">立即执行函数</h2><p><strong>运算符和函数组合使用，可以让函数立即执行。</strong>实际上，有许多运算符可以让函数立即执行，比如 +、-、!、~ 以及本文提到的 void 等运算符。此外，还有最常见的小括号（分组运算符）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'立即执行'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// =&gt; '立即执行'</span></span><br></pre></td></tr></table></figure>
<h2 id="充当_javascript:_协议的_URI">充当 <code>javascript:</code> 协议的 URI</h2><p>对于网页中的点赞、收藏等按钮，如果使用 a 标签来实现的话，往往会用到 <code>href=&quot;javascript:void(0)&quot;</code> 等类似的代码，这段代码的作用是点击链接时让页面不跳转。</p>
<p>在 href=”javascript:void(0)” 中，使用了一个以 <code>javascript:</code> 协议开头的 URI，浏览器默认会对冒号后面的代码求值，然后将结果显示在新的页面，但有一种情况例外，如果结果是 undefined，浏览器就不会刷新页面渲染新值了。</p>
<p>实际上，我们有很多方式实现点赞、收藏的效果，无需使用这么 Hack 的方式——虽然这确实很方便。</p>
<blockquote>
<p><code>javascript:</code> 协议声明了 URL 的主体是任意的 javascript 代码，由 javascript 解释器编译执行，通常使用 <code>javascript:URL</code> 执行某些不改变当前页面文档的代码，要做到这一点，必须确保 URL 的最后一条语句没有返回值，比如使用 <code>void 0</code>。</p>
</blockquote>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="external">undefined</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void" target="_blank" rel="external">void 运算符</a></li>
<li><a href="http://segmentfault.com/a/1190000000474941" target="_blank" rel="external">谈谈Javascript中的void操作符</a></li>
<li><a href="http://www.jb51.net/article/52358.htm" target="_blank" rel="external">JavaScript中伪协议 javascript:使用探讨</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直以来，<code>undefined</code> 都不是 JavaScript 的关键字或保留字，这意味着我们可以修改 window.undefined 的值。由于 undefined 会被频繁调用作为比较运算的操作数，所以在 ES5 规范之后，window.undefined 被定义为不可写、不可配置的属性。常见的 undefined 列述如下:</p>
<ul>
<li>变量声明后未赋值，则变量会被自动赋值为 undefined</li>
<li>函数中定义了一些形参，如果传入的实参少于预定义的形参，那么有一些形参就会匹配不到实参，继而会被自动赋值为 undefined</li>
<li>没有返回值的函数，默认返回 undefined</li>
</ul>
<p><code>void (expression)</code>，void 作为一个运算符，无论表达式的内容是什么，只要跟在 void 之后都会被调用执行，执行完毕后 void 操作符返回 undefined。简而言之，使用 void 运算符有三种用处：生成 undefined；让函数立即执行；充当 <code>javascript:</code> 协议的 URI。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[React 组件间的消息传递]]></title>
    <link href="http://pinggod.com/2015/React-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"/>
    <id>http://pinggod.com/2015/React-组件间的消息传递/</id>
    <published>2015-11-28T10:34:42.000Z</published>
    <updated>2015-12-27T09:32:41.000Z</updated>
    <content type="html"><![CDATA[<p>当我们封装了可复用的组件之后，用来驱动组件渲染内容的数据就变得愈发灵活，组件之间数据通信的问题就摆在了桌面上。React 组件间的消息传递主要集中于三种关系中：</p>
<ul>
<li>从父组件向子组件的消息传递</li>
<li>从子组件向父组件的消息传递</li>
<li>无关联组件之间的消息传递</li>
</ul>
<p>前两种关系都可以使用 React 内建的 <code>this.props</code> 对象来处理：</p>
<p><img src="/img/react-component-comunication.png" alt="父子组件之间的消息传递"></p>
<a id="more"></a>
<h2 id="无关联组件之间的消息传递">无关联组件之间的消息传递</h2><p>这里的“无关联”，是指两个组件既不是父子关系，也不是兄弟关系。对于这种关系，可以用一个简单的发布订阅模型来实现，这种模型又被称为观察者模式。</p>
<p>这里选用的是基于全局对象的发布订阅模型，需要自定义事件名称：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件集合</span></span><br><span class="line"><span class="keyword">let</span> events = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line"><span class="keyword">const</span> trigger = (event, ...data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fns = events[event];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有对应方法</span></span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在对应方法，依次执行</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= fns.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        fns[i](...data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line"><span class="keyword">const</span> on = (event, fn) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果尚没有该事件，创建一个数组来存储对应的方法</span></span><br><span class="line">    <span class="keyword">if</span> (!events[event]) &#123;</span><br><span class="line">        events[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    events[event].push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消监听事件</span></span><br><span class="line"><span class="keyword">const</span> off = (event, fn) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fns = events[event];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不存在事件集合</span></span><br><span class="line">    <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在事件</span></span><br><span class="line">    <span class="keyword">if</span> (!fn &amp;&amp; fns) &#123;</span><br><span class="line">        fns.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消指定事件</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fn === fns[i]) &#123;</span><br><span class="line">                fns.splice(i, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PubSub = &#123;</span><br><span class="line">    on: on,</span><br><span class="line">    off: off,</span><br><span class="line">    trigger: trigger</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PubSub;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>当我们封装了可复用的组件之后，用来驱动组件渲染内容的数据就变得愈发灵活，组件之间数据通信的问题就摆在了桌面上。React 组件间的消息传递主要集中于三种关系中：</p>
<ul>
<li>从父组件向子组件的消息传递</li>
<li>从子组件向父组件的消息传递</li>
<li>无关联组件之间的消息传递</li>
</ul>
<p>前两种关系都可以使用 React 内建的 <code>this.props</code> 对象来处理：</p>
<p><img src="/img/react-component-comunication.png" alt="父子组件之间的消息传递"></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[React 组件的生命周期]]></title>
    <link href="http://pinggod.com/2015/React-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://pinggod.com/2015/React-组件的生命周期/</id>
    <published>2015-11-23T01:56:00.000Z</published>
    <updated>2015-12-27T09:30:30.000Z</updated>
    <content type="html"><![CDATA[<p>在 React 所实践的组件化中，非常重要的一点就是组件的生命周期，简而言之是组件的挂载、更新和卸载流程。下图详细列述了 React 组件在整个生命周期中所涉及的方法和行为：</p>
<p><img src="/img/react-lifecycle.png" alt="React 组件的生命周期"></p>
<a id="more"></a>
<p>在组件实例创建之初，会依序调用 <code>getDefaultProps()</code>、<code>getInitialState()</code> 方法初始化数据。在 ES6 中，可以简写为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">static defaultProps = &#123;</span><br><span class="line">    key: value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">state = &#123;</span><br><span class="line">    key: value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于从父组件传递来的 props，React 提供了 <code>propTypes</code> 配置对象来校验数据类型或格式，常用类型如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line">React.PropTypes.bool                              </span><br><span class="line"><span class="comment">// 数值</span></span><br><span class="line">React.PropTypes.number                            </span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">React.PropTypes.string                            </span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line">React.PropTypes.func                              </span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">React.PropTypes.array                             </span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">React.PropTypes.object                            </span><br><span class="line"><span class="comment">// 数值、字符串、DOM 元素及包含这些类型的数组</span></span><br><span class="line">React.PropTypes.node                              </span><br><span class="line"><span class="comment">// React 元素</span></span><br><span class="line">React.PropTypes.element                           </span><br><span class="line"><span class="comment">// 对象实例</span></span><br><span class="line">React.PropTypes.instanceOf(Message)               </span><br><span class="line"><span class="comment">// 数组包含的值之一</span></span><br><span class="line">React.PropTypes.oneOf([<span class="string">'News'</span> <span class="string">'Photos'</span>])          </span><br><span class="line"><span class="comment">// 数组包含的类型之一</span></span><br><span class="line">React.PropTypes.oneOfType([                       </span><br><span class="line">    React.PropTypes.string,         </span><br><span class="line">    React.PropTypes.number,         </span><br><span class="line">    React.PropTypes.instanceOf(Message)                                  </span><br><span class="line">])                                               </span><br><span class="line"><span class="comment">// 数值数组</span></span><br><span class="line">React.PropTypes.arrayOf(React.PropTypes.number)   </span><br><span class="line"><span class="comment">// 对象的属性值为数值类型</span></span><br><span class="line">React.PropTypes.objectOf(React.PropTypes.number)  </span><br><span class="line"><span class="comment">// 组合类型</span></span><br><span class="line">React.PropTypes.shape(&#123;                           </span><br><span class="line">    React.PropTypes.string                                   </span><br><span class="line">    React.PropTypes.number                                   </span><br><span class="line">&#125;)                                                 </span><br><span class="line"><span class="comment">// 任何类型，必填</span></span><br><span class="line">React.PropTypes.any.isRequired                    </span><br><span class="line"><span class="comment">// 自定义规则</span></span><br><span class="line">customProp: <span class="function"><span class="keyword">function</span>(<span class="params">props propName componentName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Validation failed!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mount">mount</h2><p>在组件的挂载过程中，会依次调用 componentWillMount()、render() 和 componentDidMount()。挂载完成后，<code>componentWillMount()</code> 和 <code>componentDidMount()</code> 将不会再被触发，<code>render()</code> 则会根据 props 和 state 的变化多次执行。</p>
<p>在 componentDidMount() 调用之前，只能得到由 render() 返回的虚拟 DOM；在该方法执行时，真实 DOM 的渲染已经完成，此时，可以通过 React 内建的 <code>getDOMNode()</code> 访问真实的 DOM。</p>
<h2 id="update">update</h2><p>挂载结束后，组件处于监听状态，监听 props 和 state 的变化。props 和 state 的差异在于：state 用于配置组件内的状态，props 则用于在组件间传递数据。</p>
<p>在实际开发中，这一阶段调用的核心都是围绕 state 展开的。state changed 之后，系统会立即调用 <code>boolean shouldComponentUpdate(object nextProps, object nextState)</code> 方法来决定是否重新渲染页面。当遭遇性能瓶颈时，适当地通过该方法控制页面渲染的频率是为提升性能不二法门。</p>
<p>当 props changed 时，系统会立即调用 <code>componentWillReciveProps(object nextProps)</code> 方法。该方法常被用来执行 props -&gt; state 的更新，继而触发整个页面的渲染。</p>
<p>在这一阶段重新渲染页面所需要的同样是 will -&gt; render -&gt; did 三个方法。不同之处在于，此处的 did 和 will 附加了 props 和 state 信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentWillUpdate(object nextProps, object nextState) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate(object prevProps, object prevState) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unmount">unmount</h2><p>组件卸载前会执行 <code>componentWillUnmount()</code>，用于清理 <code>componentDidMount()</code> 之后创建的组件。此外，对于组件生命周期内累积的监听事件和定时器，也应当在该方法内执行解绑、清除操作。</p>
<h2 id="组件化">组件化</h2><p>目前组内正在构建一套 React 基础组件，方法和思路与 AlloyTeam <a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/" target="_blank" rel="external">《致我们终将组件化的 Web》</a>一文类似。其中，作者对组件提出了五点要求，如下图所示，值得参考：</p>
<p><img src="/img/react-component.png" alt="组件化的要求"></p>
<p>其中“规范化的接口”，也可更改为可管理的生命周期。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 React 所实践的组件化中，非常重要的一点就是组件的生命周期，简而言之是组件的挂载、更新和卸载流程。下图详细列述了 React 组件在整个生命周期中所涉及的方法和行为：</p>
<p><img src="/img/react-lifecycle.png" alt="React 组件的生命周期"></p>]]>
    
    </summary>
    
  </entry>
  
</feed>
