<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ES2015 · PINGGOD · Focus On Program And Life</title><meta name="description" content="ES2015 是最新的 JavaScript 语法规范，也是前端工程化高速发展所催化出的产物。JS 的不成熟一直为人诟病，前端的高速发展又离不开 JS，所以这次激进的变革显得十分必要。
虽然 ES2015 规范发布了，但是要原生的运行在浏览器上还是受到诸多因素的肘制，比如各版本浏览器的用户量、浏览器厂商对新特性的支持度等等。目前的权宜之计是使用 Babel 之类的编译器将 ES2015 代码转换为 ES5，所以下文中的 ES2015 代码也暂时以 Babel 的解析结果为准。各版本浏览器对 ES2015（ES6）、ES2016（ES7）的支持度可以参考这里：ES2015 兼容性列表。

块级作用域和变量声明ES6 新增了以花括号 {} 为标志的块级作用域，用以增强代码的稳健性。在 ES6 之前，JS 中只有全局作用域和函数作用域（eval 作用域？我从来没用过），这种设计有多种弊端，比如最常见的循环变量泄露为全局变量：
&lt;figure class=&quot;highli"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">ES2015</h1><div class="post-meta"><div class="post-time">Dec 15, 2015</div></div><div class="post-content"><p>ES2015 是最新的 JavaScript 语法规范，也是前端工程化高速发展所催化出的产物。JS 的不成熟一直为人诟病，前端的高速发展又离不开 JS，所以这次激进的变革显得十分必要。</p>
<p>虽然 ES2015 规范发布了，但是要原生的运行在浏览器上还是受到诸多因素的肘制，比如各版本浏览器的用户量、浏览器厂商对新特性的支持度等等。目前的权宜之计是使用 Babel 之类的编译器将 ES2015 代码转换为 ES5，所以下文中的 ES2015 代码也暂时以 Babel 的解析结果为准。各版本浏览器对 ES2015（ES6）、ES2016（ES7）的支持度可以参考这里：<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">ES2015 兼容性列表</a>。</p>
<a id="more"></a>
<h2 id="块级作用域和变量声明">块级作用域和变量声明</h2><p>ES6 新增了以花括号 <code>{}</code> 为标志的块级作用域，用以增强代码的稳健性。在 ES6 之前，JS 中只有全局作用域和函数作用域（eval 作用域？我从来没用过），这种设计有多种弊端，比如最常见的循环变量泄露为全局变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]());</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>虽然循环结束了，但是 i 的值在全局作用域内仍然有效，进而形成了一系列的错误。对于这种错误，最常见的处理方式是使用立即执行函数（Immediately-Invoked Function Expression）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>这里用到的立即执行函数实际上是将<a href="http://pinggod.com/2015/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/">求值策略</a>从延迟求值转变为了预先求值，但仍然不够优雅和健壮。在 ES2015 中，通过使用 <code>let</code> 来声明循环变量同样可以解决这个问题，而且方式更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]());</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p><code>let</code> 和 <code>const</code> 是 ES2015 新增的变量声明指令：let 用来声明变量，const 用来声明常量。当使用 let 和 const 声明变量时，所声明的变量只在当前的块级作用域内有效，这一点是与 var 的本质差别，也是上述代码生效的基础。对于 var 时代的各种诡异特性，现在 let 和 const 做了一些修改：</p>
<ul>
<li>let 和 const 声明的变量不存在变量提升</li>
<li>let 和 const 声明的变量不允许在同一作用域内重复声明多次</li>
<li>let 和 const 声明的变量必须先声明后使用，否则抛出 ReferenceError</li>
</ul>
<p>从块级作用域的开始到 let 和 const 变量声明的区域被称为临时死区（temporal dead zone），意指此处调用未声明的 let 和 const 变量一定报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    temp = <span class="string">'abc'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// blablablabla</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该行代码之前都属于变量 temp 的 temporal dead zone</span></span><br><span class="line">    <span class="comment">// 意指在此之前不可使用变量 temp</span></span><br><span class="line">    <span class="keyword">let</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tip"><br>    在浏览器环境下，使用 var 声明的全局变量都会挂载在全局对象 window 下面。ES 2015 规定，使用 var 和 function 声明的全局变量仍然挂载在全局对象下面，但是 let、const 和 class 声明的全局变量则不属于全局对象。<br></div>


<h2 id="解构赋值">解构赋值</h2><p>解构赋值是 ES2015 提供的一种语法糖操作，常用于简化对数组和对象的数据提取。可以使用解构赋值的数据类型包括：</p>
<ul>
<li>对象</li>
<li>字符串</li>
<li>数值和布尔值（自动转换为对象，然后调用 toString() ）</li>
<li>数组，以及具有 Iterator 结构的数据结构，比如 Set 等</li>
</ul>
<p>下面我们通过一些实例来看一下解构赋值的使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 交换两个数的值</span></span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从函数返回多个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStyle</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        content, </span><br><span class="line">        container, </span><br><span class="line">        indicator </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    content: contentStyle,</span><br><span class="line">    container: containerStyle,</span><br><span class="line">    indicator: indicatorStyle</span><br><span class="line">&#125; = handleStyle();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 提取 JSON 数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">JSON</span> = &#123;</span><br><span class="line">    id: <span class="number">12345</span>,</span><br><span class="line">    status: <span class="string">'OK'</span>,</span><br><span class="line">    data: [<span class="number">123</span>, <span class="number">456</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; id, status, data &#125; = <span class="built_in">JSON</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 按需加载模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; Route, DefaultRoute, HistoryLocation &#125; = ReactRouter;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解构赋值可以以 <code>[x = &#39;0&#39;] = [y]</code> 的形式设置默认值，当 y 不存在时，x 的值就是 0；如果 y 不存在且没有设置默认值，则会被自动赋值为 undefined。</p>
</blockquote>
<h2 id="字符串">字符串</h2><p>ES2015 在字符串方面增强了对 Unicode 的支持，并扩展出了一些新的方法。在 ES2015 之前，JS 使用 <code>\uxxxx</code> 的形式只能正确解析 <code>\u0000-\uFFFF</code> 之间的字符，如果字符的编码超过了这个范围，就必须使用两个 <code>\uxxxx</code> 来表示，解析时会被识别为两个字符。</p>
<p>在 ES2015 中，将字符的编码放入大括号 {} 中，即可正确解析该字符，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"\u&#123;20BB7&#125;"</span>)</span><br><span class="line"><span class="comment">// =&gt; "𠮷"</span></span><br></pre></td></tr></table></figure>
<p>对于此类字符，字符串对象延伸出了一系列新的方法，这些新方法与旧方法相比，可以正确识别编码大于 0xFFFF 的字符：</p>
<ul>
<li>at()，类似于 charAt()，返回指定位置的字符</li>
<li>codePointAt()，类似于 charCodeAt()，返回指定位置字符的编码</li>
<li>String.fromCodePoint()，类似于 String.fromCharCode()，返回指定编码所对应的字符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span>.charAt(<span class="number">0</span>)   <span class="comment">// =&gt; "�"</span></span><br><span class="line"><span class="string">"\u&#123;20bb7&#125;"</span>.at(<span class="number">0</span>)       <span class="comment">// =&gt; "𠮷"</span></span><br></pre></td></tr></table></figure>
<p>字符串的另一个强力扩展是：模板字符串和标签模板。模板字符串（template string）类似于其他编程语言中的字符串插值，以反引号（`）为标志，字符串中的插值部分使用 <code>${}</code> 包裹：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// =&gt; '3 + 4 = 7'</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数的函数名之后紧跟一个模板字符串，那么这个函数就会被用来处理这个模板字符串，这个功能被称为<code>标签模板（tagged template）</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是一个数组</span></span><br><span class="line"><span class="comment">// 数组的元素是被插值部分分隔的字符串</span></span><br><span class="line"><span class="comment">// 第二个及以后的参数代表模板字符串中插值部分的值</span></span><br><span class="line"><span class="comment">// 可以使用参数扩展语法将其包裹到一个变量中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strs);</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// =&gt; [""," + "," = ",""]</span></span><br><span class="line"><span class="comment">// =&gt; [3,4,7]</span></span><br></pre></td></tr></table></figure>
<p>此外，ES 2015 还为字符串添加了 Iterator 接口，并提供了一系列新的工具方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"abcdefghi"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串 str 是否以参数字符串开头</span></span><br><span class="line">str.startsWith(<span class="string">'abc'</span>);</span><br><span class="line"><span class="comment">// 判断字符串 str 是否包含参数字符串</span></span><br><span class="line">str.includes(<span class="string">'def'</span>);</span><br><span class="line"><span class="comment">// 判断字符串 str 是否以参数字符串结尾</span></span><br><span class="line">str.endsWith(<span class="string">'ghi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成重复字符串</span></span><br><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; 'xxx'</span></span><br></pre></td></tr></table></figure>
<h2 id="数值">数值</h2><p>数值部分，一个是在 Number 对象上丰富了一些工具函数：</p>
<ul>
<li>Nubmer.isNaN()</li>
<li>Number.isFinite()</li>
<li>Number.parseInt()</li>
<li>Nubmer.parseFloat()</li>
<li>Nnmber.isInteger()</li>
<li>Number.EPSILON，极小量常量，在数值比对时，如果小于极小量，则判断两数相等</li>
<li>Number.isSafeInteger()，安全范围指（-2^53，2^53）</li>
<li>Number.MAX_SAFE_INTEGER</li>
<li>Number.MIN_SAFE_INTEGER</li>
</ul>
<p>二是在 Math 对象上扩展了一些数学函数：</p>
<ul>
<li>Math.trunc()，去除浮点数的小数部分</li>
<li>Math.sign()，判断数值是正数、负数还是零</li>
<li>Math.cbrt()，计算一个数值的立方根</li>
<li>Math.clz32()，返回一个数值的 32 位无符号整数形式前前导零的个数</li>
<li>Math.imul()</li>
<li>Math.fround()</li>
<li>Math.hypot()</li>
<li>Math.expn1()</li>
<li>Math.log1p()</li>
<li>Math.log10()</li>
<li>Math.log2()</li>
<li>Math.sinh()</li>
<li>Math.cosh()</li>
<li>Math.tanh()</li>
<li>Math.asinh()</li>
<li>Math.acosh()</li>
<li>Math.atanh()</li>
</ul>
<h2 id="数组">数组</h2></div></article></div></section><footer><div class="paginator"><a href="/2015/mac-tool-kit/" class="prev">上一篇</a><a href="/2015/求值策略/" class="next">下一篇</a></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>