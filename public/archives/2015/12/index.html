<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> PINGGOD · Focus On Program And Life</title><meta name="description" content="三年不翅，将以长羽翼；不飞不鸣，将以观民则。"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/ES2015/" class="post-title-link">ES2015</a></h2><div class="post-meta"><div class="post-time">Dec 15, 2015</div></div><div class="post-content"></div><a href="2015/ES2015/" class="read-more">... more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/求值策略/" class="post-title-link">求值策略</a></h2><div class="post-meta"><div class="post-time">Dec 10, 2015</div></div><div class="post-content"><blockquote>
<p>须知参差多态乃是幸福本源。</p>
</blockquote>
<p>求值策略所要解决的问题是：何时求值。之所以要控制求值的时间，往往是出于对内存占用和执行效率的考虑。在维基百科的求值策略词条中，列出了五种求值策略：</p>
<ul>
<li>预先求值，表达式绑定到变量时，立即求值并附加给变量</li>
<li>延迟求值，表达式绑定到变量后，并不求值，直到变量被调用时才求值</li>
<li>局部求值，又称柯里化</li>
<li>分布求值，map/reduce，典型应用是分布式计算</li>
<li>短路求值，与 (&amp;&amp;) 、或 (||) 逻辑运算</li>
</ul>
<p>顾名思义，预先求值和延迟求值是一对对立的求值策略。在下面的 js 代码段中，声明了变量 x，x 赋值后又被调用了三次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> + <span class="number">3</span> * (<span class="number">1</span> + <span class="number">5</span> ^ <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">func(x);</span><br></pre></td></tr></table></figure></div><a href="2015/求值策略/" class="read-more">... more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/inline-and-absolute/" class="post-title-link">inline* and absolute</a></h2><div class="post-meta"><div class="post-time">Dec 6, 2015</div></div><div class="post-content"><p>在一个容器中，所有元素都是 inline / inline-block 类型，此时可以使用 absolute + margin 的方式实现相对定位，而且相对定位的位置就是脱离文档流之前的位置。</p>
<p><img src="https://cloud.githubusercontent.com/assets/9530963/11618643/7fe8737c-9cd8-11e5-9919-e47705faa3c7.png" alt="absolute and margin"></p></div><a href="2015/inline-and-absolute/" class="read-more">... more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/Jade/" class="post-title-link">Jade</a></h2><div class="post-meta"><div class="post-time">Dec 3, 2015</div></div><div class="post-content"><p>如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Jade 也会是你的菜。Jade 类似于 Python，都采用了对缩进敏感的语法形式，比如下面这段代码创建了一个无序列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ul(<span class="class"><span class="keyword">class</span></span>=<span class="string">"inline"</span>)</span><br><span class="line">    li  Item C</span><br><span class="line">    li  Item A</span><br><span class="line">    li  Item B</span><br></pre></td></tr></table></figure></div><a href="2015/Jade/" class="read-more">... more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/CSS-Flexbox/" class="post-title-link">CSS Flexbox</a></h2><div class="post-meta"><div class="post-time">Dec 2, 2015</div></div><div class="post-content"><p>如果你正在学习使用 CSS 布局，推荐来 <a href="http://zh.learnlayout.com/toc.html">learnlayout</a> 了解一下这些年前端所用到的各类布局手法。这里之所以使用“手法”一词，意指其中多少有些偏激取巧，比如使用浮动（float）来定位、使用 margin 来伸缩空间等等。</p>
<p>float、margin 本不应该用于布局，只是囿于早期的 CSS 布局模块发展缓慢且不合时宜，促使开发者另辟蹊径，借助其他样式来模拟布局效果。最近几年随着浏览器对布局模块的支持度越来越高，Flexible Box Layout（Flexbox）、Grid Layout、Multiple Column Layout 也逐渐为开发者所接受，其中以 Flexbox 的兼容性最好，拥护者也随之水涨船高。</p>
<p>就个人感受而言，未来的布局方式会归纳为两类：一类是纯粹使用浏览器兼容性高的布局模块，比如 Flexbox，这也是未来的发展趋势；另一类是使用预处理器或者框架自定义的布局模块，这只是目前的缓兵过渡之计。</p></div><a href="2015/CSS-Flexbox/" class="read-more">... more</a></article></li></ul></section><footer><div class="paginator"><a class="prev"> </a><a class="prev"> </a></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>