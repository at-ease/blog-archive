{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0},{"_id":"source/CNAME","path":"CNAME","modified":0},{"_id":"source/img/react-lifecycle.png","path":"img/react-lifecycle.png","modified":0},{"_id":"source/img/react-component.png","path":"img/react-component.png","modified":0},{"_id":"source/img/react-component-comunication.png","path":"img/react-component-comunication.png","modified":0},{"_id":"source/img/mixin-vs-extend.png","path":"img/mixin-vs-extend.png","modified":0},{"_id":"source/img/mac-tool-kit.png","path":"img/mac-tool-kit.png","modified":0},{"_id":"source/img/inline-and-absolute.png","path":"img/inline-and-absolute.png","modified":0},{"_id":"source/img/flexbox.png","path":"img/flexbox.png","modified":0},{"_id":"source/img/flexbox-container.png","path":"img/flexbox-container.png","modified":0},{"_id":"source/img/flexbox-cell.png","path":"img/flexbox-cell.png","modified":0},{"_id":"source/img/es2015-set-methods.png","path":"img/es2015-set-methods.png","modified":0},{"_id":"source/img/es2015-generator-yield.png","path":"img/es2015-generator-yield.png","modified":0}],"Cache":[{"_id":"source/CNAME","shasum":"ba64683b82f51c18f5419339a4ef75e195f7c402","modified":1450170901000},{"_id":"source/_posts/CSS-Flexbox.md","shasum":"682a92fe7da6be62cffb80479de4b30a53604a78","modified":1451208722000},{"_id":"source/_posts/Pug.md","shasum":"4b146f0b3dddac225d473701aa34cc59fa9337a6","modified":1451296644000},{"_id":"source/_posts/ES2015.md","shasum":"c365897e59baa54b67dce80a733a38994aaee4ba","modified":1452247558000},{"_id":"source/_posts/React-组件的生命周期.md","shasum":"00a516162e38af3239528df017e607f7ebffa73c","modified":1451208630000},{"_id":"source/_posts/inline-and-absolute.md","shasum":"da221c4cce4258cdd72c6b58cf2caac3e92a6701","modified":1451208668000},{"_id":"source/_posts/Sass.md","shasum":"a6e1d8d6ac9cf942ad67dc4b989477cac696adfc","modified":1451208542000},{"_id":"source/_posts/React-组件间的消息传递.md","shasum":"5b2af4e056b293db8199cddc82c09181a1279ff2","modified":1451208761000},{"_id":"source/_posts/mac-tool-kit.md","shasum":"7b8b04d572747b5a2a56abea69b6207f8a711d92","modified":1451811529000},{"_id":"source/_posts/数据类型的分类.md","shasum":"d3c000566260ffd3fc260f6ec620345a54443c0a","modified":1450170901000},{"_id":"source/_posts/void-and-undefined.md","shasum":"b1031feb4823f14e676fae1e6c2a70b14993a224","modified":1450170901000},{"_id":"source/_posts/求值策略.md","shasum":"e75ffcb0f571928ffee2918d95e85d14acf700ce","modified":1450170901000},{"_id":"source/_posts/开发者必看的技术站点.md","shasum":"5ebb14dfd4b59a26f70af54fd302b6ae7501f4ef","modified":1451727565000},{"_id":"source/img/inline-and-absolute.png","shasum":"751ce8dc1722afd7b2db3b5dd86138e311c99b73","modified":1451208310000},{"_id":"source/img/mac-tool-kit.png","shasum":"36ee55cced5759ba695654a1f383104a78947385","modified":1451207810000},{"_id":"source/img/react-component-comunication.png","shasum":"5d243ccdb51ea0cb89da789c3da98cee01334eec","modified":1451208293000},{"_id":"source/img/mixin-vs-extend.png","shasum":"2f430c01fa165e5b47b2f8aa7272b3ba22afb495","modified":1451208284000},{"_id":"source/img/react-component.png","shasum":"b28847caa2ebe7b0a97cc9547dc72aa892cbbc0c","modified":1451208291000},{"_id":"themes/apollo/LICENSE","shasum":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1450170901000},{"_id":"themes/apollo/README.md","shasum":"1ba376ab25772656eb5af72f632ecff83cabf8cc","modified":1450170901000},{"_id":"themes/apollo/_config.yml","shasum":"cebf93a9f1ca539a3f0051fd862328aab26e8a38","modified":1450170901000},{"_id":"themes/apollo/doc/custom-blocks.md","shasum":"78e9400714d0ff7c9b272d3ccc80fb18c3bf208f","modified":1450170901000},{"_id":"themes/apollo/layout/index.jade","shasum":"58c451042cad5beeb5a76852bba609c651ff3428","modified":1450170901000},{"_id":"themes/apollo/layout/mixins/paginator.jade","shasum":"510ee0ba37b4522cca6c6204d641809454ba3ac6","modified":1450170901000},{"_id":"themes/apollo/layout/mixins/post.jade","shasum":"37411bb13470bbfdb78b300ad4feffd2a2737086","modified":1450170901000},{"_id":"themes/apollo/layout/partial/comment.jade","shasum":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1450170901000},{"_id":"themes/apollo/layout/partial/head.jade","shasum":"2ed7b73ad13b184e2bda9c80ba078ea33bbbbe4d","modified":1450170901000},{"_id":"themes/apollo/layout/partial/nav.jade","shasum":"c35d3061da4b053b73150d9741c542d660798270","modified":1450170901000},{"_id":"themes/apollo/layout/partial/layout.jade","shasum":"d9c4f8933f6740f5159713ec69ab943db5fb7cae","modified":1450170901000},{"_id":"themes/apollo/layout/partial/scripts.jade","shasum":"4c83fec1e2fc5cffefafc2e31835e28122c0fdfd","modified":1450170901000},{"_id":"themes/apollo/layout/post.jade","shasum":"7593ff041af04c387c457417237d9ab9e3cb467d","modified":1451799756000},{"_id":"themes/apollo/source/css/apollo.css","shasum":"2f4d716a8cbda4c8de6547624696adbc19c01881","modified":1450234668000},{"_id":"themes/apollo/source/scss/_partial/base.scss","shasum":"88b361e68475caddbab763feed5e1db788ac2cd7","modified":1450170901000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","shasum":"60cf365489c0d93cd7e9f10eedd4aee702e1ef27","modified":1450170901000},{"_id":"themes/apollo/source/favicon.png","shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1450170901000},{"_id":"themes/apollo/source/scss/_partial/header.scss","shasum":"d24cc6520f3faa7bb80610b858a92639eadcc289","modified":1450170901000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","shasum":"0b9c7097136ac8e4a07d9702fc4dbe0345ac7596","modified":1450170901000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","shasum":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1450170901000},{"_id":"themes/apollo/source/scss/_partial/post.scss","shasum":"8ca0ffea647c28ed0b158635a142e43ae052b2f2","modified":1450170901000},{"_id":"themes/apollo/source/scss/_partial/posts.scss","shasum":"92858015b8f3dcb4eb91b6dc41563b7aaa91b376","modified":1450170901000},{"_id":"themes/apollo/source/scss/apollo.scss","shasum":"f8b40223ea647b7c5627c344ead5c1a493bdd576","modified":1451104759000},{"_id":"source/img/flexbox-cell.png","shasum":"59cbe9f828002aeb8f50d42c89a813612c0b632e","modified":1451209167000},{"_id":"source/img/flexbox.png","shasum":"63e13991cb1478138c2feedd5872daa5dbfed0e5","modified":1451208976000},{"_id":"source/img/react-lifecycle.png","shasum":"b42c26be04d6dc409f0bdb923029d703f8956068","modified":1451208289000},{"_id":"source/img/flexbox-container.png","shasum":"01b28ae29312276ee695dd04bb45eacfd69c6aa7","modified":1451209035000},{"_id":"source/img/es2015-set-methods.png","shasum":"26481d1bf0dc59871404d6ced48aae135d7e9f97","modified":1452221614000},{"_id":"source/img/es2015-generator-yield.png","shasum":"c7f5479577c0383a41f670e5263ec570b35cfcde","modified":1452235914000},{"_id":"public/img/es2015-set-methods.png","modified":1452317310998,"shasum":"26481d1bf0dc59871404d6ced48aae135d7e9f97"},{"_id":"public/img/es2015-generator-yield.png","modified":1452317311003,"shasum":"c7f5479577c0383a41f670e5263ec570b35cfcde"},{"_id":"public/2015/开发者必看的技术站点/index.html","modified":1452317311193,"shasum":"97364dd7efd2ccd48b078d5be3f48945626f6782"},{"_id":"public/2015/mac-tool-kit/index.html","modified":1452317311303,"shasum":"055c554c244a51b4491a6b01690dca867b144e1c"},{"_id":"public/2015/ES2015/index.html","modified":1452317311403,"shasum":"bbc2e88dccf90f988d48f9c0038240b84f4ffe4e"},{"_id":"public/2015/求值策略/index.html","modified":1452317311498,"shasum":"5847bf5b89d5ae21da720e411cc0ab0072da758b"},{"_id":"public/2015/inline-and-absolute/index.html","modified":1452317311591,"shasum":"59a6e2e100c3596803577fd2ddca76e0de623ee9"},{"_id":"public/2015/Pug/index.html","modified":1452317311666,"shasum":"3de4fd6087e4fa6eafe6da1dc9ee318da5df89e9"},{"_id":"public/2015/CSS-Flexbox/index.html","modified":1452317311738,"shasum":"c08f6eb255f8b03436bfc75d32c40d1766369f01"},{"_id":"public/2015/void-and-undefined/index.html","modified":1452317311789,"shasum":"ae950287a2873e6de21271d72aca6c993a8446d5"},{"_id":"public/2015/React-组件间的消息传递/index.html","modified":1452317311846,"shasum":"6d7fd03e2e362716d728219662a2b8ba950d3f6a"},{"_id":"public/2015/React-组件的生命周期/index.html","modified":1452317311898,"shasum":"b0532a90f9266f797a72258c2ae823ca91539a32"},{"_id":"public/2015/Sass/index.html","modified":1452317311947,"shasum":"abadc44f025aebb86cef21ca220266cfbc20ca24"},{"_id":"public/2015/数据类型的分类/index.html","modified":1452317311996,"shasum":"d5f007960dd22f0ddc2bed30e3b307b909cb6975"},{"_id":"public/archives/index.html","modified":1452317312048,"shasum":"5df0b5d31d18a4dbdd22044fc1b21dd5643b87f5"},{"_id":"public/archives/page/2/index.html","modified":1452317312096,"shasum":"e450d49474c989920fec3865ec9d00c57b3489f0"},{"_id":"public/archives/2015/index.html","modified":1452317312142,"shasum":"934f222a5f7971e09a8d07014f39efdfa3e16701"},{"_id":"public/archives/2015/page/2/index.html","modified":1452317312184,"shasum":"73b0ed4852a0f1a196ec5896f4c1d928bf7e8008"},{"_id":"public/archives/2015/11/index.html","modified":1452317312222,"shasum":"27a2f7bb373738d7979f319504ff6b689c52858a"},{"_id":"public/archives/2015/12/index.html","modified":1452317312266,"shasum":"ecde066af39b60556e9d928f513b39b2d19a0008"},{"_id":"public/sitemap.xml","modified":1452317312268,"shasum":"edb870568009d4c9ee8ac20d3fd52f67aea3adaf"},{"_id":"public/index.html","modified":1452317312313,"shasum":"c4c260a4215cca58046e85dab444d4c8b8a20fd2"},{"_id":"public/page/2/index.html","modified":1452317312349,"shasum":"8e4a8b65700581cb07c34e54fb67ce0edae1ac06"},{"_id":"public/atom.xml","modified":1452317312353,"shasum":"03c579d704892be770fc4c27e936690d3b3d857f"}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"求值策略","date":"2015-12-10T05:43:07.000Z","_content":"\n> 须知参差多态乃是幸福本源。\n\n求值策略所要解决的问题是：何时求值。之所以要控制求值的时间，往往是出于对内存占用和执行效率的考虑。在维基百科的求值策略词条中，列出了五种求值策略：\n\n- 预先求值，表达式绑定到变量时，立即求值并附加给变量\n- 延迟求值，表达式绑定到变量后，并不求值，直到变量被调用时才求值\n- 局部求值，又称柯里化\n- 分布求值，map/reduce，典型应用是分布式计算\n- 短路求值，与 (&&) 、或 (||) 逻辑运算\n\n顾名思义，预先求值和延迟求值是一对对立的求值策略。在下面的 js 代码段中，声明了变量 x，x 赋值后又被调用了三次：\n\n```js\n// 1\nvar x = 5 + 3 * (1 + 5 ^ 2);\n// 2\nconsole.log(x);\nconsole.log(x + 2);\n// 3\nfunc(x);\n```\n\n<!-- more -->\n\n在 1 处，变量 x 完成了声明和赋值等初始化工作，它的值由表达式 (5 + 3 * (1 + 5 ^ 2)) 决定。在 2 处，console.log() 函数调用了变量 x 两次。让我们暂时忽略 js 编译器的求值策略，从个人主观的理性思维来思考一下：面对预先求值和延迟求值，你会怎么选择呢？\n\n做出选择之前，我们需要对变量 x 有一个复杂度的认知：如果表达式的复杂度高，那么该表达式所占用的内存空间也就越高，在变量 x 和表达式解绑前这段内存空间都无法释放掉，意味着 x 的间接内存占用了越高，此外，高复杂度也意味着较长的执行时间，所以复杂度和内存占用、执行效率至少是一种线性相关。\n\n如此说来，那么我们应该选择预先求值的求值策略，这样的好处是：变量 x 初始化时表达式立即计算，x 被重新赋值为 83，重新赋值后表达式所占用的内存空间被释放掉，达到了节省内存空间的目的；多次调用变量 x 时，x 的值已经是可以直接用于运算的数值，而不是需要计算的表达式，减少了重复运算，提高了执行效率。\n\n如果事情按照上面描述的美好愿景发展的话，就没有延迟求值策略出现的必要了。在 3 处，我们向函数 func() 传递了变量 x。这里的 func() 类似于一个黑盒，我们不了解其内部的处理机制，也无法确定 x 是否会被使用。这个时候延迟求值的价值就体现出来了，如果变量 x 在函数内部没有被使用，就不会执行求值，避免了预先求值所要执行的求值运算。\n\n随着表达式的复杂度逐渐提高，预先求值和延迟求值在内存占用、执行效率上的差异就会愈发明显。所以根据数据类型的复杂度，js 将数据类型分为原始值和引用值，传递参数时，原始值按值传递，引用值按引用传递。","source":"_posts/求值策略.md","raw":"title: 求值策略\ndate: 2015-12-10 13:43:07\n---\n\n> 须知参差多态乃是幸福本源。\n\n求值策略所要解决的问题是：何时求值。之所以要控制求值的时间，往往是出于对内存占用和执行效率的考虑。在维基百科的求值策略词条中，列出了五种求值策略：\n\n- 预先求值，表达式绑定到变量时，立即求值并附加给变量\n- 延迟求值，表达式绑定到变量后，并不求值，直到变量被调用时才求值\n- 局部求值，又称柯里化\n- 分布求值，map/reduce，典型应用是分布式计算\n- 短路求值，与 (&&) 、或 (||) 逻辑运算\n\n顾名思义，预先求值和延迟求值是一对对立的求值策略。在下面的 js 代码段中，声明了变量 x，x 赋值后又被调用了三次：\n\n```js\n// 1\nvar x = 5 + 3 * (1 + 5 ^ 2);\n// 2\nconsole.log(x);\nconsole.log(x + 2);\n// 3\nfunc(x);\n```\n\n<!-- more -->\n\n在 1 处，变量 x 完成了声明和赋值等初始化工作，它的值由表达式 (5 + 3 * (1 + 5 ^ 2)) 决定。在 2 处，console.log() 函数调用了变量 x 两次。让我们暂时忽略 js 编译器的求值策略，从个人主观的理性思维来思考一下：面对预先求值和延迟求值，你会怎么选择呢？\n\n做出选择之前，我们需要对变量 x 有一个复杂度的认知：如果表达式的复杂度高，那么该表达式所占用的内存空间也就越高，在变量 x 和表达式解绑前这段内存空间都无法释放掉，意味着 x 的间接内存占用了越高，此外，高复杂度也意味着较长的执行时间，所以复杂度和内存占用、执行效率至少是一种线性相关。\n\n如此说来，那么我们应该选择预先求值的求值策略，这样的好处是：变量 x 初始化时表达式立即计算，x 被重新赋值为 83，重新赋值后表达式所占用的内存空间被释放掉，达到了节省内存空间的目的；多次调用变量 x 时，x 的值已经是可以直接用于运算的数值，而不是需要计算的表达式，减少了重复运算，提高了执行效率。\n\n如果事情按照上面描述的美好愿景发展的话，就没有延迟求值策略出现的必要了。在 3 处，我们向函数 func() 传递了变量 x。这里的 func() 类似于一个黑盒，我们不了解其内部的处理机制，也无法确定 x 是否会被使用。这个时候延迟求值的价值就体现出来了，如果变量 x 在函数内部没有被使用，就不会执行求值，避免了预先求值所要执行的求值运算。\n\n随着表达式的复杂度逐渐提高，预先求值和延迟求值在内存占用、执行效率上的差异就会愈发明显。所以根据数据类型的复杂度，js 将数据类型分为原始值和引用值，传递参数时，原始值按值传递，引用值按引用传递。","slug":"求值策略","published":1,"updated":"2015-12-15T09:15:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q616m0000l9diepkvi3p1"},{"title":"数据类型的分类","date":"2015-11-15T11:29:36.000Z","_content":"\n开始写作本文的时候，我已经顺利地度过了四个月的前端实习生活，其间经手的项目勉强称得上稳定和健壮。但是刚刚学习前端的那些日子，可没现在这么自信，回想起来仍然颇多感慨。\n\n《JavaScript 典型应用与最佳实践》是我学习 JavaScript 的启蒙书籍，初版于 2008 年，面色古老而又心思缜密。其中的原始值和引用值一节，让我对 JavaScript 中数据类型的理解豁然开朗。如果从写作的角度看这本书，它的亮点在于以一种结构化的思维由浅入深地引导读者，主干和分支条缕清晰。有趣的是，在我用谷歌为结构化思维（Structed Thinking）查找一些理论依据的时候，链接到了一本更古老的书籍《金字塔原理：思考、写作和解决问题的逻辑》，书中介绍的正是作者自 1963 年以来反复实践的一套结构化思维，具体的细节等我读完后再聊吧。\n\n<!-- more -->\n\n最近项目中使用到的技术都比较激进，比如 ES6 / React / Flux 等等。在 ES6 的代码中你能看到诸多其他语言的影子，比如 Python，所以上一周我决定重新回顾一下 Python 中的要点，选用的参考资料是由 Wesley J. Chun 编写的《Python 核心编程（第二版）》。\n\n当读到 4.8 节《标准类型的分类》时，我可以确定，这又是一次结构化思维在知识传播过程中华丽的表演。在高级程序设计语言中，数据类型是必不可少的一部分。理解一门语言的数据类型，也是最基础的一步。虽然下面的示例交错使用 Python 和 JavaScript，但其中所叙述的本质是具有广泛性的。\n\n## Python\n\nPython 中每个对象都有三个特性：id, type 和 value。这些特性在对象初始化时创建。Python 内建了多种数据类型，基本类型包括：\n\n- integer, long integer, float, complex number\n- string\n- list\n- tuple\n- dictionary\n\n对数据类型分类，可以让我们更清晰地理解类型之间的关系以及工作原理。首先，使用存储模型进行分类。存储类型的衡量标准就是看对象能保存多少个对象。对于只能存储单个基本类型的对象，我们称之为原子或标量存储；那些可以存储多个基本类型的对象，称之为容器存储。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n标量 / 原子存储| 数值、字符串\n容器类型       | 列表、元素、字典\n\n然后，使用更新模型进行分类，更新模型的分类依据是看对象是否允许多次赋值。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n可变类型       | 列表、字典\n不可变类型     | 数值、字符串、元组\n\n最后，使用访问模型进行分类，访问模型的分类依据是看访问方式：直接存取、顺序存取以及映射存取。直接存储通过地址直接访问内存获取数据，数值属于这一类型；顺序存取通过对象的索引从 0 顺序访问内部元素，字符串、列表和元组都属于这一类型；映射存储与顺序存取类型，不同点在于它使用哈希键来访问数据，字典属于这一类型。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n直接访问       | 数值\n顺序访问       | 字符串、列表、元组\n映射访问       | 字典\n\n> 文中使用这么多的模型对数据类型分类，将基本类型和扩展类型进行区别，描述了各种类型的具体特征。简而言之，文中调侃了一句话：“一个优秀的工匠应该知道自己的工具箱有什么宝贝”。\n\n## JavaScript\n\nECMAScript 规范中定义了变量的两种类型：原始值类型和引用值类型。用以区分的依据就是它们在内存中的存储类型：值存储和址存储。\n\n为什么要分值和地址两种方式？一般而言，值存储的变量（原始值类型）都具有占据空间小、大小固定的特点。只有 string 是个特例，虽然它不具备大小固定的要求，但它是不可变的，是稳定而又会被频繁调用的。在其他语言中，string 大多是可变的。\n\n址存储的类型，具有占据空间大、大小不固定的特点，因此如果使用值存储的方式放在内存中，将会影响程序运行的性能。","source":"_posts/数据类型的分类.md","raw":"title: 数据类型的分类\ndate: 2015-11-15 19:29:36\n---\n\n开始写作本文的时候，我已经顺利地度过了四个月的前端实习生活，其间经手的项目勉强称得上稳定和健壮。但是刚刚学习前端的那些日子，可没现在这么自信，回想起来仍然颇多感慨。\n\n《JavaScript 典型应用与最佳实践》是我学习 JavaScript 的启蒙书籍，初版于 2008 年，面色古老而又心思缜密。其中的原始值和引用值一节，让我对 JavaScript 中数据类型的理解豁然开朗。如果从写作的角度看这本书，它的亮点在于以一种结构化的思维由浅入深地引导读者，主干和分支条缕清晰。有趣的是，在我用谷歌为结构化思维（Structed Thinking）查找一些理论依据的时候，链接到了一本更古老的书籍《金字塔原理：思考、写作和解决问题的逻辑》，书中介绍的正是作者自 1963 年以来反复实践的一套结构化思维，具体的细节等我读完后再聊吧。\n\n<!-- more -->\n\n最近项目中使用到的技术都比较激进，比如 ES6 / React / Flux 等等。在 ES6 的代码中你能看到诸多其他语言的影子，比如 Python，所以上一周我决定重新回顾一下 Python 中的要点，选用的参考资料是由 Wesley J. Chun 编写的《Python 核心编程（第二版）》。\n\n当读到 4.8 节《标准类型的分类》时，我可以确定，这又是一次结构化思维在知识传播过程中华丽的表演。在高级程序设计语言中，数据类型是必不可少的一部分。理解一门语言的数据类型，也是最基础的一步。虽然下面的示例交错使用 Python 和 JavaScript，但其中所叙述的本质是具有广泛性的。\n\n## Python\n\nPython 中每个对象都有三个特性：id, type 和 value。这些特性在对象初始化时创建。Python 内建了多种数据类型，基本类型包括：\n\n- integer, long integer, float, complex number\n- string\n- list\n- tuple\n- dictionary\n\n对数据类型分类，可以让我们更清晰地理解类型之间的关系以及工作原理。首先，使用存储模型进行分类。存储类型的衡量标准就是看对象能保存多少个对象。对于只能存储单个基本类型的对象，我们称之为原子或标量存储；那些可以存储多个基本类型的对象，称之为容器存储。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n标量 / 原子存储| 数值、字符串\n容器类型       | 列表、元素、字典\n\n然后，使用更新模型进行分类，更新模型的分类依据是看对象是否允许多次赋值。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n可变类型       | 列表、字典\n不可变类型     | 数值、字符串、元组\n\n最后，使用访问模型进行分类，访问模型的分类依据是看访问方式：直接存取、顺序存取以及映射存取。直接存储通过地址直接访问内存获取数据，数值属于这一类型；顺序存取通过对象的索引从 0 顺序访问内部元素，字符串、列表和元组都属于这一类型；映射存储与顺序存取类型，不同点在于它使用哈希键来访问数据，字典属于这一类型。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n直接访问       | 数值\n顺序访问       | 字符串、列表、元组\n映射访问       | 字典\n\n> 文中使用这么多的模型对数据类型分类，将基本类型和扩展类型进行区别，描述了各种类型的具体特征。简而言之，文中调侃了一句话：“一个优秀的工匠应该知道自己的工具箱有什么宝贝”。\n\n## JavaScript\n\nECMAScript 规范中定义了变量的两种类型：原始值类型和引用值类型。用以区分的依据就是它们在内存中的存储类型：值存储和址存储。\n\n为什么要分值和地址两种方式？一般而言，值存储的变量（原始值类型）都具有占据空间小、大小固定的特点。只有 string 是个特例，虽然它不具备大小固定的要求，但它是不可变的，是稳定而又会被频繁调用的。在其他语言中，string 大多是可变的。\n\n址存储的类型，具有占据空间大、大小不固定的特点，因此如果使用值存储的方式放在内存中，将会影响程序运行的性能。","slug":"数据类型的分类","published":1,"updated":"2015-12-15T09:15:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q616s0001l9dia81vbksg"},{"title":"WEB 开发者必看的技术站点","date":"2015-12-31T06:49:13.000Z","_content":"\n> 本文总结自 Quora 上的一个问答：[What are the top 10 websites a web developer must see](https://www.quora.com/What-are-the-top-10-websites-a-web-developer-must-see)。\n\n读专业书、看教程视频、浏览技术博客、参加讲座分享……这些提高技能的途径各有优劣，相比较而言，博客或者说技术网站可以最快接触前沿技术、分享技术实践，所以，除了依赖谷歌反馈的词条，我们还可以主动收集一些优秀的技术站点，便于自己了解、参与和实践业界最活跃的技术。\n\n<!-- more -->\n\n1. [GitHub](https://github.com) —— 当下最流行的版本管理工具，云集了世界上最优秀的开发者。在 GitHub 开源之风盛行，我喜欢在这里关注各类优秀项目，也喜欢在这里查找各种工具，比如需要某个 alfred 的插件，在这里搜一下也许就能找到，如果遇到了问题，和开发者反馈一下也不是什么难事。最近喜欢浏览 trending 和 follow 大神，便于了解业界动态，顺便细化下自己的技术栈。\n\n1. [A List Apart](http://alistapart.com/)—— 我想给这个网站定义几个头衔，比如顶级、前沿、经典、最具影响力之类等等。这个网站创办十八年了（from 1998），专注对前端方向的探索，每一篇文章都是深入思考的结晶。典型的文章就是[《Responsive Web Design》](http://alistapart.com/article/responsive-web-design)，发表之后迅速启发了业界的开发思维，打开了响应式设计的大门。\n\n1. [MDN](https://developer.mozilla.org) —— Mozilla 开发者网络知识库，权威、全面的 WEB 文档，支持多种语言，示例丰富。\n\n1. [Stack Overflow](http://stackoverflow.com/) —— 活跃的技术问答社区。一般问题都有开发者问过了，如果找不到，换一换关键字，最后的方式才应该是提问。作为开发者，为了使用 Stack Overflow 也应该给自己准备一个翻墙工具，永远不要闭门造车般的解决问题。\n\n1. [Can I Use](http://caniuse.com/) —— 如果你有兼容性问题，先来这里看看浏览器的支持情况吧。\n\n1. [CSS-Tricks](https://css-tricks.com/) —— 这里发表所有和 CSS 有关的技巧和教程，当然如果你想来这里找点黑科技，也是有的。\n\n1. [Codrops](http://tympanus.net/codrops/) —— 如果有一天我可以靠理想生活，那我肯定要先实践一番 Codrops 上的教程，这些教程的效果绝对出彩，这也是前端吸引我的魅力所在。\n\n1. [CodePen](http://codepen.io/) —— 在线 WEB 开发工具。一方面我们可以在这里快速实践自己的灵感，另一方面当我们的调试遇到困境，在这里搭一个 DEMO 详细描述下问题，然后发给有经验的人，绝对是最佳的问答礼仪。\n\n1. [Dribble](https://dribbble.com/) —— 作为前端开发者，要求我们必须具备一定的审美水平，来 Dribble 看看吧，你会重新燃起创造力的激情，比如用 WEB 技术实践几个 Driible 的原型图，那一定帅得不行不行的。\n\n1. [CSS Zen Garden（CSS 禅意花园）](http://csszengarden.com/)—— 现在网站的效果越来风格化，无论是简约还是拟物都十分精致，相比而言，来自上个年代的 CSS 禅意花园已经显得并不是很出彩了，但实际上其中还有很多重要的东西值得学习，建议各位读一读[ CSS 禅意花园](http://book.douban.com/subject/2052176/)这本书，看一下作者对各个主题的分析，了解从设计立意到编码开发的诸多思考。\n\n\n\n\n\n\n下面这些网站的内容大都涵盖了从 WEB 到设计、从图形到动效、从数据到运维的方方面面，是非常全面的技术站点：\n\n1. [DZone](https://dzone.com/) —— Programming, Web Development, and DevOps news, tutorials and tools for beginners to experts. Hundreds of free publications, over 1M members, totally free.\n\n1. [Smashing Magazine](http://www.smashingmagazine.com/) —— Smashing Magazine is an online magazine for professional Web designers and developers, with a focus on useful techniques, best practices and valuable resources.\n \n1. [SitePoint](http://www.sitepoint.com/) —— Learn Web Design & Development with SitePoint tutorials, courses and books - HTML5, CSS3, JavaScript, PHP, mobile app development, Responsive Web Design.\n\n1. [CodeProject](http://www.codeproject.com/) —— Free source code and tutorials for Software developers and Architects.; Updated: 2 Jan 2016.","source":"_posts/开发者必看的技术站点.md","raw":"title: WEB 开发者必看的技术站点\ndate: 2015-12-31 14:49:13\n---\n\n> 本文总结自 Quora 上的一个问答：[What are the top 10 websites a web developer must see](https://www.quora.com/What-are-the-top-10-websites-a-web-developer-must-see)。\n\n读专业书、看教程视频、浏览技术博客、参加讲座分享……这些提高技能的途径各有优劣，相比较而言，博客或者说技术网站可以最快接触前沿技术、分享技术实践，所以，除了依赖谷歌反馈的词条，我们还可以主动收集一些优秀的技术站点，便于自己了解、参与和实践业界最活跃的技术。\n\n<!-- more -->\n\n1. [GitHub](https://github.com) —— 当下最流行的版本管理工具，云集了世界上最优秀的开发者。在 GitHub 开源之风盛行，我喜欢在这里关注各类优秀项目，也喜欢在这里查找各种工具，比如需要某个 alfred 的插件，在这里搜一下也许就能找到，如果遇到了问题，和开发者反馈一下也不是什么难事。最近喜欢浏览 trending 和 follow 大神，便于了解业界动态，顺便细化下自己的技术栈。\n\n1. [A List Apart](http://alistapart.com/)—— 我想给这个网站定义几个头衔，比如顶级、前沿、经典、最具影响力之类等等。这个网站创办十八年了（from 1998），专注对前端方向的探索，每一篇文章都是深入思考的结晶。典型的文章就是[《Responsive Web Design》](http://alistapart.com/article/responsive-web-design)，发表之后迅速启发了业界的开发思维，打开了响应式设计的大门。\n\n1. [MDN](https://developer.mozilla.org) —— Mozilla 开发者网络知识库，权威、全面的 WEB 文档，支持多种语言，示例丰富。\n\n1. [Stack Overflow](http://stackoverflow.com/) —— 活跃的技术问答社区。一般问题都有开发者问过了，如果找不到，换一换关键字，最后的方式才应该是提问。作为开发者，为了使用 Stack Overflow 也应该给自己准备一个翻墙工具，永远不要闭门造车般的解决问题。\n\n1. [Can I Use](http://caniuse.com/) —— 如果你有兼容性问题，先来这里看看浏览器的支持情况吧。\n\n1. [CSS-Tricks](https://css-tricks.com/) —— 这里发表所有和 CSS 有关的技巧和教程，当然如果你想来这里找点黑科技，也是有的。\n\n1. [Codrops](http://tympanus.net/codrops/) —— 如果有一天我可以靠理想生活，那我肯定要先实践一番 Codrops 上的教程，这些教程的效果绝对出彩，这也是前端吸引我的魅力所在。\n\n1. [CodePen](http://codepen.io/) —— 在线 WEB 开发工具。一方面我们可以在这里快速实践自己的灵感，另一方面当我们的调试遇到困境，在这里搭一个 DEMO 详细描述下问题，然后发给有经验的人，绝对是最佳的问答礼仪。\n\n1. [Dribble](https://dribbble.com/) —— 作为前端开发者，要求我们必须具备一定的审美水平，来 Dribble 看看吧，你会重新燃起创造力的激情，比如用 WEB 技术实践几个 Driible 的原型图，那一定帅得不行不行的。\n\n1. [CSS Zen Garden（CSS 禅意花园）](http://csszengarden.com/)—— 现在网站的效果越来风格化，无论是简约还是拟物都十分精致，相比而言，来自上个年代的 CSS 禅意花园已经显得并不是很出彩了，但实际上其中还有很多重要的东西值得学习，建议各位读一读[ CSS 禅意花园](http://book.douban.com/subject/2052176/)这本书，看一下作者对各个主题的分析，了解从设计立意到编码开发的诸多思考。\n\n\n\n\n\n\n下面这些网站的内容大都涵盖了从 WEB 到设计、从图形到动效、从数据到运维的方方面面，是非常全面的技术站点：\n\n1. [DZone](https://dzone.com/) —— Programming, Web Development, and DevOps news, tutorials and tools for beginners to experts. Hundreds of free publications, over 1M members, totally free.\n\n1. [Smashing Magazine](http://www.smashingmagazine.com/) —— Smashing Magazine is an online magazine for professional Web designers and developers, with a focus on useful techniques, best practices and valuable resources.\n \n1. [SitePoint](http://www.sitepoint.com/) —— Learn Web Design & Development with SitePoint tutorials, courses and books - HTML5, CSS3, JavaScript, PHP, mobile app development, Responsive Web Design.\n\n1. [CodeProject](http://www.codeproject.com/) —— Free source code and tutorials for Software developers and Architects.; Updated: 2 Jan 2016.","slug":"开发者必看的技术站点","published":1,"updated":"2016-01-02T09:39:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q616w0002l9dif7843ide"},{"title":"void and undefined","date":"2015-11-30T12:18:37.000Z","_content":"\n一直以来，`undefined` 都不是 JavaScript 的关键字或保留字，这意味着我们可以修改 window.undefined 的值。由于 undefined 会被频繁调用作为比较运算的操作数，所以在 ES5 规范之后，window.undefined 被定义为不可写、不可配置的属性。常见的 undefined 列述如下:\n\n- 变量声明后未赋值，则变量会被自动赋值为 undefined\n- 函数中定义了一些形参，如果传入的实参少于预定义的形参，那么有一些形参就会匹配不到实参，继而会被自动赋值为 undefined\n- 没有返回值的函数，默认返回 undefined\n\n`void (expression)`，void 作为一个运算符，无论表达式的内容是什么，只要跟在 void 之后都会被调用执行，执行完毕后 void 操作符返回 undefined。简而言之，使用 void 运算符有三种用处：生成 undefined；让函数立即执行；充当 `javascript:` 协议的 URI。\n\n<!-- more -->\n\n## 生成 undefined\n\n使用 `void 0` 生成 undefined 的做法由来已久，既减少了在原形链上查找 window.undefined 的时间，也避免了误用被修改过的 undefined。\n\n```js\nfunction checkLogin (loginName) {\n    if (loginName === void 0) {\n        console.log('Wrong!');\n    } \n}\n\ncheckLogin();\n// => 'Wrong!'\n```\n\n## 立即执行函数\n\n**运算符和函数组合使用，可以让函数立即执行。**实际上，有许多运算符可以让函数立即执行，比如 +、-、!、~ 以及本文提到的 void 等运算符。此外，还有最常见的小括号（分组运算符）：\n\n```js\n(function(){\n    console.log('立即执行');\n})();\n// => '立即执行'\n```\n\n## 充当 `javascript:` 协议的 URI\n\n对于网页中的点赞、收藏等按钮，如果使用 a 标签来实现的话，往往会用到 `href=\"javascript:void(0)\"` 等类似的代码，这段代码的作用是点击链接时让页面不跳转。\n\n在 href=\"javascript:void(0)\" 中，使用了一个以 `javascript:` 协议开头的 URI，浏览器默认会对冒号后面的代码求值，然后将结果显示在新的页面，但有一种情况例外，如果结果是 undefined，浏览器就不会刷新页面渲染新值了。\n\n实际上，我们有很多方式实现点赞、收藏的效果，无需使用这么 Hack 的方式——虽然这确实很方便。\n\n> `javascript:` 协议声明了 URL 的主体是任意的 javascript 代码，由 javascript 解释器编译执行，通常使用 `javascript:URL` 执行某些不改变当前页面文档的代码，要做到这一点，必须确保 URL 的最后一条语句没有返回值，比如使用 `void 0`。\n\n## 参考资料\n\n- [undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)\n- [void 运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\n- [谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)\n- [JavaScript中伪协议 javascript:使用探讨](http://www.jb51.net/article/52358.htm)","source":"_posts/void-and-undefined.md","raw":"title: void and undefined\ndate: 2015-11-30 20:18:37\n---\n\n一直以来，`undefined` 都不是 JavaScript 的关键字或保留字，这意味着我们可以修改 window.undefined 的值。由于 undefined 会被频繁调用作为比较运算的操作数，所以在 ES5 规范之后，window.undefined 被定义为不可写、不可配置的属性。常见的 undefined 列述如下:\n\n- 变量声明后未赋值，则变量会被自动赋值为 undefined\n- 函数中定义了一些形参，如果传入的实参少于预定义的形参，那么有一些形参就会匹配不到实参，继而会被自动赋值为 undefined\n- 没有返回值的函数，默认返回 undefined\n\n`void (expression)`，void 作为一个运算符，无论表达式的内容是什么，只要跟在 void 之后都会被调用执行，执行完毕后 void 操作符返回 undefined。简而言之，使用 void 运算符有三种用处：生成 undefined；让函数立即执行；充当 `javascript:` 协议的 URI。\n\n<!-- more -->\n\n## 生成 undefined\n\n使用 `void 0` 生成 undefined 的做法由来已久，既减少了在原形链上查找 window.undefined 的时间，也避免了误用被修改过的 undefined。\n\n```js\nfunction checkLogin (loginName) {\n    if (loginName === void 0) {\n        console.log('Wrong!');\n    } \n}\n\ncheckLogin();\n// => 'Wrong!'\n```\n\n## 立即执行函数\n\n**运算符和函数组合使用，可以让函数立即执行。**实际上，有许多运算符可以让函数立即执行，比如 +、-、!、~ 以及本文提到的 void 等运算符。此外，还有最常见的小括号（分组运算符）：\n\n```js\n(function(){\n    console.log('立即执行');\n})();\n// => '立即执行'\n```\n\n## 充当 `javascript:` 协议的 URI\n\n对于网页中的点赞、收藏等按钮，如果使用 a 标签来实现的话，往往会用到 `href=\"javascript:void(0)\"` 等类似的代码，这段代码的作用是点击链接时让页面不跳转。\n\n在 href=\"javascript:void(0)\" 中，使用了一个以 `javascript:` 协议开头的 URI，浏览器默认会对冒号后面的代码求值，然后将结果显示在新的页面，但有一种情况例外，如果结果是 undefined，浏览器就不会刷新页面渲染新值了。\n\n实际上，我们有很多方式实现点赞、收藏的效果，无需使用这么 Hack 的方式——虽然这确实很方便。\n\n> `javascript:` 协议声明了 URL 的主体是任意的 javascript 代码，由 javascript 解释器编译执行，通常使用 `javascript:URL` 执行某些不改变当前页面文档的代码，要做到这一点，必须确保 URL 的最后一条语句没有返回值，比如使用 `void 0`。\n\n## 参考资料\n\n- [undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)\n- [void 运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\n- [谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)\n- [JavaScript中伪协议 javascript:使用探讨](http://www.jb51.net/article/52358.htm)","slug":"void-and-undefined","published":1,"updated":"2015-12-15T09:15:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q616y0003l9di3uxbpsl9"},{"title":"mac tool kit","date":"2015-12-26T10:17:00.000Z","_content":"\n这会是一篇持续更新的文章，用于记录我在 mac 中常用的开发工具。过去的一年（2015）里，我使用 mac 作为开发的主力平台，在上面折腾过各类软件，以实现最高的开发效率和最舒适的开发环境。一切都是为了开发成果服务，脱离结果强调过程不是我支持的态度，简而言之，这些都是一些增益技巧。\n\n文中工具的排序规则（核心是优先安装具有依赖关系的软件）：\n\n1. 从常用工具中随机选择一个工具作为 random seed\n2. 根据 random seed 的配置过程进行上溯，上溯到的目标工具排在 random seed 之前\n3. 如果上溯到的系统工具不常用，以常用工具替换，比如 chrome 替换 safari\n4. random seed 可组合使用的工具排在 random seed 之后\n5. random seed 中包含的插件在 random seed 中以列表的形式列出\n6. 每次接触新工具，将 random seed 设为该工具，循环执行 2、3、4 过程\n7. 其他工具根据肌肉对键盘的非条件反射随机排列\n\n![mac tool kit 排列方法 2015-12-27.png](/img/mac-tool-kit.png)\n\n<!-- more -->\n\n## preparation\n\n在选择下文中的工具时，主要有两点参考标准：\n\n- 快速，指响应速度和切换速度，或者可以提高这两点的工具。目前键盘操作是无冲突下最快速的控制方式，所以这也是围绕速度进行评估的关键点。\n- 界面有设计亮点，这纯属前端职业病\n\n<div class=\"tip\">\n    初始化 mac 之后，依次进入系统偏好设置 -> 键盘 -> 修饰键，将 Caps Lock 键映射为 Control 键，别问为什么，用心去体会吧 —— Casp Lock 的功能价值与它在键盘布局中所占有的重要位置极度不相符。\n</div>\n \n## applications list\n\n1. [iTerm2](https://www.iterm2.com/downloads.html)，终端工具，替代系统自带的终端，主题 [dracula-theme](https://github.com/zenorocha/dracula-theme)。\n    - Xcode command Line Tool，Homebrew 的依赖，可通过 `xcode-select --install` 命令或者安装 Xcode 来完成\n\n1. [Xcode](https://developer.apple.com/cn/xcode/downloads/)，苹果产品开发环境，\n\n1. [Homebrew](http://brew.sh/)，OS X 的包管理工具：\n    - [nvm](https://github.com/creationix/nvm)，node 版本管理工具\n    - [node](https://github.com/nodejs/node)，运行在服务端的 JavaScript，使用 nvm 统一管理\n    - [tmux](https://tmux.github.io/)，终端复用工具\n    - [tree](http://mama.indstate.edu/users/ice/tree/)，树状结构目录\n    - [python / python3](https://www.python.org)，python 开发环境\n    - [nginx](http://nginx.org/)，反向代理服务器\n    - [httpie](https://github.com/jakubroztocil/httpie)，替代 curl 的 HTTP 终端工具\n    - [optipng](http://optipng.sourceforge.net/)，png 优化工具\n\n1. [Homebrew Cask](http://caskroom.io/)，使用 hombrew 安装，可用于安装 OS X 应用：\n    - [haskell platform](http://caskroom.io/search)，haskell 开发环境\n\n1. [Chrome / Chrome Canary](http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html)，插件众多，开发调试便利，平时也比较依赖谷歌体系内的东西。插件：\n    - [GitHub Old Header](https://chrome.google.com/webstore/detail/github-old-header/bbencfiifelhglgknaheifiekmjndlek)，在顶部导航区提供一个指向个人页面的链接\n    - [HTTP status](https://chrome.google.com/webstore/detail/http-status/cknfnacbckhfpjahnmkblajcpledpfnp)，在地址栏显示 HTTTP 状态码\n    - [JSON Formatter](https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=zh-CN)，格式化浏览器预览到的 JSON 数据\n    - [Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=zh-CN)，为 GitHub 仓库提供一个树状结构目录\n    - [Save to Pocket](https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj?hl=zh-CN)，右键保存到 Pocket\n\n1. [Sublime Text 3](http://www.sublimetext.com/3)，编辑器，适用多平台响应迅速扩展能力强。插件：\n    - [Package Control](https://packagecontrol.io/installation#st3)，Sublime 扩展插件的安装和管理工具\n    - [DashDoc](https://packagecontrol.io/packages/DashDoc)，调用 Dash\n    - [Emmet](http://emmet.io/)，前端开发工具集\n    - [BracketHighlighter](https://packagecontrol.io/packages/BracketHighlighter)，标签和符号的高亮工具\n    - [SideBarEnhancements](https://packagecontrol.io/packages/SideBarEnhancements)，侧边栏功能扩展插件\n    - [Material Theme](https://github.com/equinusocio/material-theme)，谷歌 material 风格的简洁主题\n    - [Babel](https://packagecontrol.io/packages/Babel)，JSX 和 ES6 的高亮插件，不具有编译功能\n    - [DocBlockr](https://packagecontrol.io/packages/DocBlockr)，Javascript, PHP, CoffeeScript, Actionscript, C & C++ 规范化注释\n\n1. [Dash](https://kapeli.com/dash)，开发文档、代码片段管理工具\n\n1. [alfred](https://www.alfredapp.com/)，必备辅助工具，提高工作效率，不要让双手离开键盘\n\n1. [Pocket](https://getpocket.com/)，离线阅读工具，也被用来做知识管理\n\n1. [Snip](http://snip.qq.com/)，滚动截屏必备工具\n\n1. [Ember](http://realmacsoftware.com/ember/)，图库管理，可以订阅 dribbble popular。\n\n1. [Microsoft office](https://products.office.com/zh-cn/mac/microsoft-office-for-mac)，我喜欢用 PowerPoint 来做流程图、序列图……\n\n1. [Tuck](http://www.irradiatedsoftware.com/tuck/)，将应用程序隐藏到窗口边缘\n\n1. [SizeUp](http://www.irradiatedsoftware.com/sizeup/)，管理应用程序窗口的位置和大小\n\n## host configuration\n\n最近在熟悉云主机的使用，下面是配置过程：\n\n1. ssh root 账号登录云主机，通过 `passwd` 命令更改主机密码，至于怎样设置结构复杂的密码，建议参考文章[《每一个程序员都有一颗当诗人的心》](http://www.hello-code.com/diary/201409/2223.html)。\n\n1. 使用 root 账号创建普通用户：`adduser sean`、`passwd sean`，然后为新用户配置权限，通过 `visudo` 命令添加 `sean ALL=(ALL) ALL` 配置信息，完成后退出 root 账户，使用普通账户登录云主机，比如这里的 sean。\n\n1. 安装常用工具：\n    - [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\n    - [amix/vimrc](https://github.com/amix/vimrc)\n    - [bling/vim-airline](https://github.com/bling/vim-airline)\n    - [powerline/fonts](https://github.com/powerline/fonts)\n    - [nvm](https://github.com/creationix/nvm)\n    - [node](https://github.com/nodejs/node)\n    - [node:tldr](https://github.com/tldr-pages/tldr)\n    - [apt-get:tree](https://packages.debian.org/search?keywords=tree)\n\n## tldr\n\n不断地在中英文间进行切换也是非常低效率的操作，所以，初步设定在 2016 年底脱离非业务开发下对中文输入的依赖——不过我最喜欢的哲学思维还是先秦百家交叉融汇出的框架。","source":"_posts/mac-tool-kit.md","raw":"title: mac tool kit\ndate: 2015-12-26 18:17:00\n---\n\n这会是一篇持续更新的文章，用于记录我在 mac 中常用的开发工具。过去的一年（2015）里，我使用 mac 作为开发的主力平台，在上面折腾过各类软件，以实现最高的开发效率和最舒适的开发环境。一切都是为了开发成果服务，脱离结果强调过程不是我支持的态度，简而言之，这些都是一些增益技巧。\n\n文中工具的排序规则（核心是优先安装具有依赖关系的软件）：\n\n1. 从常用工具中随机选择一个工具作为 random seed\n2. 根据 random seed 的配置过程进行上溯，上溯到的目标工具排在 random seed 之前\n3. 如果上溯到的系统工具不常用，以常用工具替换，比如 chrome 替换 safari\n4. random seed 可组合使用的工具排在 random seed 之后\n5. random seed 中包含的插件在 random seed 中以列表的形式列出\n6. 每次接触新工具，将 random seed 设为该工具，循环执行 2、3、4 过程\n7. 其他工具根据肌肉对键盘的非条件反射随机排列\n\n![mac tool kit 排列方法 2015-12-27.png](/img/mac-tool-kit.png)\n\n<!-- more -->\n\n## preparation\n\n在选择下文中的工具时，主要有两点参考标准：\n\n- 快速，指响应速度和切换速度，或者可以提高这两点的工具。目前键盘操作是无冲突下最快速的控制方式，所以这也是围绕速度进行评估的关键点。\n- 界面有设计亮点，这纯属前端职业病\n\n<div class=\"tip\">\n    初始化 mac 之后，依次进入系统偏好设置 -> 键盘 -> 修饰键，将 Caps Lock 键映射为 Control 键，别问为什么，用心去体会吧 —— Casp Lock 的功能价值与它在键盘布局中所占有的重要位置极度不相符。\n</div>\n \n## applications list\n\n1. [iTerm2](https://www.iterm2.com/downloads.html)，终端工具，替代系统自带的终端，主题 [dracula-theme](https://github.com/zenorocha/dracula-theme)。\n    - Xcode command Line Tool，Homebrew 的依赖，可通过 `xcode-select --install` 命令或者安装 Xcode 来完成\n\n1. [Xcode](https://developer.apple.com/cn/xcode/downloads/)，苹果产品开发环境，\n\n1. [Homebrew](http://brew.sh/)，OS X 的包管理工具：\n    - [nvm](https://github.com/creationix/nvm)，node 版本管理工具\n    - [node](https://github.com/nodejs/node)，运行在服务端的 JavaScript，使用 nvm 统一管理\n    - [tmux](https://tmux.github.io/)，终端复用工具\n    - [tree](http://mama.indstate.edu/users/ice/tree/)，树状结构目录\n    - [python / python3](https://www.python.org)，python 开发环境\n    - [nginx](http://nginx.org/)，反向代理服务器\n    - [httpie](https://github.com/jakubroztocil/httpie)，替代 curl 的 HTTP 终端工具\n    - [optipng](http://optipng.sourceforge.net/)，png 优化工具\n\n1. [Homebrew Cask](http://caskroom.io/)，使用 hombrew 安装，可用于安装 OS X 应用：\n    - [haskell platform](http://caskroom.io/search)，haskell 开发环境\n\n1. [Chrome / Chrome Canary](http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html)，插件众多，开发调试便利，平时也比较依赖谷歌体系内的东西。插件：\n    - [GitHub Old Header](https://chrome.google.com/webstore/detail/github-old-header/bbencfiifelhglgknaheifiekmjndlek)，在顶部导航区提供一个指向个人页面的链接\n    - [HTTP status](https://chrome.google.com/webstore/detail/http-status/cknfnacbckhfpjahnmkblajcpledpfnp)，在地址栏显示 HTTTP 状态码\n    - [JSON Formatter](https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=zh-CN)，格式化浏览器预览到的 JSON 数据\n    - [Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=zh-CN)，为 GitHub 仓库提供一个树状结构目录\n    - [Save to Pocket](https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj?hl=zh-CN)，右键保存到 Pocket\n\n1. [Sublime Text 3](http://www.sublimetext.com/3)，编辑器，适用多平台响应迅速扩展能力强。插件：\n    - [Package Control](https://packagecontrol.io/installation#st3)，Sublime 扩展插件的安装和管理工具\n    - [DashDoc](https://packagecontrol.io/packages/DashDoc)，调用 Dash\n    - [Emmet](http://emmet.io/)，前端开发工具集\n    - [BracketHighlighter](https://packagecontrol.io/packages/BracketHighlighter)，标签和符号的高亮工具\n    - [SideBarEnhancements](https://packagecontrol.io/packages/SideBarEnhancements)，侧边栏功能扩展插件\n    - [Material Theme](https://github.com/equinusocio/material-theme)，谷歌 material 风格的简洁主题\n    - [Babel](https://packagecontrol.io/packages/Babel)，JSX 和 ES6 的高亮插件，不具有编译功能\n    - [DocBlockr](https://packagecontrol.io/packages/DocBlockr)，Javascript, PHP, CoffeeScript, Actionscript, C & C++ 规范化注释\n\n1. [Dash](https://kapeli.com/dash)，开发文档、代码片段管理工具\n\n1. [alfred](https://www.alfredapp.com/)，必备辅助工具，提高工作效率，不要让双手离开键盘\n\n1. [Pocket](https://getpocket.com/)，离线阅读工具，也被用来做知识管理\n\n1. [Snip](http://snip.qq.com/)，滚动截屏必备工具\n\n1. [Ember](http://realmacsoftware.com/ember/)，图库管理，可以订阅 dribbble popular。\n\n1. [Microsoft office](https://products.office.com/zh-cn/mac/microsoft-office-for-mac)，我喜欢用 PowerPoint 来做流程图、序列图……\n\n1. [Tuck](http://www.irradiatedsoftware.com/tuck/)，将应用程序隐藏到窗口边缘\n\n1. [SizeUp](http://www.irradiatedsoftware.com/sizeup/)，管理应用程序窗口的位置和大小\n\n## host configuration\n\n最近在熟悉云主机的使用，下面是配置过程：\n\n1. ssh root 账号登录云主机，通过 `passwd` 命令更改主机密码，至于怎样设置结构复杂的密码，建议参考文章[《每一个程序员都有一颗当诗人的心》](http://www.hello-code.com/diary/201409/2223.html)。\n\n1. 使用 root 账号创建普通用户：`adduser sean`、`passwd sean`，然后为新用户配置权限，通过 `visudo` 命令添加 `sean ALL=(ALL) ALL` 配置信息，完成后退出 root 账户，使用普通账户登录云主机，比如这里的 sean。\n\n1. 安装常用工具：\n    - [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\n    - [amix/vimrc](https://github.com/amix/vimrc)\n    - [bling/vim-airline](https://github.com/bling/vim-airline)\n    - [powerline/fonts](https://github.com/powerline/fonts)\n    - [nvm](https://github.com/creationix/nvm)\n    - [node](https://github.com/nodejs/node)\n    - [node:tldr](https://github.com/tldr-pages/tldr)\n    - [apt-get:tree](https://packages.debian.org/search?keywords=tree)\n\n## tldr\n\n不断地在中英文间进行切换也是非常低效率的操作，所以，初步设定在 2016 年底脱离非业务开发下对中文输入的依赖——不过我最喜欢的哲学思维还是先秦百家交叉融汇出的框架。","slug":"mac-tool-kit","published":1,"updated":"2016-01-03T08:58:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q61710004l9didhrt58v9"},{"title":"inline* and absolute","date":"2015-12-06T03:32:17.000Z","_content":"\n在一个容器中，所有元素都是 inline / inline-block 类型，此时可以使用 absolute + margin 的方式实现相对定位，而且相对定位的位置就是脱离文档流之前的位置。\n\n![absolute and margin](/img/inline-and-absolute.png)\n\n<!-- more -->\n\n###### 在线示例\n\n- [absolute and marign](http://codepen.io/pinggod/pen/WrNJmE)","source":"_posts/inline-and-absolute.md","raw":"title: 'inline* and absolute'\ndate: 2015-12-06 11:32:17\n---\n\n在一个容器中，所有元素都是 inline / inline-block 类型，此时可以使用 absolute + margin 的方式实现相对定位，而且相对定位的位置就是脱离文档流之前的位置。\n\n![absolute and margin](/img/inline-and-absolute.png)\n\n<!-- more -->\n\n###### 在线示例\n\n- [absolute and marign](http://codepen.io/pinggod/pen/WrNJmE)","slug":"inline-and-absolute","published":1,"updated":"2015-12-27T09:31:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q61730005l9digkxzov3y"},{"title":"Sass","date":"2015-11-19T09:19:52.000Z","_content":"\n从 [Ben Frain](http://benfrain.com/) 的书中可以看出，他是一个勇于实践、善于学习的开发者。一直以来都很关注他的动态，当他的新书《Sass 和 Compass 设计师指南》初版时，就迫不及待地入手了，这是我和 Sass 的第一次见面。后来机缘巧合翻译了 [Sass Guidelines](http://sass-guidelin.es/zh) 和其它一些颇具实践性的 Sass 文章，零零散散至今大概有了一年的时间。\n\n以前的翻译专注于“学习”，在这篇文章之后，我将会分配更多的精力到“实践”中，做一些共享性的库或工具回馈社区。\n\n<div class=\"tip\">\n    预处理器很强大，但它只是编写 CSS 的辅助工具。出于对扩展和维护等方面的考虑，在大型项目中有必要使用预处理器构建 CSS；但是对于小型项目，原生的 CSS 可能是一种更好的选择。不要肆意使用预处理器！\n</div>\n\n<!-- more -->\n\n## Quick Start\n\nSass 扩展了 CSS 的现有语法，并提供了一些新的语法糖。在下面的简短代码中，集合了 Sass 中最常用的模块引用 `@import`、变量和嵌套：\n\n```scss\n// 设置字符集\n@charset \"UTF-8\";\n\n// 引入模块\n@import \"reset\";\n\n// 创建变量\n$primary-color: #333;\n\n// 嵌套\nbody {\n    color: $primary-color;\n    ul {\n        list-style-type: none;\n    }\n}\n```\n\n## 插值字符串\n\nSass 中的插值字符串 `#{$var}` 有两方面的作用：动态拼接字符串和去除字符串首尾的引号。示例如下：\n\n```scss\n@mixin header($tag) {\n    #{$tag}:before {\n        content: \"#{$tag}\";\n        // 等同于 content: $tag;\n    }\n}\n\n.post-content {\n    @include header(\"h1\");\n}\n```\n\n编译结果：\n\n```css\n.post-content h1:before {\n    content: \"h1\";\n}\n```\n\n## 父级引用符：`&`\n\n可以将父级引用符 `&` 看做是一个值为父级选择器的插值语法：\n\n```scss\na {\n    text-decoration: none;\n    &:hover {\n        text-decoration: underline;\n    }\n}\n```\n\n编译结果：\n\n```css\na {\n    text-decoration: none;\n}\n\na:hover {\n    text-decoration: underline;\n}\n```\n\n## 占位符选择器\n\n占位符选择器是 Sass 特有的一种选择器，声明时以 `%` 开头，编译时不会输出到 CSS 文件中，主要用于抽象组件的公共部分，配合 `@extend` 指令实现样式的继承机制：\n\n```scss\n%font {\n    font-size: 14px;\n    font-family: \"Source Sans Pro\";\n}\n\nbody {\n    @extend %font;\n}\n```\n\n编译结果：\n\n```css\nbody {\n    font-size: 14px;\n    font-family: \"Source Sans Pro\";\n}\n```\n\n## 数据类型\n\n- 字符串 (string): \"foo\", foo\n- 数值 (number): 1.3, 13, 10px\n- 列表 (list): ( 1.5em 1em 0 2em, Helvetica, Arial, sa ns-serif )\n- 映射 (map): ( key1: value1, key2: value2 )\n- 颜色值 (color): blue, #FFFFFF, rgb, hsl, rgba, hsla\n- 布尔值 (bool): true, false\n- 空类型 (null): null\n\n## 操作符\n\n- 赋值 `:`\n- 计算 `+`、`-`、`*`、`/`、`%`\n- 比较 `==`、`!=`、`>`、`>=`、`<`、`<=`\n- 逻辑 `and`、`or`、`not`\n\n其中，`+` 除了用作算术运算之外，也可以用于拼接字符串和求取颜色值。在 Sass 中字符串分为两种：引用字符串（quoted string，外部被引号包裹）和未引用字符串（unquoted string，外部没有引号）。使用 `+` 拼接字符串时，最终生成的字符串类型为第一个运算子的字符串类型：\n\n```scss\nbody {\n    font-family: \"Source Sans \" + TC;\n    p {\n        font-family: sans- + \"serif\";\n    }\n}\n```\n\n编译结果：\n\n```css\nbody {\n  font-family: \"Source Sans TC\";\n}\n\nbody p {\n  font-family: sans-serif;\n}\n```\n\n使用 `+` 求取颜色值时，必须保证运算子具有相同的不透明度：\n\n```scss\nbody {\n    color: rgba(70, 132, 153, 1) + rgba(32, 68, 121, 1);\n    // => color: #66c8ff;\n\n    background-color: rgba(70, 132, 153, .9) + rgba(32, 68, 121, .7);\n    // alpha channels must be equal when combining colors \n    // 报错：不透明通道值必须相等\n}\n```\n\n<div class=\"tip\">\n    `/` 在 CSS 中是有意义的，为了避免和 Sass 除法运算的混淆，所有的除法操作都应该使用小括号 `()` 包裹，比如使用 `font-size: (10px / 2)` 产出 `font-size: 5px`。\n</div>\n\n## 变量标识符\n\nSass 中的变量有三种身份：普通变量、默认值变量（`!default`）和全局变量（`!global`），而且这些变量具有作用域的概念，每个代码块 `{}` 内一个作用域，整个代码文件内也有一个作用域。\n\n当我们引用普通变量时，Sass 首先会从当前作用域开始检索变量，如果找不到就上溯到父级作用域，直到递归到最顶层的作用域：\n\n```scss\n$color: orange;\n\ndiv {\n    // 对 $color 重新赋值\n    $color: blue;\n    color: $color;\n    p {\n        color: $color;\n    }\n}\n\na {\n    color: $color;\n}\n```\n\n编译结果：\n\n```css\ndiv {\n  color: blue;\n}\n\ndiv p {\n  color: blue;\n}\n\na {\n  color: orange;\n}\n```\n\n> 默认值变量往往用于主题的配置文件，起到标识默认值，方便后续的重写覆盖。在最顶层作用域下，变量默认具有全局性，此时使用 `!global` 并没有实际意义；在块级作用域中，可以通过 `!global` 将变量提升为全局变量，但这么做势必降低代码的可维护性，所以目前全局变量显得有些鸡肋。\n\n## `@` 指令\n\n- @import 模块引用\n- @media 媒体查询\n- @extend 选择器继承\n- @at-root 嵌套提取\n- @debug / @warn / @error 异常和测试\n\n`@extend` 的强大无可置疑，但是复杂性也一直为人诟病，稍微控制不当就会生成冗余的选择器。归根结底，使用 `@extend` 是为了继承组件的公有样式，所以在不影响功能的基础上，应该适当的束缚它的能力。到目前为止，最优秀的实践方式就是 `@extend` 搭配占位符选择器。\n\n```scss\n%btn {\n    color: white;\n    font-size: 20px;\n}\n\n.btn-danger {\n    @extend %btn;\n    background-color: red;\n}\n\n.btn-default {\n    @extend %btn;\n    background-color: gray;\n}\n```\n\n编译结果：\n\n```css\n.btn-danger, .btn-default {\n    color: white;\n    font-size: 20px;\n}\n\n.btn-danger {\n    background-color: red;\n}\n\n.btn-default {\n    background-color: gray;\n}\n```\n\n在这个组合中，占位符选择器本身不会被编译到 CSS 文件中，可以节省文件体积，而且 `@extend` 只继承了单一的占位符选择器，杜绝了选择器泛滥。此外，相比起 `@mixin` 来，`@extend` 搭配占位符选择器生成的结果会聚合在同一个样式集中：\n\n![@extend vs @mixin](/img/mixin-vs-extend.png)\n\n> 如果再上升一个层次分工的话，那就需要比较一下 `@mixin` 和 `@extend`。这两种方式都可以生成公有样式，但是仅此而已就是浪费了 `@mixin` 的能力。就目前的最佳实践来说，建议使用 `@extend` 搭配占位符选择器继承公有样式，使用 `@mixin` 产出动态样式。`@mixin` 的详细介绍见后续小节。\n\n\n## 控制指令\n\n- @if ... @else if ... @else ... 条件判断\n- @for $var from start through end [start, end] 循环\n- @for $var from start to end [start, end) 循环\n- @each ... in ... 遍历\n- @while\n\n`@each` 可以用来遍历 list 和 map 类型的数据，示例如下：\n\n```scss\n$btn: (\n    danger: red, \n    primary: blue, \n    warning: orange\n);\n\n@each $type, $color in $btn {\n    .btn-#{$type} {\n        color: $color;\n    }\n}\n```\n\n编译结果：\n\n```css\n.btn-danger {\n    color: red;\n}\n\n.btn-primary {\n    color: blue;\n}\n\n.btn-warning {\n    color: orange;\n}\n```\n\n## 混合宏 `@mixin`\n\n在 `@extend` 部分已经介绍到 `@mixin` 的一个功能是生成公有样式，但事实上，建议你避开使用该功能，而是着眼于使用 `@mixin` 动态生成共有样式，更优雅地实现组件复用：\n\n```scss\n@mixin btn($fontSize, $borderRadius) {\n    font-size: $fontSize;\n    border-radius: $borderRadius;\n}\n\n.btn-sm {\n    @include btn(14px, 3px);\n}\n\n.btn-lg {\n    @include btn(18px, 5px);\n}\n```\n\n编译结果：\n\n```css\n.btn-sm {\n    font-size: 14px;\n    border-radius: 3px;\n}\n\n.btn-lg {\n    font-size: 18px;\n    border-radius: 5px;\n}\n```\n\n`@mixin` 的参数除了上面示例的普通参数，还包括默认值参数和不定参数。默认值参数通过提供默认样式，可以在参数缺失时，保障代码的健壮性：\n\n```scss\n@mixin btn($fontSize, $borderRadius: 5px) {\n    font-size: $fontSize;\n    border-radius: $borderRadius;\n}\n\n.btn-lg {\n    @include btn(18px);\n}\n```\n\n编译结果：\n\n```css\n.btn-lg {\n    font-size: 18px;\n    border-radius: 5px;\n}\n```\n\n不定参数可以保存零个或多个值，最常用的地方就是为同一属性添加多个值，比如多重阴影：\n\n```scss\n@mixin box-shadow($shadows...) {\n    -moz-box-shadow: $shadows;\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n}\n\n.shadows {\n    @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n编译结果：\n\n```css\n.shadows {\n    -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n    -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n    box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n}\n```\n\n此外，在传参时也可以使用不定参数：\n\n```scss\n@mixin colors($text, $background, $border) {\n    color: $text;\n    background-color: $background;\n    border-color: $border;\n}\n\n$values: #ff0000, #00ff00, #0000ff;\n.primary {\n    @include colors($values...);\n}\n\n$value-map: (text: #00ff00, background: #0000ff, border: #ff0000);\n.secondary {\n    @include colors($value-map...);\n}\n```\n\n编译结果：\n\n```css\n.primary {\n    color: #ff0000;\n    background-color: #00ff00;\n    border-color: #0000ff;\n}\n\n.secondary {\n    color: #00ff00;\n    background-color: #0000ff;\n    border-color: #ff0000;\n}\n```\n\n<div class=\"tip\">\n    在 `@mixin` 中配置参数时，先写普通参数，然后是默认值参数，最后是不定参数。\n</div>\n\n## 函数指令 `@function`\n\n相比起上面的继承和动态生成，`@function` 在生成方式上自由度更高。此外，还可以嵌套上面的各种指令和操作符，对数据进行筛选、在加工，生成特定样式。在下面的代码中，混合宏根据栅格的数量，动态生成容器的宽度：\n\n```scss\n$grid-width: 40px;\n$gutter-width: 10px;\n\n@function width($n) {\n    @return $n * $grid-width + ($n - 1) * $gutter-width;\n}\n\n.container { \n    width: width(5); \n}\n```\n\n编译结果：\n\n```css\n.container {\n    width: 240px;\n}\n```\n\n###### 参考资料\n\n- [Sass 内建函数](http://sass-lang.com/documentation/Sass/Script/Functions.html#blue-instance_method)","source":"_posts/Sass.md","raw":"title: Sass\ndate: 2015-11-19 17:19:52\ntags:\n---\n\n从 [Ben Frain](http://benfrain.com/) 的书中可以看出，他是一个勇于实践、善于学习的开发者。一直以来都很关注他的动态，当他的新书《Sass 和 Compass 设计师指南》初版时，就迫不及待地入手了，这是我和 Sass 的第一次见面。后来机缘巧合翻译了 [Sass Guidelines](http://sass-guidelin.es/zh) 和其它一些颇具实践性的 Sass 文章，零零散散至今大概有了一年的时间。\n\n以前的翻译专注于“学习”，在这篇文章之后，我将会分配更多的精力到“实践”中，做一些共享性的库或工具回馈社区。\n\n<div class=\"tip\">\n    预处理器很强大，但它只是编写 CSS 的辅助工具。出于对扩展和维护等方面的考虑，在大型项目中有必要使用预处理器构建 CSS；但是对于小型项目，原生的 CSS 可能是一种更好的选择。不要肆意使用预处理器！\n</div>\n\n<!-- more -->\n\n## Quick Start\n\nSass 扩展了 CSS 的现有语法，并提供了一些新的语法糖。在下面的简短代码中，集合了 Sass 中最常用的模块引用 `@import`、变量和嵌套：\n\n```scss\n// 设置字符集\n@charset \"UTF-8\";\n\n// 引入模块\n@import \"reset\";\n\n// 创建变量\n$primary-color: #333;\n\n// 嵌套\nbody {\n    color: $primary-color;\n    ul {\n        list-style-type: none;\n    }\n}\n```\n\n## 插值字符串\n\nSass 中的插值字符串 `#{$var}` 有两方面的作用：动态拼接字符串和去除字符串首尾的引号。示例如下：\n\n```scss\n@mixin header($tag) {\n    #{$tag}:before {\n        content: \"#{$tag}\";\n        // 等同于 content: $tag;\n    }\n}\n\n.post-content {\n    @include header(\"h1\");\n}\n```\n\n编译结果：\n\n```css\n.post-content h1:before {\n    content: \"h1\";\n}\n```\n\n## 父级引用符：`&`\n\n可以将父级引用符 `&` 看做是一个值为父级选择器的插值语法：\n\n```scss\na {\n    text-decoration: none;\n    &:hover {\n        text-decoration: underline;\n    }\n}\n```\n\n编译结果：\n\n```css\na {\n    text-decoration: none;\n}\n\na:hover {\n    text-decoration: underline;\n}\n```\n\n## 占位符选择器\n\n占位符选择器是 Sass 特有的一种选择器，声明时以 `%` 开头，编译时不会输出到 CSS 文件中，主要用于抽象组件的公共部分，配合 `@extend` 指令实现样式的继承机制：\n\n```scss\n%font {\n    font-size: 14px;\n    font-family: \"Source Sans Pro\";\n}\n\nbody {\n    @extend %font;\n}\n```\n\n编译结果：\n\n```css\nbody {\n    font-size: 14px;\n    font-family: \"Source Sans Pro\";\n}\n```\n\n## 数据类型\n\n- 字符串 (string): \"foo\", foo\n- 数值 (number): 1.3, 13, 10px\n- 列表 (list): ( 1.5em 1em 0 2em, Helvetica, Arial, sa ns-serif )\n- 映射 (map): ( key1: value1, key2: value2 )\n- 颜色值 (color): blue, #FFFFFF, rgb, hsl, rgba, hsla\n- 布尔值 (bool): true, false\n- 空类型 (null): null\n\n## 操作符\n\n- 赋值 `:`\n- 计算 `+`、`-`、`*`、`/`、`%`\n- 比较 `==`、`!=`、`>`、`>=`、`<`、`<=`\n- 逻辑 `and`、`or`、`not`\n\n其中，`+` 除了用作算术运算之外，也可以用于拼接字符串和求取颜色值。在 Sass 中字符串分为两种：引用字符串（quoted string，外部被引号包裹）和未引用字符串（unquoted string，外部没有引号）。使用 `+` 拼接字符串时，最终生成的字符串类型为第一个运算子的字符串类型：\n\n```scss\nbody {\n    font-family: \"Source Sans \" + TC;\n    p {\n        font-family: sans- + \"serif\";\n    }\n}\n```\n\n编译结果：\n\n```css\nbody {\n  font-family: \"Source Sans TC\";\n}\n\nbody p {\n  font-family: sans-serif;\n}\n```\n\n使用 `+` 求取颜色值时，必须保证运算子具有相同的不透明度：\n\n```scss\nbody {\n    color: rgba(70, 132, 153, 1) + rgba(32, 68, 121, 1);\n    // => color: #66c8ff;\n\n    background-color: rgba(70, 132, 153, .9) + rgba(32, 68, 121, .7);\n    // alpha channels must be equal when combining colors \n    // 报错：不透明通道值必须相等\n}\n```\n\n<div class=\"tip\">\n    `/` 在 CSS 中是有意义的，为了避免和 Sass 除法运算的混淆，所有的除法操作都应该使用小括号 `()` 包裹，比如使用 `font-size: (10px / 2)` 产出 `font-size: 5px`。\n</div>\n\n## 变量标识符\n\nSass 中的变量有三种身份：普通变量、默认值变量（`!default`）和全局变量（`!global`），而且这些变量具有作用域的概念，每个代码块 `{}` 内一个作用域，整个代码文件内也有一个作用域。\n\n当我们引用普通变量时，Sass 首先会从当前作用域开始检索变量，如果找不到就上溯到父级作用域，直到递归到最顶层的作用域：\n\n```scss\n$color: orange;\n\ndiv {\n    // 对 $color 重新赋值\n    $color: blue;\n    color: $color;\n    p {\n        color: $color;\n    }\n}\n\na {\n    color: $color;\n}\n```\n\n编译结果：\n\n```css\ndiv {\n  color: blue;\n}\n\ndiv p {\n  color: blue;\n}\n\na {\n  color: orange;\n}\n```\n\n> 默认值变量往往用于主题的配置文件，起到标识默认值，方便后续的重写覆盖。在最顶层作用域下，变量默认具有全局性，此时使用 `!global` 并没有实际意义；在块级作用域中，可以通过 `!global` 将变量提升为全局变量，但这么做势必降低代码的可维护性，所以目前全局变量显得有些鸡肋。\n\n## `@` 指令\n\n- @import 模块引用\n- @media 媒体查询\n- @extend 选择器继承\n- @at-root 嵌套提取\n- @debug / @warn / @error 异常和测试\n\n`@extend` 的强大无可置疑，但是复杂性也一直为人诟病，稍微控制不当就会生成冗余的选择器。归根结底，使用 `@extend` 是为了继承组件的公有样式，所以在不影响功能的基础上，应该适当的束缚它的能力。到目前为止，最优秀的实践方式就是 `@extend` 搭配占位符选择器。\n\n```scss\n%btn {\n    color: white;\n    font-size: 20px;\n}\n\n.btn-danger {\n    @extend %btn;\n    background-color: red;\n}\n\n.btn-default {\n    @extend %btn;\n    background-color: gray;\n}\n```\n\n编译结果：\n\n```css\n.btn-danger, .btn-default {\n    color: white;\n    font-size: 20px;\n}\n\n.btn-danger {\n    background-color: red;\n}\n\n.btn-default {\n    background-color: gray;\n}\n```\n\n在这个组合中，占位符选择器本身不会被编译到 CSS 文件中，可以节省文件体积，而且 `@extend` 只继承了单一的占位符选择器，杜绝了选择器泛滥。此外，相比起 `@mixin` 来，`@extend` 搭配占位符选择器生成的结果会聚合在同一个样式集中：\n\n![@extend vs @mixin](/img/mixin-vs-extend.png)\n\n> 如果再上升一个层次分工的话，那就需要比较一下 `@mixin` 和 `@extend`。这两种方式都可以生成公有样式，但是仅此而已就是浪费了 `@mixin` 的能力。就目前的最佳实践来说，建议使用 `@extend` 搭配占位符选择器继承公有样式，使用 `@mixin` 产出动态样式。`@mixin` 的详细介绍见后续小节。\n\n\n## 控制指令\n\n- @if ... @else if ... @else ... 条件判断\n- @for $var from start through end [start, end] 循环\n- @for $var from start to end [start, end) 循环\n- @each ... in ... 遍历\n- @while\n\n`@each` 可以用来遍历 list 和 map 类型的数据，示例如下：\n\n```scss\n$btn: (\n    danger: red, \n    primary: blue, \n    warning: orange\n);\n\n@each $type, $color in $btn {\n    .btn-#{$type} {\n        color: $color;\n    }\n}\n```\n\n编译结果：\n\n```css\n.btn-danger {\n    color: red;\n}\n\n.btn-primary {\n    color: blue;\n}\n\n.btn-warning {\n    color: orange;\n}\n```\n\n## 混合宏 `@mixin`\n\n在 `@extend` 部分已经介绍到 `@mixin` 的一个功能是生成公有样式，但事实上，建议你避开使用该功能，而是着眼于使用 `@mixin` 动态生成共有样式，更优雅地实现组件复用：\n\n```scss\n@mixin btn($fontSize, $borderRadius) {\n    font-size: $fontSize;\n    border-radius: $borderRadius;\n}\n\n.btn-sm {\n    @include btn(14px, 3px);\n}\n\n.btn-lg {\n    @include btn(18px, 5px);\n}\n```\n\n编译结果：\n\n```css\n.btn-sm {\n    font-size: 14px;\n    border-radius: 3px;\n}\n\n.btn-lg {\n    font-size: 18px;\n    border-radius: 5px;\n}\n```\n\n`@mixin` 的参数除了上面示例的普通参数，还包括默认值参数和不定参数。默认值参数通过提供默认样式，可以在参数缺失时，保障代码的健壮性：\n\n```scss\n@mixin btn($fontSize, $borderRadius: 5px) {\n    font-size: $fontSize;\n    border-radius: $borderRadius;\n}\n\n.btn-lg {\n    @include btn(18px);\n}\n```\n\n编译结果：\n\n```css\n.btn-lg {\n    font-size: 18px;\n    border-radius: 5px;\n}\n```\n\n不定参数可以保存零个或多个值，最常用的地方就是为同一属性添加多个值，比如多重阴影：\n\n```scss\n@mixin box-shadow($shadows...) {\n    -moz-box-shadow: $shadows;\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n}\n\n.shadows {\n    @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n编译结果：\n\n```css\n.shadows {\n    -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n    -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n    box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n}\n```\n\n此外，在传参时也可以使用不定参数：\n\n```scss\n@mixin colors($text, $background, $border) {\n    color: $text;\n    background-color: $background;\n    border-color: $border;\n}\n\n$values: #ff0000, #00ff00, #0000ff;\n.primary {\n    @include colors($values...);\n}\n\n$value-map: (text: #00ff00, background: #0000ff, border: #ff0000);\n.secondary {\n    @include colors($value-map...);\n}\n```\n\n编译结果：\n\n```css\n.primary {\n    color: #ff0000;\n    background-color: #00ff00;\n    border-color: #0000ff;\n}\n\n.secondary {\n    color: #00ff00;\n    background-color: #0000ff;\n    border-color: #ff0000;\n}\n```\n\n<div class=\"tip\">\n    在 `@mixin` 中配置参数时，先写普通参数，然后是默认值参数，最后是不定参数。\n</div>\n\n## 函数指令 `@function`\n\n相比起上面的继承和动态生成，`@function` 在生成方式上自由度更高。此外，还可以嵌套上面的各种指令和操作符，对数据进行筛选、在加工，生成特定样式。在下面的代码中，混合宏根据栅格的数量，动态生成容器的宽度：\n\n```scss\n$grid-width: 40px;\n$gutter-width: 10px;\n\n@function width($n) {\n    @return $n * $grid-width + ($n - 1) * $gutter-width;\n}\n\n.container { \n    width: width(5); \n}\n```\n\n编译结果：\n\n```css\n.container {\n    width: 240px;\n}\n```\n\n###### 参考资料\n\n- [Sass 内建函数](http://sass-lang.com/documentation/Sass/Script/Functions.html#blue-instance_method)","slug":"Sass","published":1,"updated":"2015-12-27T09:29:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q617a0007l9diw1i3j5x3"},{"title":"React 组件间的消息传递","date":"2015-11-28T10:34:42.000Z","_content":"\n当我们封装了可复用的组件之后，用来驱动组件渲染内容的数据就变得愈发灵活，组件之间数据通信的问题就摆在了桌面上。React 组件间的消息传递主要集中于三种关系中：\n\n- 从父组件向子组件的消息传递\n- 从子组件向父组件的消息传递\n- 无关联组件之间的消息传递\n\n前两种关系都可以使用 React 内建的 `this.props` 对象来处理：\n\n![父子组件之间的消息传递](/img/react-component-comunication.png)\n\n<!-- more -->\n\n## 无关联组件之间的消息传递\n\n这里的“无关联”，是指两个组件既不是父子关系，也不是兄弟关系。对于这种关系，可以用一个简单的发布订阅模型来实现，这种模型又被称为观察者模式。\n\n这里选用的是基于全局对象的发布订阅模型，需要自定义事件名称：\n\n```js\n// 事件集合\nlet events = {};\n\n// 发布事件\nconst trigger = (event, ...data) => {\n    const fns = events[event];\n\n    // 如果没有对应方法\n    if (!fns || fns.length === 0) {\n        return false;\n    }\n    // 如果存在对应方法，依次执行\n    for ( let i = 0; i <= fns.length - 1; i++) {\n        fns[i](...data);\n    }\n};\n\n// 监听事件\nconst on = (event, fn) => {\n    // 如果尚没有该事件，创建一个数组来存储对应的方法\n    if (!events[event]) {\n        events[event] = [];\n    }\n    events[event].push(fn);\n};\n\n// 取消监听事件\nconst off = (event, fn) => {\n    const fns = events[event];\n\n    // 如果不存在事件集合\n    if (!fns) {\n        return false;\n    }\n    // 如果不存在事件\n    if (!fn && fns) {\n        fns.length = 0;\n    }\n    // 取消指定事件\n    else {\n        for (let i = fns.length - 1; i >= 0; i--) {\n            if (fn === fns[i]) {\n                fns.splice(i, 1);\n            }\n        }\n    }\n};\n\nconst PubSub = {\n    on: on,\n    off: off,\n    trigger: trigger\n};\n\nexport default PubSub;\n```","source":"_posts/React-组件间的消息传递.md","raw":"title: React 组件间的消息传递\ndate: 2015-11-28 18:34:42\n---\n\n当我们封装了可复用的组件之后，用来驱动组件渲染内容的数据就变得愈发灵活，组件之间数据通信的问题就摆在了桌面上。React 组件间的消息传递主要集中于三种关系中：\n\n- 从父组件向子组件的消息传递\n- 从子组件向父组件的消息传递\n- 无关联组件之间的消息传递\n\n前两种关系都可以使用 React 内建的 `this.props` 对象来处理：\n\n![父子组件之间的消息传递](/img/react-component-comunication.png)\n\n<!-- more -->\n\n## 无关联组件之间的消息传递\n\n这里的“无关联”，是指两个组件既不是父子关系，也不是兄弟关系。对于这种关系，可以用一个简单的发布订阅模型来实现，这种模型又被称为观察者模式。\n\n这里选用的是基于全局对象的发布订阅模型，需要自定义事件名称：\n\n```js\n// 事件集合\nlet events = {};\n\n// 发布事件\nconst trigger = (event, ...data) => {\n    const fns = events[event];\n\n    // 如果没有对应方法\n    if (!fns || fns.length === 0) {\n        return false;\n    }\n    // 如果存在对应方法，依次执行\n    for ( let i = 0; i <= fns.length - 1; i++) {\n        fns[i](...data);\n    }\n};\n\n// 监听事件\nconst on = (event, fn) => {\n    // 如果尚没有该事件，创建一个数组来存储对应的方法\n    if (!events[event]) {\n        events[event] = [];\n    }\n    events[event].push(fn);\n};\n\n// 取消监听事件\nconst off = (event, fn) => {\n    const fns = events[event];\n\n    // 如果不存在事件集合\n    if (!fns) {\n        return false;\n    }\n    // 如果不存在事件\n    if (!fn && fns) {\n        fns.length = 0;\n    }\n    // 取消指定事件\n    else {\n        for (let i = fns.length - 1; i >= 0; i--) {\n            if (fn === fns[i]) {\n                fns.splice(i, 1);\n            }\n        }\n    }\n};\n\nconst PubSub = {\n    on: on,\n    off: off,\n    trigger: trigger\n};\n\nexport default PubSub;\n```","slug":"React-组件间的消息传递","published":1,"updated":"2015-12-27T09:32:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q617b0008l9di7rf89cwa"},{"title":"React 组件的生命周期","date":"2015-11-23T01:56:00.000Z","_content":"\n在 React 所实践的组件化中，非常重要的一点就是组件的生命周期，简而言之是组件的挂载、更新和卸载流程。下图详细列述了 React 组件在整个生命周期中所涉及的方法和行为：\n\n![React 组件的生命周期](/img/react-lifecycle.png)\n\n<!-- more -->\n\n在组件实例创建之初，会依序调用 `getDefaultProps()`、`getInitialState()` 方法初始化数据。在 ES6 中，可以简写为：\n\n```js\nstatic defaultProps = {\n    key: value\n};\n\nstate = {\n    key: value\n};\n```\n\n对于从父组件传递来的 props，React 提供了 `propTypes` 配置对象来校验数据类型或格式，常用类型如下：\n\n```js\n// 布尔值\nReact.PropTypes.bool                              \n// 数值\nReact.PropTypes.number                            \n// 字符串\nReact.PropTypes.string                            \n// 函数\nReact.PropTypes.func                              \n// 数组\nReact.PropTypes.array                             \n// 对象\nReact.PropTypes.object                            \n// 数值、字符串、DOM 元素及包含这些类型的数组\nReact.PropTypes.node                              \n// React 元素\nReact.PropTypes.element                           \n// 对象实例\nReact.PropTypes.instanceOf(Message)               \n// 数组包含的值之一\nReact.PropTypes.oneOf(['News' 'Photos'])          \n// 数组包含的类型之一\nReact.PropTypes.oneOfType([                       \n    React.PropTypes.string,         \n    React.PropTypes.number,         \n    React.PropTypes.instanceOf(Message)                                  \n])                                               \n// 数值数组\nReact.PropTypes.arrayOf(React.PropTypes.number)   \n// 对象的属性值为数值类型\nReact.PropTypes.objectOf(React.PropTypes.number)  \n// 组合类型\nReact.PropTypes.shape({                           \n    React.PropTypes.string                                   \n    React.PropTypes.number                                   \n})                                                 \n// 任何类型，必填\nReact.PropTypes.any.isRequired                    \n// 自定义规则\ncustomProp: function(props propName componentName) {\n    if (!/matchme/.test(props[propName])) {\n        return new Error('Validation failed!');\n    }\n}\n```\n\n## mount\n\n在组件的挂载过程中，会依次调用 componentWillMount()、render() 和 componentDidMount()。挂载完成后，`componentWillMount()` 和 `componentDidMount()` 将不会再被触发，`render()` 则会根据 props 和 state 的变化多次执行。\n\n在 componentDidMount() 调用之前，只能得到由 render() 返回的虚拟 DOM；在该方法执行时，真实 DOM 的渲染已经完成，此时，可以通过 React 内建的 `getDOMNode()` 访问真实的 DOM。\n\n## update\n\n挂载结束后，组件处于监听状态，监听 props 和 state 的变化。props 和 state 的差异在于：state 用于配置组件内的状态，props 则用于在组件间传递数据。\n\n在实际开发中，这一阶段调用的核心都是围绕 state 展开的。state changed 之后，系统会立即调用 `boolean shouldComponentUpdate(object nextProps, object nextState)` 方法来决定是否重新渲染页面。当遭遇性能瓶颈时，适当地通过该方法控制页面渲染的频率是为提升性能不二法门。\n\n当 props changed 时，系统会立即调用 `componentWillReciveProps(object nextProps)` 方法。该方法常被用来执行 props -> state 的更新，继而触发整个页面的渲染。\n\n在这一阶段重新渲染页面所需要的同样是 will -> render -> did 三个方法。不同之处在于，此处的 did 和 will 附加了 props 和 state 信息：\n\n```js\ncomponentWillUpdate(object nextProps, object nextState) {\n    ...\n}\n\ncomponentDidUpdate(object prevProps, object prevState) {\n    ...\n}\n```\n\n## unmount\n\n组件卸载前会执行 `componentWillUnmount()`，用于清理 `componentDidMount()` 之后创建的组件。此外，对于组件生命周期内累积的监听事件和定时器，也应当在该方法内执行解绑、清除操作。\n\n## 组件化\n\n目前组内正在构建一套 React 基础组件，方法和思路与 AlloyTeam [《致我们终将组件化的 Web》](http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/)一文类似。其中，作者对组件提出了五点要求，如下图所示，值得参考：\n\n![组件化的要求](/img/react-component.png)\n\n其中“规范化的接口”，也可更改为可管理的生命周期。","source":"_posts/React-组件的生命周期.md","raw":"title: React 组件的生命周期\ndate: 2015-11-23 09:56:00\n---\n\n在 React 所实践的组件化中，非常重要的一点就是组件的生命周期，简而言之是组件的挂载、更新和卸载流程。下图详细列述了 React 组件在整个生命周期中所涉及的方法和行为：\n\n![React 组件的生命周期](/img/react-lifecycle.png)\n\n<!-- more -->\n\n在组件实例创建之初，会依序调用 `getDefaultProps()`、`getInitialState()` 方法初始化数据。在 ES6 中，可以简写为：\n\n```js\nstatic defaultProps = {\n    key: value\n};\n\nstate = {\n    key: value\n};\n```\n\n对于从父组件传递来的 props，React 提供了 `propTypes` 配置对象来校验数据类型或格式，常用类型如下：\n\n```js\n// 布尔值\nReact.PropTypes.bool                              \n// 数值\nReact.PropTypes.number                            \n// 字符串\nReact.PropTypes.string                            \n// 函数\nReact.PropTypes.func                              \n// 数组\nReact.PropTypes.array                             \n// 对象\nReact.PropTypes.object                            \n// 数值、字符串、DOM 元素及包含这些类型的数组\nReact.PropTypes.node                              \n// React 元素\nReact.PropTypes.element                           \n// 对象实例\nReact.PropTypes.instanceOf(Message)               \n// 数组包含的值之一\nReact.PropTypes.oneOf(['News' 'Photos'])          \n// 数组包含的类型之一\nReact.PropTypes.oneOfType([                       \n    React.PropTypes.string,         \n    React.PropTypes.number,         \n    React.PropTypes.instanceOf(Message)                                  \n])                                               \n// 数值数组\nReact.PropTypes.arrayOf(React.PropTypes.number)   \n// 对象的属性值为数值类型\nReact.PropTypes.objectOf(React.PropTypes.number)  \n// 组合类型\nReact.PropTypes.shape({                           \n    React.PropTypes.string                                   \n    React.PropTypes.number                                   \n})                                                 \n// 任何类型，必填\nReact.PropTypes.any.isRequired                    \n// 自定义规则\ncustomProp: function(props propName componentName) {\n    if (!/matchme/.test(props[propName])) {\n        return new Error('Validation failed!');\n    }\n}\n```\n\n## mount\n\n在组件的挂载过程中，会依次调用 componentWillMount()、render() 和 componentDidMount()。挂载完成后，`componentWillMount()` 和 `componentDidMount()` 将不会再被触发，`render()` 则会根据 props 和 state 的变化多次执行。\n\n在 componentDidMount() 调用之前，只能得到由 render() 返回的虚拟 DOM；在该方法执行时，真实 DOM 的渲染已经完成，此时，可以通过 React 内建的 `getDOMNode()` 访问真实的 DOM。\n\n## update\n\n挂载结束后，组件处于监听状态，监听 props 和 state 的变化。props 和 state 的差异在于：state 用于配置组件内的状态，props 则用于在组件间传递数据。\n\n在实际开发中，这一阶段调用的核心都是围绕 state 展开的。state changed 之后，系统会立即调用 `boolean shouldComponentUpdate(object nextProps, object nextState)` 方法来决定是否重新渲染页面。当遭遇性能瓶颈时，适当地通过该方法控制页面渲染的频率是为提升性能不二法门。\n\n当 props changed 时，系统会立即调用 `componentWillReciveProps(object nextProps)` 方法。该方法常被用来执行 props -> state 的更新，继而触发整个页面的渲染。\n\n在这一阶段重新渲染页面所需要的同样是 will -> render -> did 三个方法。不同之处在于，此处的 did 和 will 附加了 props 和 state 信息：\n\n```js\ncomponentWillUpdate(object nextProps, object nextState) {\n    ...\n}\n\ncomponentDidUpdate(object prevProps, object prevState) {\n    ...\n}\n```\n\n## unmount\n\n组件卸载前会执行 `componentWillUnmount()`，用于清理 `componentDidMount()` 之后创建的组件。此外，对于组件生命周期内累积的监听事件和定时器，也应当在该方法内执行解绑、清除操作。\n\n## 组件化\n\n目前组内正在构建一套 React 基础组件，方法和思路与 AlloyTeam [《致我们终将组件化的 Web》](http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/)一文类似。其中，作者对组件提出了五点要求，如下图所示，值得参考：\n\n![组件化的要求](/img/react-component.png)\n\n其中“规范化的接口”，也可更改为可管理的生命周期。","slug":"React-组件的生命周期","published":1,"updated":"2015-12-27T09:30:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q617e0009l9dixno9p9om"},{"title":"Pug","date":"2015-12-03T05:24:27.000Z","_content":"\n<div class=\"tip\">\n    由于商标版权问题，Jade 已经改名为了 Pug，详见 [issue](https://github.com/pugjs/jade/issues/2184)。\n</div>\n\n如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Pug 也会是你的菜。Pug 类似于 Python，都采用了对缩进敏感的语法形式，比如下面这段代码创建了一个无序列表：\n\n```javascript\nul(class=\"inline\")\n    li  Item C\n    li  Item A\n    li  Item B\n```\n\n\n<!-- more -->\n\n\n## 属性\n\nPug 的另一大特点就是和 JavaScript 的融合度很高，比如设置属性：\n\n```javascript\n- var authenticated = true\nbody(class= authenticated ? 'authed' : 'anon')\n- var currentUrl = '/about'\na(class={active: currentUrl === '/'} href='/') Home\na(class={active: currentUrl === '/about'} href='/about') About\n```\n\n此外，给标签设置行内样式时，需要以对象的形式赋值给 style：\n\n```javascript\na(style={color: 'red', background: 'green'})\n```\n\n## 插值\n\nPug 提供了字符串插值和标签插值。其中，字符串插值由于要考虑到安全性问题，所以又分成了转义和不转义两种情况：\n\n```javascript\n// 转义插值 #{}\n- var theGreat = \"<span>escape!</span>\";\np This will be safe: #{theGreat}\n\n// 不转义插值 !{}\n- var theGreat = \"<span>escape!</span>\";\np This will be safe: !{theGreat}\n\n// 标签插值\np #[a(href=\"Pug-lang.com\") Pug]\n```\n\n编译结果：\n\n```html\n<!-- 转义插值 #{}-->\n<p>This will be safe: &lt;span&gt;escape!&lt;/span&gt;</p>\n\n<!-- 不转义插值 !{}-->\n<p>This will be safe: <span>escape!</span></p>\n\n<!-- 标签插值-->\n<p><a href=\"Pug-lang.com\">Pug</a></p>\n```\n\n## 逻辑语句\n\nPug 提供了条件、分支、循环、遍历四种逻辑语句，这四种语句继承自 JavaScript，只是语法上有些差异:\n\n- 条件语句：if ... else if ... else\n- 分支语句：case ... when ... default\n- 循环语句：while\n- 遍历数组：each $elem in [elem...]\n- 遍历对象：each $key, $value in {key: value}\n\n```javascript\n// 分支语句\n- var friends = 10\ncase friends\n    when 0\n        p you have no friends\n    when 1\n        p you have a friend\n    default\n        p you have #{friends} friends\n```\n\n## mixin\n\nPug 和 Sass 都提供了 mixin 语法来实现代码的复用，两者语法也很相似：\n\n```javascript\nmixin list(id, ...items)\n    ul(id=id)\n        each item in items\n            li= item\n\n+list('my-list', 1, 2, 3, 4)\n```\n\nmixin 一般放在独立的文件中，需要使用 `include` 指令导入到其他文件中。\n\n## extends\n\n`extends` 是 Pug 的模板继承语法，通过 `extends filename.Pug` 可以将模板文件导入到其他文件中。继承机制基本上是一个复制代码片段的过程，为了能够动态修改其中的部分内容，Pug 提供了 `block` 语法：\n\n```javascript\n// 声明 block\nblock content\n    p Hello\n\n// 修改 block\n// 同名重新赋值\nblock content\n    p Hi\n\n// 前置追加\nblock append content\n    p APPEND\n\n// 后置追加\nblock prepend content\n    p PREPEND\n```\n","source":"_posts/Pug.md","raw":"title: Pug\ndate: 2015-12-03 13:24:27\n---\n\n<div class=\"tip\">\n    由于商标版权问题，Jade 已经改名为了 Pug，详见 [issue](https://github.com/pugjs/jade/issues/2184)。\n</div>\n\n如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Pug 也会是你的菜。Pug 类似于 Python，都采用了对缩进敏感的语法形式，比如下面这段代码创建了一个无序列表：\n\n```javascript\nul(class=\"inline\")\n    li  Item C\n    li  Item A\n    li  Item B\n```\n\n\n<!-- more -->\n\n\n## 属性\n\nPug 的另一大特点就是和 JavaScript 的融合度很高，比如设置属性：\n\n```javascript\n- var authenticated = true\nbody(class= authenticated ? 'authed' : 'anon')\n- var currentUrl = '/about'\na(class={active: currentUrl === '/'} href='/') Home\na(class={active: currentUrl === '/about'} href='/about') About\n```\n\n此外，给标签设置行内样式时，需要以对象的形式赋值给 style：\n\n```javascript\na(style={color: 'red', background: 'green'})\n```\n\n## 插值\n\nPug 提供了字符串插值和标签插值。其中，字符串插值由于要考虑到安全性问题，所以又分成了转义和不转义两种情况：\n\n```javascript\n// 转义插值 #{}\n- var theGreat = \"<span>escape!</span>\";\np This will be safe: #{theGreat}\n\n// 不转义插值 !{}\n- var theGreat = \"<span>escape!</span>\";\np This will be safe: !{theGreat}\n\n// 标签插值\np #[a(href=\"Pug-lang.com\") Pug]\n```\n\n编译结果：\n\n```html\n<!-- 转义插值 #{}-->\n<p>This will be safe: &lt;span&gt;escape!&lt;/span&gt;</p>\n\n<!-- 不转义插值 !{}-->\n<p>This will be safe: <span>escape!</span></p>\n\n<!-- 标签插值-->\n<p><a href=\"Pug-lang.com\">Pug</a></p>\n```\n\n## 逻辑语句\n\nPug 提供了条件、分支、循环、遍历四种逻辑语句，这四种语句继承自 JavaScript，只是语法上有些差异:\n\n- 条件语句：if ... else if ... else\n- 分支语句：case ... when ... default\n- 循环语句：while\n- 遍历数组：each $elem in [elem...]\n- 遍历对象：each $key, $value in {key: value}\n\n```javascript\n// 分支语句\n- var friends = 10\ncase friends\n    when 0\n        p you have no friends\n    when 1\n        p you have a friend\n    default\n        p you have #{friends} friends\n```\n\n## mixin\n\nPug 和 Sass 都提供了 mixin 语法来实现代码的复用，两者语法也很相似：\n\n```javascript\nmixin list(id, ...items)\n    ul(id=id)\n        each item in items\n            li= item\n\n+list('my-list', 1, 2, 3, 4)\n```\n\nmixin 一般放在独立的文件中，需要使用 `include` 指令导入到其他文件中。\n\n## extends\n\n`extends` 是 Pug 的模板继承语法，通过 `extends filename.Pug` 可以将模板文件导入到其他文件中。继承机制基本上是一个复制代码片段的过程，为了能够动态修改其中的部分内容，Pug 提供了 `block` 语法：\n\n```javascript\n// 声明 block\nblock content\n    p Hello\n\n// 修改 block\n// 同名重新赋值\nblock content\n    p Hi\n\n// 前置追加\nblock append content\n    p APPEND\n\n// 后置追加\nblock prepend content\n    p PREPEND\n```\n","slug":"Pug","published":1,"updated":"2015-12-28T09:57:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q617f000al9dilat738fg"},{"title":"ES2015","date":"2015-12-15T06:07:10.000Z","_content":"\nES2015 是最新的 JavaScript 语法规范，也是前端工程化高速发展所催化出的产物。JS 的不成熟一直为人诟病，前端的高速发展又离不开 JS，所以这次激进的变革显得十分必要。\n\n虽然 ES2015 规范发布了，但是要原生的运行在浏览器上还是受到诸多因素的肘制，比如各版本浏览器的用户量、浏览器厂商对新特性的支持度等等。目前的权宜之计是使用 Babel 之类的编译器将 ES2015 代码转换为 ES5，所以下文中的 ES2015 代码也暂时以 Babel 的解析结果为准。各版本浏览器对 ES2015（ES6）、ES2016（ES7）的支持度可以参考这里：[ES2015 兼容性列表](http://kangax.github.io/compat-table/es6/)。\n\n<!-- more -->\n\n## 块级作用域和变量声明\n\nES6 新增了以花括号 `{}` 为标志的块级作用域，用以增强代码的稳健性。在 ES6 之前，JS 中只有全局作用域和函数作用域（eval 作用域？我从来没用过），这种设计有多种弊端，比如最常见的循环变量泄露为全局变量：\n\n```js\nvar a = [];\n\nfor ( var i = 0; i < 3; i++ ) {\n    a[i] = function () {\n        return i;\n    };\n}\n\nconsole.log(a[1]());\n// => 3\n```\n\n虽然循环结束了，但是 i 的值在全局作用域内仍然有效，进而形成了一系列的错误。对于这种错误，最常见的处理方式是使用立即执行函数（Immediately-Invoked Function Expression）：\n\n```js\nvar a = [];\n\nfor ( var i = 0; i < 3; i++ ) {\n    a[i] = (function (i) {\n        return i;\n    })(i);\n}\n\nconsole.log(a[1]);\n// => 1\n```\n\n这里用到的立即执行函数实际上是将[求值策略](http://pinggod.com/2015/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/)从延迟求值转变为了预先求值，但仍然不够优雅和健壮。在 ES2015 中，通过使用 `let` 来声明循环变量同样可以解决这个问题，而且方式更加简洁：\n\n```js\nlet a = [];\n\nfor ( let i = 0; i < 3; i++ ) {\n    a[i] = function () {\n        return i;\n    };\n}\n\nconsole.log(a[1]());\n// => 1\n```\n\n`let` 和 `const` 是 ES2015 新增的变量声明指令：let 用来声明变量，const 用来声明常量。当使用 let 和 const 声明变量时，所声明的变量只在当前的块级作用域内有效，这一点是与 var 的本质差别，也是上述代码生效的基础。对于 var 时代的各种诡异特性，现在 let 和 const 做了一些修改：\n\n- let 和 const 声明的变量不存在变量提升\n- let 和 const 声明的变量不允许在同一作用域内重复声明多次\n- let 和 const 声明的变量必须先声明后使用，否则抛出 ReferenceError\n\n从块级作用域的开始到 let 和 const 变量声明的区域被称为临时死区（temporal dead zone），意指此处调用未声明的 let 和 const 变量一定报错：\n\n```js\nif ( true ) {\n    temp = 'abc';\n    \n    // ...\n    // blablablabla\n    // ...\n\n    // 该行代码之前都属于变量 temp 的 temporal dead zone\n    // 意指在此之前不可使用变量 temp\n    let temp;\n}\n```\n\n<div class=\"tip\">\n    在浏览器环境下，使用 var 声明的全局变量都会挂载在全局对象 window 下面。ES 2015 规定，使用 var 和 function 声明的全局变量仍然挂载在全局对象下面，但是 let、const 和 class 声明的全局变量则不属于全局对象。\n</div>\n\n\n## 解构赋值\n\n解构赋值是 ES2015 提供的一种语法糖操作，常用于简化对数组和对象的数据提取。可以使用解构赋值的数据类型包括：\n\n- 对象\n- 字符串\n- 数值和布尔值（自动转换为对象，然后调用 toString() ）\n- 数组，以及具有 Iterator 结构的数据结构，比如 Set 等\n\n下面我们通过一些实例来看一下解构赋值的使用方式：\n\n```js\n// 1. 交换两个数的值\n[x, y] = [y, x]\n\n// 2. 提取 JSON 数据\nconst JSON = {\n    id: 12345,\n    status: 'OK',\n    data: [123, 456]\n};\n\nconst { id, status, data } = JSON;\n\n// 3. 按需加载模块\nconst { Route, DefaultRoute, HistoryLocation } = ReactRouter; \n\n// 4. 从函数返回多个值\nfunction handleStyle ()  {\n    const font = {};\n    const border = {};\n    const position = {};\n  \n    return { font, border, position };\n}\n\nconst {\n    font: fontStyle,\n    border: borderStyle,\n    position: positionStyle\n} = handleStyle();\n\n```\n\n> 解构赋值可以以 `[x = '0'] = [y]` 的形式设置默认值，当 y 不存在时，x 的值就是 0；如果 y 不存在且没有设置默认值，则会被自动赋值为 undefined。\n\n## 字符串\n\n在 JS 内部，字符以 16 位 2 字节的格式存储，这种表示法的范围限制为 \\u0000-\\uFFFF，对于超出范围的字符（\\u20BB7），会被解析为两个字符四个字节（\\u20BB\\u0007）。ES2015 增强了对 Unicode 的支持，提出了一种新的字符表示方法：\\u{20BB7}。\n\n对于新的字符表示形式 `\\u{codePoint}`，传统的字符串方法已经不适用了，所以 ES2015 提出了一系列新的方法来替代，它们可以正确识别编码大于 \\uFFFF 的字符：\n\n- at()，对应 charAt()，返回指定位置的字符\n- codePointAt()，对应 charCodeAt()，返回指定位置字符的编码\n- String.fromCodePoint()，对应 String.fromCharCode()，返回指定编码所对应的字符\n\n```js\n'\\u20BB7'\n// => '₻7'\n\n'\\u{20BB7}'\n// => '𠮷'\n\n'\\u{20BB7}'.charAt(0)   \n// => '�'\n'\\u{20BB7}'.at(0)       \n// => \"𠮷\"\n\n'\\u{20BB7}'.codePointAt(0).toString(16)\n// => 20BB7\n'\\u{20BB7}'.codePointAt(1).toString(16)\n// => DFB7\n'\\u{20BB7}'.charCodeAt(1).toString(16)\n// => DFB7\n\n'a\\u{20BB7}b'.length\n// => 4\nArray.from('a\\u{20BB7}b').length\n// => 3\n```\n\nES2015 规范中规定字符串实现了 Iterator 接口，用于 for ... of 遍历，此外，增加了一些工具类方法：\n\n```js\nconst str = \"abcdefghi\";\n\n// 判断字符串 str 是否以参数字符串开头\nstr.startsWith('abc');\n// 判断字符串 str 是否包含参数字符串\nstr.includes('def');\n// 判断字符串 str 是否以参数字符串结尾\nstr.endsWith('ghi');\n\n// 生成重复字符串\n'x'.repeat(3);\n// => 'xxx'\n```\n\n字符串的另一个强力扩展是：模板字符串和标签模板。模板字符串（template string）类似于其他编程语言中的字符串插值，以反引号（\\`）为标志，字符串中的插值部分使用 `${}` 包裹：\n\n```js\nconst x = 3;\nconst y = 4;\n\nconsole.log(`${x} + ${y} = ${x + y}`);\n// => '3 + 4 = 7'\n```\n\n如果一个函数的函数名之后紧跟一个模板字符串，那么这个函数就会被用来处理这个模板字符串，这个功能被称为`标签模板（tagged template）`：\n\n```js\n// 第一个参数是一个数组\n// 数组的元素是被插值部分分隔的字符串\n// 第二个及以后的参数代表模板字符串中插值部分的值\n// 可以使用参数扩展语法将其包裹到一个变量中\nfunction tag(strs, ...values) {\n    console.log(strs);\n    console.log(values);\n}\n\nconst x = 3;\nconst y = 4;\n\ntag`${x} + ${y} = ${x + y}`;\n// => [\"\",\" + \",\" = \",\"\"]\n// => [3,4,7]\n```\n\n标签模板的一个实际运用就是过滤 HTML 字符串，提高安全性：\n\n```js\nfunction safeHTML (strs, ...values) {\n    let result = '';\n\n    strs.forEach( (str, index) => {\n        let temp = String(values[index]);\n\n        result += str;\n        if ( temp ) {\n            result += temp.replace(/&/g, '&amp;')\n                          .replace(/</g, '$lt;')\n                          .replace(/>/g, '&gc;');\n        }\n    });\n\n    return result;\n}\n\nconst user = '<html tag>';\nconst msg = safeHTML`<p>${user} has sent you a msg.</p>`;\n// => <p>$lt;html tag&gc; has sent you a msg.</p>undefined\n```\n\n## 数值\n\n数值部分，一个是在 Number 对象上丰富了一些工具函数\n\n- Nubmer.isNaN()\n- Number.isFinite()\n- Number.parseInt()\n- Nubmer.parseFloat()\n- Nnmber.isInteger()\n- Number.EPSILON，极小量常量，在数值比对时，如果小于极小量，则判断两数相等\n- Number.isSafeInteger()，安全范围指（-2^53，2^53）\n- Number.MAX\\_SAFE\\_INTEGER\n- Number.MIN\\_SAFE\\_INTEGER\n\n```js\nNumber.isNaN(NaN);\n// => true\n\nNumber.isFinite(Infinity);\n// => false\n\nNumber.isInteger(1.0);\n// => true\n\nwindow.parseFloat === Number.parseFloat\n// => true\n\nwindow.parseInt === Number.parseInt\n// => true\n\n0.1 + 0.2\n// => 0.30000000000000004\n\n0.1 + 0.2 === 0.3\n// => false\n\n0.1 + 0.2 - 0.3 < Number.EPSILON\n// => true\n```\n\n二是在 Math 对象上扩展了一些数学函数：\n\n- Math.trunc()，去除浮点数的小数部分\n- Math.sign()，判断数值是正数、负数还是零\n- Math.cbrt()，计算一个数值的立方根\n- Math.clz32()，返回一个数值的 32 位无符号整数形式前前导零的个数\n- Math.imul()\n- Math.fround()\n- Math.hypot()\n- Math.expn1()\n- Math.log1p()\n- Math.log10()\n- Math.log2()\n- Math.sinh()\n- Math.cosh()\n- Math.tanh()\n- Math.asinh()\n- Math.acosh()\n- Math.atanh()\n\n```js\nMath.trunc(3.1415926);\n// => 3\n\nMath.cbrt(8);\n// => 2\n\nMath.hypot(3, 4);\n// => 5\n\nMath.log10(100)\n// => 2\n\nMath.log2(16)\n// => 4\n```\n\n## 数组\n\n在函数中，参数对象 arguments 是一个具有 length 属性的对象，这一类对象被称为类数组对象（array-like object），常见的类数组对象包括 arguments 对象和 DOM 操作返回的 NodeList 集合，对于此类类数组对象，我们往往希望可以将其转换为数组，方便调用数组的方法对数据进行处理。在 ES6 中有一个方法专门用于转换类数组对象为真正的数组：\n\n```js\nconst obj = { '0': 'a', length: 2 };\nconst arr = Array.from(obj);\n\nconsole.log(arr);\n// => [ \"a\", undefined ]\n```\n\n从上面的代码可知，对象中的 length 属性确定了转换后数组的长度，索引不匹配的位置返回 undefined，此外 Array.from() 还接受第二个参数，用于对 obj 数据进行 map 处理。此外，对于 ES6 新增的 Set 和 Map 数据结构，也可以使用 Array.from() 转换为数组。\n\n在前面我们遇到了字符串编码大于 \\uFFFF 时，字符长度会被误判的问题，这种情况下可以使用 Array.from() 将字符串转换为数组，获取数组的长度：\n\n```js\n\"𠮷\".length\n// => 2\n\nArray.from(\"𠮷\").length;\n// =>  1\n```\n\n数组的构造函数 Array() 一直存在行为不确定的问题（一个参数表示新建数组长度，多个参数表示新建数组的组成元素），对此 ES6 提出了 Array.of() 方法来构建数组。Array.of() 方法接收任意多个参数，这些参数就是返回数组的元素：\n\n```js\nArray.of(1, 'a', {}, [], Symbol())\n// => [ 1, \"a\", Object, Array[0], Symbol() ]\n```\n\n在众多的数组方法中，有那么一类方法非常值得警惕，这类方法的危险性在于，它们可以修改数组自身的数据，常见方法有：**pop() / push() / shift() / unshift() / reverse() / sort() / splice()**。在 ES6 中也存在两个可以修改数组自身的方法：copyWithin() 和 fill()：\n\n```js\n// copyWithin(arrayStart[, copyStart, copyEnd])\n// arrayStart: 从数组的该位置开始修改数据\n// copyStart: 从数组的该位置开始取数据\n// copyEnd: 从数组的该位置停止取数据\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);\n// => [ 4, 2, 3, 4, 5 ]\n\n// fill(num, start, end) 方法可以用于数据重置\n[1, 2, 3, 4, 5].fill(0, 3, 4);\n// => [ 1, 2, 3, 0, 5 ]\n```\n\n新增的 find() 和 some() 类似，都需要一个回调函数对遍历到的元素进行判断，不同点在于，find() 返回符合条件的第一个值，some() 则是在遇到复合条件的元素时返回 true；另一个新增的 findIndex() 与 indexOf() 类似，用于在数组中查找特定值的索引，不同之处在于 findIndex() 接收一个回调函数，indexOf() 接收的是一个值，此外，findIndex() 配合 Object.is 可以发现 NaN：\n\n```js\n[1, 2, 3, NaN].indexOf(y => Object.is(NaN, y))\n// => -1\n[1, 2, 3, NaN].findIndex(y => Object.is(NaN, y))\n// => 3\n```\n\n此外，我们还可以使用 includes() 方法来判断是否存在：\n\n```js\n[1, 2, NaN].includes(NaN);\n// => true\n```\n\n对于数组的遍历，ES6 提供了更精细的方法 entries() / keys() / values()，分别是对键值对、键和值的遍历：\n\n```js\nfor ( let key of ['a', 'b'].keys() ) {\n    console.log(key);\n}\n// => 0\n// => 1\n\nfor ( let value of ['a', 'b'].values()) {\n    console.log(value);\n}\n// => 'a'\n// => 'b'\n\nfor ( let [key, value] of ['a', 'b'].entries()) {\n    console.log([key, value]);\n}\n// => [ 0, \"a\" ]\n// => [ 1, \"b\" ]\n```\n\n最后，值得一提的是，babel 编译已经支持了数组推导式（ES7），这一推到式在 Haskell 和 python 中都有实现：\n\n```js\nconst years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];\nconst array = [ for ( year of years ) if ( year > 1990 ) if ( year < 2014 ) year ];\nconsole.log(array);\n// => [ 2006, 2010 ]\n```\n\n## 函数\n\n先看一个示例：\n\n```js\nfunction f ( x, y = 2, ...z) {\n    console.log(`x = ${x}`);\n    console.log(`y = ${y}`);\n    console.log(`z = ${z}`);\n}\n\nf(1, undefined, 2, 3, 5, 8, 13);\n// => x = 1\n// => y = 2\n// => z = 2,3,5,8,13\n\nconsoel.log(f.length);\n// => 1\n```\n\n这个示例中聚合了很多 ES6 在函数方面的特性，第一处是 `y = 2`，这种形式定义了函数参数的默认值，所以这里的 y 相当于一个默认值参数；第二处是 `...z`，这里的 z 被称为 rest 参数，用于存放函数中多余的参数，该参数往往可以用来替代 arguments 对象，因为它天生就是数组类型；第三处是传参时的 undefined，如果我们想跳过某个参数，需要显示的将该参数赋值为 undefined，使用 null 的话没有效果；第四处就是 func.length，这里的 length 表示普通参数的数量，如果我们测试 arugments.length，会发现结果为 7，因为这里的 arguments.length 表示的是传入参数的数量；最后一处不是很明显，但是很重要，就是普通参数、默认值参数和 rest 参数的位置顺序。\n\n进一步还可以配合对象解构来传参：\n\n```js\nfunction fetch(url, { body = '', method = 'GET', headers = {} } ) {\n    console.log(method);\n}\n\nfetch('http://meituan.com', {});\n// => 'GET'\n\nfetch('http://meituan.com');\n// => Cannot read property 'body' of undefined\n```\n\n第二个 fetch 的问题在于不能省略第二个参数，如果要省略参数，可以设置双重默认值：\n\n```js\nfunction fetch(url, { body = '', method = 'GET', headers = {} } = {} ) {\n    console.log(method);\n}\n\nfetch('http://meituan.com');\n// => 'GET'\n```\n\nrest 参数 `...rest` 用于将参数打包成数组，通过扩展运算符 `...`，可以执行逆运算，将数组（babel 也支持对类数对象的转换）转换为以分号分隔的参数序列：\n\n```js\nfunction add (...rest) {\n    return [0, ...rest, 21];\n}\n\nadd(1, 1, 2, 3, 5, 8, 13);\n// => [0,1,1,2,3,5,8,13,21]\n\n// 实际运用\n// ES5\nMath.max.apply(null, [1, 5, 3]);\n\n// ES6\nMath.max(...[1, 5, 3]);\n```\n\n接下来是比较亮眼的箭头函数`=>`：\n\n```js\n// ES5\nvar f = function(k, v) {\n    return { k: v };\n}\n\n// ES6\nvar f = (k, v) => ( { k: v } );\n```\n\n看到箭头函数的第一感官就是：简洁。另一个重要的点在于，箭头函数绑定了 this 对象，其特点如下：\n\n1. this 对象的指向是可变，但在箭头函数中，它固定的志向定义时所在的对象，而不是使用时所在的对象\n2. 不可以用于构造函数\n3. 不可以使用 arguments 对象，可以使用 rest 参数代替\n4. 不能用作 Generator 函数，所以不能使用 yield 命令\n\n```js\nfunction foo() {\n    setTimeout( () => {\n        console.log(\"id:\", this.id);\n    },100);\n}\n\nfoo.call( { id: 42 } );\n// id: 42\n```\n\n之所以 this 的指向是固定的，根据 babel 的实现来说，是因为箭头函数内并没有 this 对象，无论箭头函数嵌套多少层，它都是指向定时所在的函数：\n\n```js\nfunction foo() {\n    return () => {\n        return () => {\n            return () => {\n                console.log(\"id:\", this.id);\n            };\n        };\n    };\n}\nfoo.call( { id: 42 } )()()();\n\n// babel 编译结果\n\"use strict\";\nfunction foo() {\n    var _this = this;\n\n    return function () {\n        return function () {\n            return function () {\n                console.log(\"id:\", _this.id);\n            };\n        };\n    };\n}\nfoo.call({ id: 42 })()()();\n```\n\n> ES7 提出了函数绑定的概念，使用双冒号 `::` 来替代 call/apply/bind 的调用，目前 babel 已经支持该特性，双冒号左侧是一个对象，右侧是一个函数，实现以左边对象为上下文对象的右边函数：\n```js\nconst obj = { id: 123 };\nfunction f () {\n    console.log(this.id);\n}\n\nobj::f();\n// => 123\n```\n\n最后，讲讲尾函数调用的优化问题。在函数式编程中，如果某个函数的最后一步是函数调用过程，那么这一过程就成为尾调用：\n\n```js\nfunction f(x){\n    return g(x);\n}\n\n// 下面的函数并不是尾调用\nfunction f(x){\n    g(x);\n}\n\n// 上面示例相当于\nfunction f(x){\n    g(x);\n    return undefined;\n}\n```\n\n函数调用过程是不断入栈出栈的过程，由于尾调用是最后一步操作，所以不需要保存外层函数的调用，这被称为尾调用优化，即只保留内层函数的调用帧，这种优化的好处是如果函数都是尾调用，那么就可以优化到每次尾调用都只保留一层调用，大大节省内存，这就是尾调用优化的意义。\n\n函数调用自身的过程，成为递归，如果尾调用自身，则称为尾递归。下面是一个阶乘函数，没有使用尾递归，最多需要保存 n 个调用记录，复杂度为 O(n)：\n\n```js\nfunction factorial (n) {\n    if ( n === 1 ) return 1;\n    return n * factorial( n - 1 );\n}\n\nfactorial(5);\n// => 120\n\n// 使用尾递归改写，只保留一个调用记录，复杂度 O(1)\n// Babel 检测到尾调用时使用 while 循环执行函数体\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1)\n// => 120\n```\n\n鉴于尾调用优化的在性能上的良好表现，EMCAScript 明确规定，所有 ECMAScript 的实现都应该实现“尾调用优化”。\n\n> 为了确保最后一步调用自身实现尾递归优化，就需要把函数内部用到的变量转换为函数的参数，比如上面的 total，不过这样的处理方式并不容易理解，优化方式有两种，一种是函数柯里化，另一种方式就是使用默认值参数：\n```js\n// 方式一\nfunction currying(fn, n) {\n    return function (m) {\n        return fn.call(this, m, n);\n    };\n}\nfunction tailFactorial(n, total) {\n    if (n === 1) return total;\n    return tailFactorial(n - 1, n * total);\n}\nconst factorial = currying(tailFactorial, 1);\nfactorial(5);\n// => 120\n\n// 方式二\nfunction factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\nfactorial(5);\n// 120\n```\n\n## 对象\n\nES6 在编码的简洁性上做了很多工作，比如上面的箭头函数，比如下面的对象声明：\n\n```js\nconst foo = 'bar';\nconst obj = { foo };\n// 相当于 obj = { foo: foo };\n\nconst obj = {\n    getSth ( x, y ) {\n        return { x, y };\n        // 相当于 return { x: x, y: y };\n    }\n    // 相当于 getSth: function ( x, y ) {}\n}\n```\n\nES2015 新增了一个 Object.is() 方法来比较两个值是否相等，主要解决两方面的问题：一是 `==` 比较时的数据类型自动转换，一是 `===` 比较时 NaN 不等于自身、`+0` 等于 `-0` 的问题。Object.is() 实现的原则是：只要两个值一样，就应该相等（Same-value equality）。\n\n```js\n+0 === -0\n// => true\nObject.is(+0, -0);\n// => false\n\nNaN === NaN;\n// => false\nObject.is(NaN, NaN);\n// => true\n```\n\n`Object.assign(target, source1, source2)` 用于将 source1/source2... 的属性拷贝到 target 中，遇到同名属性自动覆盖：\n\n```js\nlet target = {};\nconst o1 = { \n    id: 123, \n    meta: { \n        age: 1\n    } \n};\nconst o2 = { \n    meta: {\n        age: 2\n    }\n};\nObject.assign(target, o1, o2);\ntarget\n// => {\"id\":123,\"meta\":{\"age\":2}}\n```\n\n到目前为止，一共有六种方法可以遍历对象的属性：\n\n1. `for...in`，循环遍历对象自身的和集成的可枚举属性（不包含 Symbol 属性）\n1. `object.keys(obj)`，返回一个数组，包括自身所有可枚举属性（不含 Symbol 属性和继承属性）\n1. `Object.getOwnPropertyNames(obj)`，返回一个数组，包含对象自身的所有属性（不含Symbol属性，包括不可枚举属性）\n1. `Object.getOwnPropertySymbols(obj)`，返回一个数组，包含对象自身的所有Symbol属性\n1. `Reflect.ownKeys(obj)`，返回一个数组，包含对象自身的所有属性，包括 Symbol 和不可枚举属性\n1. `Reflect.enumerate(obj)` 返回一个 Iterator 对象，结果与 `for...in` 相同\n\n以上六种遍历方法，都遵守同样的遍历次序：\n\n- 首先遍历所有属性名为数值的属性，按照数字排序。\n- 其次遍历所有属性名为字符串的属性，按照生成时间排序。\n- 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。\n\n```js\nReflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })\n// ['2', '10', 'b', 'a', Symbol()]\n```\n\n`__proto__` 是一个没有正式规范，被浏览器广泛支持的属性，ES6 提供了新的方法来代替对该属性的操作：`Object.setPrototypeOf()` / `Object.getPrototypeOf()` / `Object.create()`。\n\n## Symbol\n\nSymbol 是 ES2015 加入的第七种数据类型，它与 undefined/null/boolean/string/number 都是原始数据类型，Symbol 用来实现一种独一无二的值：\n\n```js\nconst s1 = Symbol('foo');\nconst s2 = Symbol('foo');\n\ntypeof s;\n// => 'symbol'\n\ns1.toString();\n// => 'Symbol(foo)'\n\ns2 === s1;\n// => false\n```\n\nSymbol 独一无二的特性非常适合作为对象的属性名：\n\n```js\nconst s = Symbol('foo');\nconst o = {\n    [s]: 'Hi'\n};\n\no.s\n// => 'undefined'\n\n0[s]\n// => 'hi'\n```\n\n在对使用 Symbol 作为属性名的对象进行遍历时，Symbol 属性不会出现在 for...in、for...of 循环中，也不会出现在 Object.keys()、Object.getOwnPropertyNames() 的返回值中。虽然如此，Symbol 并不是私有属性，可以通过 Object.getOwnPropertySymbols() 来获取指定对象的所有 Symbol 属性名：\n\n```js\nconst s1 = Symbol('foo');\nconst s2 = Symbol('baz');\n\nconst obj = {\n    [s1]: 123,\n    [s2]: 'abc'\n};\n\nconst ss = Object.getOwnPropertySymbols(obj);\n// [ Symbol(foo), Symbol(baz) ]\n```\n\n要获取相同的 Symbol，可以调用系统的 Symbol.for()，该方法接受一个字符串作为参数，它会检测是否存在以该字符串参数名称的 Symbol 值，找到就返回，没有就创建：\n\n```js\nconst s1 = Symbol.for('foo');\nconst s2 = Symbol.for('foo');\n\ns1 === s2;\n// => true\n```\n\n上面示例中用作参数的字符串又被成为 Symbol 的 key，使用 Symbol.keyFor() 可以查看这个 key:\n\n```js\nconst s = Symbol.for('foo');\n\nSymbol.keyFor(s);\n// => 'foo'\n```\n\n## Proxy and Reflect\n\nProxy，顾名思义，用于代替特定对象与外界进行交互的对象，简称代理对象:\n\n```js\nconst obj = {};\nconst p = new Proxy(obj, {\n    get: function (target, key) {\n        console.log(target);\n        console.log(`getting ${key}`);\n    }\n});\n\np.xxx\n// => {}\n// => 'getting xxx'\n```\n\nProxy 的拦截操作概览：\n\n- get()，拦截属性的读取\n- set()，拦截属性的设置\n- has()，拦截 propKey in proxy 操作\n- deleteProperty()，拦截 delete proxy[propKey] 操作\n- enumerate()，拦截 for ( let x in proxy ) 操作\n- ownKeys()\n- getOwnPropertyDescriptor()\n- defineProperty()\n- preventExtensions()\n- getPrototypeOf()\n- isExtensible()\n- setPrototypeOf()\n- apply()\n- construct()\n\n使用 Proxy.revocable() 可以创建一个可撤销拦截的代理对象：\n\n```js\nconst { proxy, revoke } = Proxy.revocable({}, {});\n\nproxy.foo = 1;\nconsole.log(proxy.foo);\n// => 1\n\nrevoke();\nconsole.log(proxy);\n// => undefined\n```\n\nReflect 对象的设计初衷：\n\n1. 将 object 对象上明显属于语言内部的方法（Object.defineProperty）放到 Reflect 对象上\n1. 修改某些 Object 对象的返回结果，使其更可控，比如 Object.defineProperty() 在无法定义属性时会抛出错误，而 Reflect.defineProperty() 则会返回 false\n1. 让 Object 操作统一为函数行为，比如 name in obj 和 delete obj[name]，使用 Reflect.has() 和 Reflect.deleteProperty() 来执行\n1. Reflect 对象的方法和 Proxy 对象的方法一一对应，两者高度统一，方便 Proxy 对象调用对应的 Reflect 方法 —— 不管 Proxy 怎么拦截和修改，总可以在 Reflect 上获取默认行为\n\n```js\n// Object 操作对比 Reflect 操作\ntry {\n    Object.defineProperty(target, prop, attr);\n    // success\n}\ncatch (e) {\n    // failure\n}\n\nif (Reflect.defineProperty(target, prop, attr)) {\n    // success\n}\nelse {\n    // failure\n}\n```\n\n## Set and Map\n\nES2015 提供的 Set 数据结构是数组的一个约束，两者的差别就在于 Set 中没有重复值：\n\n```js\n// Set 的参数必须实现了 iterator 接口\nconst set = new Set([1, 2, '2', 2, 1]);\n\nconsole.log(set);\n// => [ 1, 2, \"2\" ]\n```\n\nSet 实例绑定的方法可以分为两类：数据操作方法和成员遍历方法：\n\n![set methods](/img/es2015-set-methods.png)\n\n```js\nconst set = new Set();\n\nset.add(1);\nset.add(2);\n\nset\n// => [1, 2]\n\nset.has(2);\n// => true\n\nset.delete(2);\n// => true\n\nset.clear();\n\nset\n// => []\n\n// 数组去重\nArray.from(new Set([1, 2, 3, 2, 1]))\n// => [1, 2, 3]\n```\n\n在遍历时，由于 Set 结构没有键名，只有键值，所以 keys() 和 values() 的返回值一致：\n\n```js\nconst set = new Set(['red', 'green', 'blue']);\n\nfor ( let key of set.keys() ) {\n    console.log(key);\n}\n// => red\n// => green\n// => blue\n\nfor ( let value of set.values() ) {\n    console.log(value);\n}\n// => red\n// => green\n// => blue\n\nfor ( let [key, value] of set.entries() ) {\n    console.log([key, value]);\n}\n// => [\"red\",\"red\"]\n// => [\"green\",\"green\"]\n// => [\"blue\",\"blue\"]\n```\n\n下面是一个 Set 结构的实例，用来求取两个 Set 结构的并交差集：\n\n```js\nconst x = new Set([1, 2, 3]);\nconst y = new Set([2, 3, 4]);\n\n// 并集\nconst union = new Set([...x, ...y]);\n\n// 交集\nconst intersection = new Set([...x].filter( x => y.has(x) ));\n\n// 差集\nconst diffset = new Set([...x].filter( x => !y.has(x) ));\n```\n\nWeakSet 结构和 Set 结构相似，也是不重复值的集合，差异在于两个地方：一是 WeakSet 内部的元素只能是对象，二是 WeakSet 内部的对象是弱引用，垃圾回收机制不考虑 WeakSet 中对象的引用计数。\n\n由于 WeakSet 结构的对象是弱引用，随时可能消失，所以没有 size 属性，也无法进行遍历，只具有 Set 结构中的三个操作方法：add() / delete() / has()。\n\nMap 结构是对现有 Object 对象的扩展，Object 中的 key 只能是字符串和 Symbol（ES2015 新增），Map 中的 key 可以是任意数据类型：\n\n```js\nconst map = new Map();\nconst obj = { id: 123 };\n\nmap.set(obj, 'hi');\nmap.get(obj);\n// => 'hi'\n\nmap.has(obj);\n// true\nmap.delete(obj);\nmap.has(obj);\n// false\n\n// key 绑定内存地址\nmap.set({}, 'object');\nmap.get({});\n// => undefined\n```\n\n下面在 Map 初始化的时候传入一个二维数组创建 Map：\n\n```js\nconst map = new Map([\n    [1, 'one'],\n    [2, 'two'],\n    [3, 'three']\n]);\n\nfor ( let key of map.keys() ) {\n    console.log(key);\n}\n// => 1\n// => 2\n// => 3\n\nfor ( let value of map.values() ) {\n    console.log(value);\n}\n// => one\n// => two\n// => three\n\nfor ( let [key, value] of map.entries() ) {\n    console.log([key, value]);\n}\n// => [1,\"one\"]\n// => [2,\"two\"]\n// => [3,\"three\"]\n```\n\nWeakMap 是弱引用的 Map 结构，而且 WeakMap 只能以对象作为键值，不接受其他类型的值作为键名。\n\n## Iterator\n\n现在，JS 中表示集合的数据结构包括 String、Array、Object、Map、Set、WeakMap、WeakSet 七种数据结构。Iterator 提供了一种接口，为各种不同的数据结构提供统一的接口，任何数据结构只要部署了 Iterator 结构，就可以完成遍历操作，目前，String、Array、Map 和 Set 是默认部署了该接口的数据结构，Array-like object 可以通过 Array.from() 转换为 Array 使用该接口。\n\nIterator 的作用主要有三点：\n\n- 为数据结构提供统一的访问接口\n- 使得数据接口的成员可以按照某种次序排列\n- 供 for...of 使用\n\n```js\nconst arr = [1, 2, 3];\nconst it = arr[Symbol.iterator]();\n\nit.next();\n// => Object { value: 1, done: false }\nit.next()\n// => Object { value: 2, done: false }\nit.next()\n// => Object { value: 3, done: false }\nit.next()\n// => Object { value: undefined, done: true }\n```\n\n凡是数据结构原生部署了 Symbol.iterator 属性，则具备 Iterator 接口，调用该接口，就可以得到一个遍历器对象。遍历器对象调用 next() 方法一次可以得到数据结构的所有成员，next() 返回一个对象，包括 value 和 done 属性。\n\nES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性上，部署该属性的数据结构都被认为是可遍历的。在某些场合会自动调用遍历器接口：\n\n```js\n// 解构赋值\n[x, y] = [x, y]\n\n// 扩展运算符\n[...'hello']\n// => [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\n// 其他\nfor ... of\nArray.from()\nMap() / Set() / WeakMap() / WeakSet()\nPromise.all()\nPromis.race()\n\n// yield*\nfunction* gen () {\n    yield* [1, 2, 3];\n}\n\nconst it = gen();\n\nit.next();\n// => Object { value: 1, done: false }\nit.next()\n// => Object { value: 2, done: false }\nit.next()\n// => Object { value: 3, done: false }\nit.next()\n// => Object { value: undefined, done: true }\n```\n\n遍历语法的发展：\n\n- for 遍历，语法繁琐\n- forEach()，不能使用 break、continue、return 退出循环\n- for...in，为对象设计，遍历数组时会自动将索引转换为字符串\n- for...of，修复上述问题，可以遍历实现 iterator 接口的数据接口，不支持对普通对象的遍历\n\n```js\nconst arr = ['a', 'b', 'c'];\n\nfor ( let key in arr ) {\n    console.log([key, arr[key]]);\n}\n// => [ \"0\", \"a\" ]\n// => [ \"1\", \"b\" ]\n// => [ \"2\", \"c\" ]\n\nfor ( let [key, value] of arr.entries() ) {\n    console.log([key, value]);\n} \n// => [ 0, \"a\" ]\n// => [ 1, \"b\" ]\n// => [ 2, \"c\" ]\n```\n\n## Generator\n\nGenerator 函数是 ES2015 提供的一种异步编程解决方案。可以将 Generator 视为一个有限状态机，内部封装了多个状态：\n\n```js\nfunction* gen () {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nconst it = gen();\n\nit.next();\n// => Object { value: 1, done: false }\nit.next()\n// => Object { value: 2, done: false }\nit.next()\n// => Object { value: 3, done: false }\nit.next()\n// => Object { value: undefined, done: true }\n```\n\nGenerator 函数返回的遍历器对象需要调用 next 函数才会遍历到下一个内部状态，并且通过函数内部的 yield 命名挂起函数。遍历器对象 next 方法的运行逻辑：\n\n1. 执行 next 函数，遇到 yield 命令挂起函数的执行，并且返回 yield 命令后表达式的值，作为返回的遍历器对象的 value 属性\n1. 继续执行 next 函数，直到遇到下一个 yield，然后挂起函数\n1. 如果没有再遇到 return，就运行到函数结束。函数结束时如果有 return，返回 return 后面表达式的值作为返回对象的 value 属性\n1. 如果没有 return 表达式，则返回对象的 value 属性为 undefined\n\n![es2015-generator-yield](/img/es2015-generator-yield.png)\n\n```js\nfunction* gen () {\n    const ret = yield 1;\n    yield ret;\n}\n\nconst g = gen();\n\ng.next();\n// => Object { value: 1, done: false }\ng.next(true)\n// => Object { value: true, done: false }\ng.next()\n// => Object { value: undefined, done: true }\n```\n\nGenerator 函数返回的对象都部署了 Iterator 接口 [Symbol.iterator]，所以，我们可以使用 for...of 循环来遍历 Generator 函数，当返回对象的 done 属性为 true 时，循环自动中止：\n\n```js\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nfor ( let v of gen() ) {\n    console.log(v);\n}\n// => 1\n// => 2\n// => 3\n```\n\nGenerator 返回的对象附带两个方法：throw() 和 return，用于手动抛出异常和结束 Generator 函数。\n\n如果要在 Generator 函数内调用另外一个 Generator 函数，需要使用 `yield*`，实际上如果 yield 后面跟的是一个遍历器对象，都可以使用 `yield*` 来解析：\n\n```js\nfunction* gen() {\n    yield 1;\n    yield* [2, 3, 4];\n    // 等同于 \n    // yield 2;\n    // yield 3;\n    // yield 4;\n    yield 5;\n}\n\nconst g = gen();\n\ng.next();\n// => Object { value: 1, done: false }\ng.next()\n// => Object { value: 2, done: false }\ng.next()\n// => Object { value: 3, done: false }\ng.next()\n// => Object { value: 4, done: false }\ng.next()\n// => Object { value: 5, done: false }\ng.next()\n// => Object { value: undefined, done: true }\n```\n\n如果对象的某个属性是 Generator 函数，形式上有所不同：\n\n```js\nconst obj = {\n    * gen () {\n        yield 1;\n        yield 2;\n    }\n};\n\nconst g = obj.gen();\n\ng.next();\n// => Object { value: 1, done: false }\ng.next()\n// => Object { value: 2, done: false }\ng.next()\n// => Object { value: undefined, done: true }\n```\n\n前面有数组推导，Generator 函数也有推导，Generator 函数推导的优势在于它是惰性求值：\n\n```js\nfunction* bigArr () {\n    for ( let i = 0; i < 1000000; i++ ) {\n        yield i;\n    }\n}\n\nconst ret = ( for ( n of bigArr() ) if ( n < 10 ) n * n );\n\n[...ret]\n// => [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]\n```\n\n下面是使用 Generator 函数实现的一个状态机：\n\n```js\nfunction* gen() {\n    while( true ) {\n        yield _;\n        console.log('on');\n\n        yield _;\n        console.log('off');\n    }\n}\n\nconst g = gen();\n\ng.next()\n// on\ng.next()\n// off\ng.next()\n// on\n// ...\n```\n\nJS 解析引擎是单线程，只能保持一个调用栈，为了保持多个任务独立的调用栈，引入了协程。Generator 函数是 ES2015 对协程的实现，但不是完整的实现，完整的协程应该可以通过任何函数实现暂停，但是只有 Generator 函数的调用者才能结束 Generator 函数。\n\n如果将 Generator 函数当做协程，可以将多个需要写作的任务都写成 Generator 函数，使用 yield 命令交换控制权。\n\n## Promise\n\n在 ES2015 之前，Promise 早有实现，ES2015 规范统一了 Promise 的用法。Promise 对象共有三个状态：Pending、Resolved 和 Rejected。Promise 对象的状态只能从 Pending 变为 Resolved 或者从 Pending 变为 Rejected。\n\nPromise 对象存在的价值是将异步操作以同步操作的流程表达出来，避免层层嵌套的回调函数，并且提供了统一的接口，便于控制异步操作。不过，Promise 也存在一些缺点：\n\n- 创建后立即执行，无法中途取消\n- 如果不设置回调函数，无法抛出内部错误\n- 处于 Pending 状态时，无法获得具体状态（刚刚开始还是即将完成）\n\nES2015 规定，Promise 对象是一个构造函数，用于生成 Promise 实例：\n\n```js\nconst p = new Promise( (resolve, reject) => {\n    setTimeout(resolve, 1000, 'done');\n});\n\np.then((value) => {\n    console.log(value);\n});\n// 1000ms 后\n// => 'done'\n```\n\nPromise 的原型对象上有两个方法：then() 和 catch()，这里的 catch() 相当于 then(null, reject)。Promise 对象提供的方法：\n\n- all()，用于将多个 Promise 实例打包成一个实例\n- race()，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 建议使用的特性\n\n\n\n\n###### 参考资料\n\n- [ECMAScript6 入门](http://es6.ruanyifeng.com/)\n- [MDN JavaScript](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)\n\n","source":"_posts/ES2015.md","raw":"title: ES2015\ndate: 2015-12-15 14:07:10\n---\n\nES2015 是最新的 JavaScript 语法规范，也是前端工程化高速发展所催化出的产物。JS 的不成熟一直为人诟病，前端的高速发展又离不开 JS，所以这次激进的变革显得十分必要。\n\n虽然 ES2015 规范发布了，但是要原生的运行在浏览器上还是受到诸多因素的肘制，比如各版本浏览器的用户量、浏览器厂商对新特性的支持度等等。目前的权宜之计是使用 Babel 之类的编译器将 ES2015 代码转换为 ES5，所以下文中的 ES2015 代码也暂时以 Babel 的解析结果为准。各版本浏览器对 ES2015（ES6）、ES2016（ES7）的支持度可以参考这里：[ES2015 兼容性列表](http://kangax.github.io/compat-table/es6/)。\n\n<!-- more -->\n\n## 块级作用域和变量声明\n\nES6 新增了以花括号 `{}` 为标志的块级作用域，用以增强代码的稳健性。在 ES6 之前，JS 中只有全局作用域和函数作用域（eval 作用域？我从来没用过），这种设计有多种弊端，比如最常见的循环变量泄露为全局变量：\n\n```js\nvar a = [];\n\nfor ( var i = 0; i < 3; i++ ) {\n    a[i] = function () {\n        return i;\n    };\n}\n\nconsole.log(a[1]());\n// => 3\n```\n\n虽然循环结束了，但是 i 的值在全局作用域内仍然有效，进而形成了一系列的错误。对于这种错误，最常见的处理方式是使用立即执行函数（Immediately-Invoked Function Expression）：\n\n```js\nvar a = [];\n\nfor ( var i = 0; i < 3; i++ ) {\n    a[i] = (function (i) {\n        return i;\n    })(i);\n}\n\nconsole.log(a[1]);\n// => 1\n```\n\n这里用到的立即执行函数实际上是将[求值策略](http://pinggod.com/2015/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/)从延迟求值转变为了预先求值，但仍然不够优雅和健壮。在 ES2015 中，通过使用 `let` 来声明循环变量同样可以解决这个问题，而且方式更加简洁：\n\n```js\nlet a = [];\n\nfor ( let i = 0; i < 3; i++ ) {\n    a[i] = function () {\n        return i;\n    };\n}\n\nconsole.log(a[1]());\n// => 1\n```\n\n`let` 和 `const` 是 ES2015 新增的变量声明指令：let 用来声明变量，const 用来声明常量。当使用 let 和 const 声明变量时，所声明的变量只在当前的块级作用域内有效，这一点是与 var 的本质差别，也是上述代码生效的基础。对于 var 时代的各种诡异特性，现在 let 和 const 做了一些修改：\n\n- let 和 const 声明的变量不存在变量提升\n- let 和 const 声明的变量不允许在同一作用域内重复声明多次\n- let 和 const 声明的变量必须先声明后使用，否则抛出 ReferenceError\n\n从块级作用域的开始到 let 和 const 变量声明的区域被称为临时死区（temporal dead zone），意指此处调用未声明的 let 和 const 变量一定报错：\n\n```js\nif ( true ) {\n    temp = 'abc';\n    \n    // ...\n    // blablablabla\n    // ...\n\n    // 该行代码之前都属于变量 temp 的 temporal dead zone\n    // 意指在此之前不可使用变量 temp\n    let temp;\n}\n```\n\n<div class=\"tip\">\n    在浏览器环境下，使用 var 声明的全局变量都会挂载在全局对象 window 下面。ES 2015 规定，使用 var 和 function 声明的全局变量仍然挂载在全局对象下面，但是 let、const 和 class 声明的全局变量则不属于全局对象。\n</div>\n\n\n## 解构赋值\n\n解构赋值是 ES2015 提供的一种语法糖操作，常用于简化对数组和对象的数据提取。可以使用解构赋值的数据类型包括：\n\n- 对象\n- 字符串\n- 数值和布尔值（自动转换为对象，然后调用 toString() ）\n- 数组，以及具有 Iterator 结构的数据结构，比如 Set 等\n\n下面我们通过一些实例来看一下解构赋值的使用方式：\n\n```js\n// 1. 交换两个数的值\n[x, y] = [y, x]\n\n// 2. 提取 JSON 数据\nconst JSON = {\n    id: 12345,\n    status: 'OK',\n    data: [123, 456]\n};\n\nconst { id, status, data } = JSON;\n\n// 3. 按需加载模块\nconst { Route, DefaultRoute, HistoryLocation } = ReactRouter; \n\n// 4. 从函数返回多个值\nfunction handleStyle ()  {\n    const font = {};\n    const border = {};\n    const position = {};\n  \n    return { font, border, position };\n}\n\nconst {\n    font: fontStyle,\n    border: borderStyle,\n    position: positionStyle\n} = handleStyle();\n\n```\n\n> 解构赋值可以以 `[x = '0'] = [y]` 的形式设置默认值，当 y 不存在时，x 的值就是 0；如果 y 不存在且没有设置默认值，则会被自动赋值为 undefined。\n\n## 字符串\n\n在 JS 内部，字符以 16 位 2 字节的格式存储，这种表示法的范围限制为 \\u0000-\\uFFFF，对于超出范围的字符（\\u20BB7），会被解析为两个字符四个字节（\\u20BB\\u0007）。ES2015 增强了对 Unicode 的支持，提出了一种新的字符表示方法：\\u{20BB7}。\n\n对于新的字符表示形式 `\\u{codePoint}`，传统的字符串方法已经不适用了，所以 ES2015 提出了一系列新的方法来替代，它们可以正确识别编码大于 \\uFFFF 的字符：\n\n- at()，对应 charAt()，返回指定位置的字符\n- codePointAt()，对应 charCodeAt()，返回指定位置字符的编码\n- String.fromCodePoint()，对应 String.fromCharCode()，返回指定编码所对应的字符\n\n```js\n'\\u20BB7'\n// => '₻7'\n\n'\\u{20BB7}'\n// => '𠮷'\n\n'\\u{20BB7}'.charAt(0)   \n// => '�'\n'\\u{20BB7}'.at(0)       \n// => \"𠮷\"\n\n'\\u{20BB7}'.codePointAt(0).toString(16)\n// => 20BB7\n'\\u{20BB7}'.codePointAt(1).toString(16)\n// => DFB7\n'\\u{20BB7}'.charCodeAt(1).toString(16)\n// => DFB7\n\n'a\\u{20BB7}b'.length\n// => 4\nArray.from('a\\u{20BB7}b').length\n// => 3\n```\n\nES2015 规范中规定字符串实现了 Iterator 接口，用于 for ... of 遍历，此外，增加了一些工具类方法：\n\n```js\nconst str = \"abcdefghi\";\n\n// 判断字符串 str 是否以参数字符串开头\nstr.startsWith('abc');\n// 判断字符串 str 是否包含参数字符串\nstr.includes('def');\n// 判断字符串 str 是否以参数字符串结尾\nstr.endsWith('ghi');\n\n// 生成重复字符串\n'x'.repeat(3);\n// => 'xxx'\n```\n\n字符串的另一个强力扩展是：模板字符串和标签模板。模板字符串（template string）类似于其他编程语言中的字符串插值，以反引号（\\`）为标志，字符串中的插值部分使用 `${}` 包裹：\n\n```js\nconst x = 3;\nconst y = 4;\n\nconsole.log(`${x} + ${y} = ${x + y}`);\n// => '3 + 4 = 7'\n```\n\n如果一个函数的函数名之后紧跟一个模板字符串，那么这个函数就会被用来处理这个模板字符串，这个功能被称为`标签模板（tagged template）`：\n\n```js\n// 第一个参数是一个数组\n// 数组的元素是被插值部分分隔的字符串\n// 第二个及以后的参数代表模板字符串中插值部分的值\n// 可以使用参数扩展语法将其包裹到一个变量中\nfunction tag(strs, ...values) {\n    console.log(strs);\n    console.log(values);\n}\n\nconst x = 3;\nconst y = 4;\n\ntag`${x} + ${y} = ${x + y}`;\n// => [\"\",\" + \",\" = \",\"\"]\n// => [3,4,7]\n```\n\n标签模板的一个实际运用就是过滤 HTML 字符串，提高安全性：\n\n```js\nfunction safeHTML (strs, ...values) {\n    let result = '';\n\n    strs.forEach( (str, index) => {\n        let temp = String(values[index]);\n\n        result += str;\n        if ( temp ) {\n            result += temp.replace(/&/g, '&amp;')\n                          .replace(/</g, '$lt;')\n                          .replace(/>/g, '&gc;');\n        }\n    });\n\n    return result;\n}\n\nconst user = '<html tag>';\nconst msg = safeHTML`<p>${user} has sent you a msg.</p>`;\n// => <p>$lt;html tag&gc; has sent you a msg.</p>undefined\n```\n\n## 数值\n\n数值部分，一个是在 Number 对象上丰富了一些工具函数\n\n- Nubmer.isNaN()\n- Number.isFinite()\n- Number.parseInt()\n- Nubmer.parseFloat()\n- Nnmber.isInteger()\n- Number.EPSILON，极小量常量，在数值比对时，如果小于极小量，则判断两数相等\n- Number.isSafeInteger()，安全范围指（-2^53，2^53）\n- Number.MAX\\_SAFE\\_INTEGER\n- Number.MIN\\_SAFE\\_INTEGER\n\n```js\nNumber.isNaN(NaN);\n// => true\n\nNumber.isFinite(Infinity);\n// => false\n\nNumber.isInteger(1.0);\n// => true\n\nwindow.parseFloat === Number.parseFloat\n// => true\n\nwindow.parseInt === Number.parseInt\n// => true\n\n0.1 + 0.2\n// => 0.30000000000000004\n\n0.1 + 0.2 === 0.3\n// => false\n\n0.1 + 0.2 - 0.3 < Number.EPSILON\n// => true\n```\n\n二是在 Math 对象上扩展了一些数学函数：\n\n- Math.trunc()，去除浮点数的小数部分\n- Math.sign()，判断数值是正数、负数还是零\n- Math.cbrt()，计算一个数值的立方根\n- Math.clz32()，返回一个数值的 32 位无符号整数形式前前导零的个数\n- Math.imul()\n- Math.fround()\n- Math.hypot()\n- Math.expn1()\n- Math.log1p()\n- Math.log10()\n- Math.log2()\n- Math.sinh()\n- Math.cosh()\n- Math.tanh()\n- Math.asinh()\n- Math.acosh()\n- Math.atanh()\n\n```js\nMath.trunc(3.1415926);\n// => 3\n\nMath.cbrt(8);\n// => 2\n\nMath.hypot(3, 4);\n// => 5\n\nMath.log10(100)\n// => 2\n\nMath.log2(16)\n// => 4\n```\n\n## 数组\n\n在函数中，参数对象 arguments 是一个具有 length 属性的对象，这一类对象被称为类数组对象（array-like object），常见的类数组对象包括 arguments 对象和 DOM 操作返回的 NodeList 集合，对于此类类数组对象，我们往往希望可以将其转换为数组，方便调用数组的方法对数据进行处理。在 ES6 中有一个方法专门用于转换类数组对象为真正的数组：\n\n```js\nconst obj = { '0': 'a', length: 2 };\nconst arr = Array.from(obj);\n\nconsole.log(arr);\n// => [ \"a\", undefined ]\n```\n\n从上面的代码可知，对象中的 length 属性确定了转换后数组的长度，索引不匹配的位置返回 undefined，此外 Array.from() 还接受第二个参数，用于对 obj 数据进行 map 处理。此外，对于 ES6 新增的 Set 和 Map 数据结构，也可以使用 Array.from() 转换为数组。\n\n在前面我们遇到了字符串编码大于 \\uFFFF 时，字符长度会被误判的问题，这种情况下可以使用 Array.from() 将字符串转换为数组，获取数组的长度：\n\n```js\n\"𠮷\".length\n// => 2\n\nArray.from(\"𠮷\").length;\n// =>  1\n```\n\n数组的构造函数 Array() 一直存在行为不确定的问题（一个参数表示新建数组长度，多个参数表示新建数组的组成元素），对此 ES6 提出了 Array.of() 方法来构建数组。Array.of() 方法接收任意多个参数，这些参数就是返回数组的元素：\n\n```js\nArray.of(1, 'a', {}, [], Symbol())\n// => [ 1, \"a\", Object, Array[0], Symbol() ]\n```\n\n在众多的数组方法中，有那么一类方法非常值得警惕，这类方法的危险性在于，它们可以修改数组自身的数据，常见方法有：**pop() / push() / shift() / unshift() / reverse() / sort() / splice()**。在 ES6 中也存在两个可以修改数组自身的方法：copyWithin() 和 fill()：\n\n```js\n// copyWithin(arrayStart[, copyStart, copyEnd])\n// arrayStart: 从数组的该位置开始修改数据\n// copyStart: 从数组的该位置开始取数据\n// copyEnd: 从数组的该位置停止取数据\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);\n// => [ 4, 2, 3, 4, 5 ]\n\n// fill(num, start, end) 方法可以用于数据重置\n[1, 2, 3, 4, 5].fill(0, 3, 4);\n// => [ 1, 2, 3, 0, 5 ]\n```\n\n新增的 find() 和 some() 类似，都需要一个回调函数对遍历到的元素进行判断，不同点在于，find() 返回符合条件的第一个值，some() 则是在遇到复合条件的元素时返回 true；另一个新增的 findIndex() 与 indexOf() 类似，用于在数组中查找特定值的索引，不同之处在于 findIndex() 接收一个回调函数，indexOf() 接收的是一个值，此外，findIndex() 配合 Object.is 可以发现 NaN：\n\n```js\n[1, 2, 3, NaN].indexOf(y => Object.is(NaN, y))\n// => -1\n[1, 2, 3, NaN].findIndex(y => Object.is(NaN, y))\n// => 3\n```\n\n此外，我们还可以使用 includes() 方法来判断是否存在：\n\n```js\n[1, 2, NaN].includes(NaN);\n// => true\n```\n\n对于数组的遍历，ES6 提供了更精细的方法 entries() / keys() / values()，分别是对键值对、键和值的遍历：\n\n```js\nfor ( let key of ['a', 'b'].keys() ) {\n    console.log(key);\n}\n// => 0\n// => 1\n\nfor ( let value of ['a', 'b'].values()) {\n    console.log(value);\n}\n// => 'a'\n// => 'b'\n\nfor ( let [key, value] of ['a', 'b'].entries()) {\n    console.log([key, value]);\n}\n// => [ 0, \"a\" ]\n// => [ 1, \"b\" ]\n```\n\n最后，值得一提的是，babel 编译已经支持了数组推导式（ES7），这一推到式在 Haskell 和 python 中都有实现：\n\n```js\nconst years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];\nconst array = [ for ( year of years ) if ( year > 1990 ) if ( year < 2014 ) year ];\nconsole.log(array);\n// => [ 2006, 2010 ]\n```\n\n## 函数\n\n先看一个示例：\n\n```js\nfunction f ( x, y = 2, ...z) {\n    console.log(`x = ${x}`);\n    console.log(`y = ${y}`);\n    console.log(`z = ${z}`);\n}\n\nf(1, undefined, 2, 3, 5, 8, 13);\n// => x = 1\n// => y = 2\n// => z = 2,3,5,8,13\n\nconsoel.log(f.length);\n// => 1\n```\n\n这个示例中聚合了很多 ES6 在函数方面的特性，第一处是 `y = 2`，这种形式定义了函数参数的默认值，所以这里的 y 相当于一个默认值参数；第二处是 `...z`，这里的 z 被称为 rest 参数，用于存放函数中多余的参数，该参数往往可以用来替代 arguments 对象，因为它天生就是数组类型；第三处是传参时的 undefined，如果我们想跳过某个参数，需要显示的将该参数赋值为 undefined，使用 null 的话没有效果；第四处就是 func.length，这里的 length 表示普通参数的数量，如果我们测试 arugments.length，会发现结果为 7，因为这里的 arguments.length 表示的是传入参数的数量；最后一处不是很明显，但是很重要，就是普通参数、默认值参数和 rest 参数的位置顺序。\n\n进一步还可以配合对象解构来传参：\n\n```js\nfunction fetch(url, { body = '', method = 'GET', headers = {} } ) {\n    console.log(method);\n}\n\nfetch('http://meituan.com', {});\n// => 'GET'\n\nfetch('http://meituan.com');\n// => Cannot read property 'body' of undefined\n```\n\n第二个 fetch 的问题在于不能省略第二个参数，如果要省略参数，可以设置双重默认值：\n\n```js\nfunction fetch(url, { body = '', method = 'GET', headers = {} } = {} ) {\n    console.log(method);\n}\n\nfetch('http://meituan.com');\n// => 'GET'\n```\n\nrest 参数 `...rest` 用于将参数打包成数组，通过扩展运算符 `...`，可以执行逆运算，将数组（babel 也支持对类数对象的转换）转换为以分号分隔的参数序列：\n\n```js\nfunction add (...rest) {\n    return [0, ...rest, 21];\n}\n\nadd(1, 1, 2, 3, 5, 8, 13);\n// => [0,1,1,2,3,5,8,13,21]\n\n// 实际运用\n// ES5\nMath.max.apply(null, [1, 5, 3]);\n\n// ES6\nMath.max(...[1, 5, 3]);\n```\n\n接下来是比较亮眼的箭头函数`=>`：\n\n```js\n// ES5\nvar f = function(k, v) {\n    return { k: v };\n}\n\n// ES6\nvar f = (k, v) => ( { k: v } );\n```\n\n看到箭头函数的第一感官就是：简洁。另一个重要的点在于，箭头函数绑定了 this 对象，其特点如下：\n\n1. this 对象的指向是可变，但在箭头函数中，它固定的志向定义时所在的对象，而不是使用时所在的对象\n2. 不可以用于构造函数\n3. 不可以使用 arguments 对象，可以使用 rest 参数代替\n4. 不能用作 Generator 函数，所以不能使用 yield 命令\n\n```js\nfunction foo() {\n    setTimeout( () => {\n        console.log(\"id:\", this.id);\n    },100);\n}\n\nfoo.call( { id: 42 } );\n// id: 42\n```\n\n之所以 this 的指向是固定的，根据 babel 的实现来说，是因为箭头函数内并没有 this 对象，无论箭头函数嵌套多少层，它都是指向定时所在的函数：\n\n```js\nfunction foo() {\n    return () => {\n        return () => {\n            return () => {\n                console.log(\"id:\", this.id);\n            };\n        };\n    };\n}\nfoo.call( { id: 42 } )()()();\n\n// babel 编译结果\n\"use strict\";\nfunction foo() {\n    var _this = this;\n\n    return function () {\n        return function () {\n            return function () {\n                console.log(\"id:\", _this.id);\n            };\n        };\n    };\n}\nfoo.call({ id: 42 })()()();\n```\n\n> ES7 提出了函数绑定的概念，使用双冒号 `::` 来替代 call/apply/bind 的调用，目前 babel 已经支持该特性，双冒号左侧是一个对象，右侧是一个函数，实现以左边对象为上下文对象的右边函数：\n```js\nconst obj = { id: 123 };\nfunction f () {\n    console.log(this.id);\n}\n\nobj::f();\n// => 123\n```\n\n最后，讲讲尾函数调用的优化问题。在函数式编程中，如果某个函数的最后一步是函数调用过程，那么这一过程就成为尾调用：\n\n```js\nfunction f(x){\n    return g(x);\n}\n\n// 下面的函数并不是尾调用\nfunction f(x){\n    g(x);\n}\n\n// 上面示例相当于\nfunction f(x){\n    g(x);\n    return undefined;\n}\n```\n\n函数调用过程是不断入栈出栈的过程，由于尾调用是最后一步操作，所以不需要保存外层函数的调用，这被称为尾调用优化，即只保留内层函数的调用帧，这种优化的好处是如果函数都是尾调用，那么就可以优化到每次尾调用都只保留一层调用，大大节省内存，这就是尾调用优化的意义。\n\n函数调用自身的过程，成为递归，如果尾调用自身，则称为尾递归。下面是一个阶乘函数，没有使用尾递归，最多需要保存 n 个调用记录，复杂度为 O(n)：\n\n```js\nfunction factorial (n) {\n    if ( n === 1 ) return 1;\n    return n * factorial( n - 1 );\n}\n\nfactorial(5);\n// => 120\n\n// 使用尾递归改写，只保留一个调用记录，复杂度 O(1)\n// Babel 检测到尾调用时使用 while 循环执行函数体\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1)\n// => 120\n```\n\n鉴于尾调用优化的在性能上的良好表现，EMCAScript 明确规定，所有 ECMAScript 的实现都应该实现“尾调用优化”。\n\n> 为了确保最后一步调用自身实现尾递归优化，就需要把函数内部用到的变量转换为函数的参数，比如上面的 total，不过这样的处理方式并不容易理解，优化方式有两种，一种是函数柯里化，另一种方式就是使用默认值参数：\n```js\n// 方式一\nfunction currying(fn, n) {\n    return function (m) {\n        return fn.call(this, m, n);\n    };\n}\nfunction tailFactorial(n, total) {\n    if (n === 1) return total;\n    return tailFactorial(n - 1, n * total);\n}\nconst factorial = currying(tailFactorial, 1);\nfactorial(5);\n// => 120\n\n// 方式二\nfunction factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\nfactorial(5);\n// 120\n```\n\n## 对象\n\nES6 在编码的简洁性上做了很多工作，比如上面的箭头函数，比如下面的对象声明：\n\n```js\nconst foo = 'bar';\nconst obj = { foo };\n// 相当于 obj = { foo: foo };\n\nconst obj = {\n    getSth ( x, y ) {\n        return { x, y };\n        // 相当于 return { x: x, y: y };\n    }\n    // 相当于 getSth: function ( x, y ) {}\n}\n```\n\nES2015 新增了一个 Object.is() 方法来比较两个值是否相等，主要解决两方面的问题：一是 `==` 比较时的数据类型自动转换，一是 `===` 比较时 NaN 不等于自身、`+0` 等于 `-0` 的问题。Object.is() 实现的原则是：只要两个值一样，就应该相等（Same-value equality）。\n\n```js\n+0 === -0\n// => true\nObject.is(+0, -0);\n// => false\n\nNaN === NaN;\n// => false\nObject.is(NaN, NaN);\n// => true\n```\n\n`Object.assign(target, source1, source2)` 用于将 source1/source2... 的属性拷贝到 target 中，遇到同名属性自动覆盖：\n\n```js\nlet target = {};\nconst o1 = { \n    id: 123, \n    meta: { \n        age: 1\n    } \n};\nconst o2 = { \n    meta: {\n        age: 2\n    }\n};\nObject.assign(target, o1, o2);\ntarget\n// => {\"id\":123,\"meta\":{\"age\":2}}\n```\n\n到目前为止，一共有六种方法可以遍历对象的属性：\n\n1. `for...in`，循环遍历对象自身的和集成的可枚举属性（不包含 Symbol 属性）\n1. `object.keys(obj)`，返回一个数组，包括自身所有可枚举属性（不含 Symbol 属性和继承属性）\n1. `Object.getOwnPropertyNames(obj)`，返回一个数组，包含对象自身的所有属性（不含Symbol属性，包括不可枚举属性）\n1. `Object.getOwnPropertySymbols(obj)`，返回一个数组，包含对象自身的所有Symbol属性\n1. `Reflect.ownKeys(obj)`，返回一个数组，包含对象自身的所有属性，包括 Symbol 和不可枚举属性\n1. `Reflect.enumerate(obj)` 返回一个 Iterator 对象，结果与 `for...in` 相同\n\n以上六种遍历方法，都遵守同样的遍历次序：\n\n- 首先遍历所有属性名为数值的属性，按照数字排序。\n- 其次遍历所有属性名为字符串的属性，按照生成时间排序。\n- 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。\n\n```js\nReflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })\n// ['2', '10', 'b', 'a', Symbol()]\n```\n\n`__proto__` 是一个没有正式规范，被浏览器广泛支持的属性，ES6 提供了新的方法来代替对该属性的操作：`Object.setPrototypeOf()` / `Object.getPrototypeOf()` / `Object.create()`。\n\n## Symbol\n\nSymbol 是 ES2015 加入的第七种数据类型，它与 undefined/null/boolean/string/number 都是原始数据类型，Symbol 用来实现一种独一无二的值：\n\n```js\nconst s1 = Symbol('foo');\nconst s2 = Symbol('foo');\n\ntypeof s;\n// => 'symbol'\n\ns1.toString();\n// => 'Symbol(foo)'\n\ns2 === s1;\n// => false\n```\n\nSymbol 独一无二的特性非常适合作为对象的属性名：\n\n```js\nconst s = Symbol('foo');\nconst o = {\n    [s]: 'Hi'\n};\n\no.s\n// => 'undefined'\n\n0[s]\n// => 'hi'\n```\n\n在对使用 Symbol 作为属性名的对象进行遍历时，Symbol 属性不会出现在 for...in、for...of 循环中，也不会出现在 Object.keys()、Object.getOwnPropertyNames() 的返回值中。虽然如此，Symbol 并不是私有属性，可以通过 Object.getOwnPropertySymbols() 来获取指定对象的所有 Symbol 属性名：\n\n```js\nconst s1 = Symbol('foo');\nconst s2 = Symbol('baz');\n\nconst obj = {\n    [s1]: 123,\n    [s2]: 'abc'\n};\n\nconst ss = Object.getOwnPropertySymbols(obj);\n// [ Symbol(foo), Symbol(baz) ]\n```\n\n要获取相同的 Symbol，可以调用系统的 Symbol.for()，该方法接受一个字符串作为参数，它会检测是否存在以该字符串参数名称的 Symbol 值，找到就返回，没有就创建：\n\n```js\nconst s1 = Symbol.for('foo');\nconst s2 = Symbol.for('foo');\n\ns1 === s2;\n// => true\n```\n\n上面示例中用作参数的字符串又被成为 Symbol 的 key，使用 Symbol.keyFor() 可以查看这个 key:\n\n```js\nconst s = Symbol.for('foo');\n\nSymbol.keyFor(s);\n// => 'foo'\n```\n\n## Proxy and Reflect\n\nProxy，顾名思义，用于代替特定对象与外界进行交互的对象，简称代理对象:\n\n```js\nconst obj = {};\nconst p = new Proxy(obj, {\n    get: function (target, key) {\n        console.log(target);\n        console.log(`getting ${key}`);\n    }\n});\n\np.xxx\n// => {}\n// => 'getting xxx'\n```\n\nProxy 的拦截操作概览：\n\n- get()，拦截属性的读取\n- set()，拦截属性的设置\n- has()，拦截 propKey in proxy 操作\n- deleteProperty()，拦截 delete proxy[propKey] 操作\n- enumerate()，拦截 for ( let x in proxy ) 操作\n- ownKeys()\n- getOwnPropertyDescriptor()\n- defineProperty()\n- preventExtensions()\n- getPrototypeOf()\n- isExtensible()\n- setPrototypeOf()\n- apply()\n- construct()\n\n使用 Proxy.revocable() 可以创建一个可撤销拦截的代理对象：\n\n```js\nconst { proxy, revoke } = Proxy.revocable({}, {});\n\nproxy.foo = 1;\nconsole.log(proxy.foo);\n// => 1\n\nrevoke();\nconsole.log(proxy);\n// => undefined\n```\n\nReflect 对象的设计初衷：\n\n1. 将 object 对象上明显属于语言内部的方法（Object.defineProperty）放到 Reflect 对象上\n1. 修改某些 Object 对象的返回结果，使其更可控，比如 Object.defineProperty() 在无法定义属性时会抛出错误，而 Reflect.defineProperty() 则会返回 false\n1. 让 Object 操作统一为函数行为，比如 name in obj 和 delete obj[name]，使用 Reflect.has() 和 Reflect.deleteProperty() 来执行\n1. Reflect 对象的方法和 Proxy 对象的方法一一对应，两者高度统一，方便 Proxy 对象调用对应的 Reflect 方法 —— 不管 Proxy 怎么拦截和修改，总可以在 Reflect 上获取默认行为\n\n```js\n// Object 操作对比 Reflect 操作\ntry {\n    Object.defineProperty(target, prop, attr);\n    // success\n}\ncatch (e) {\n    // failure\n}\n\nif (Reflect.defineProperty(target, prop, attr)) {\n    // success\n}\nelse {\n    // failure\n}\n```\n\n## Set and Map\n\nES2015 提供的 Set 数据结构是数组的一个约束，两者的差别就在于 Set 中没有重复值：\n\n```js\n// Set 的参数必须实现了 iterator 接口\nconst set = new Set([1, 2, '2', 2, 1]);\n\nconsole.log(set);\n// => [ 1, 2, \"2\" ]\n```\n\nSet 实例绑定的方法可以分为两类：数据操作方法和成员遍历方法：\n\n![set methods](/img/es2015-set-methods.png)\n\n```js\nconst set = new Set();\n\nset.add(1);\nset.add(2);\n\nset\n// => [1, 2]\n\nset.has(2);\n// => true\n\nset.delete(2);\n// => true\n\nset.clear();\n\nset\n// => []\n\n// 数组去重\nArray.from(new Set([1, 2, 3, 2, 1]))\n// => [1, 2, 3]\n```\n\n在遍历时，由于 Set 结构没有键名，只有键值，所以 keys() 和 values() 的返回值一致：\n\n```js\nconst set = new Set(['red', 'green', 'blue']);\n\nfor ( let key of set.keys() ) {\n    console.log(key);\n}\n// => red\n// => green\n// => blue\n\nfor ( let value of set.values() ) {\n    console.log(value);\n}\n// => red\n// => green\n// => blue\n\nfor ( let [key, value] of set.entries() ) {\n    console.log([key, value]);\n}\n// => [\"red\",\"red\"]\n// => [\"green\",\"green\"]\n// => [\"blue\",\"blue\"]\n```\n\n下面是一个 Set 结构的实例，用来求取两个 Set 结构的并交差集：\n\n```js\nconst x = new Set([1, 2, 3]);\nconst y = new Set([2, 3, 4]);\n\n// 并集\nconst union = new Set([...x, ...y]);\n\n// 交集\nconst intersection = new Set([...x].filter( x => y.has(x) ));\n\n// 差集\nconst diffset = new Set([...x].filter( x => !y.has(x) ));\n```\n\nWeakSet 结构和 Set 结构相似，也是不重复值的集合，差异在于两个地方：一是 WeakSet 内部的元素只能是对象，二是 WeakSet 内部的对象是弱引用，垃圾回收机制不考虑 WeakSet 中对象的引用计数。\n\n由于 WeakSet 结构的对象是弱引用，随时可能消失，所以没有 size 属性，也无法进行遍历，只具有 Set 结构中的三个操作方法：add() / delete() / has()。\n\nMap 结构是对现有 Object 对象的扩展，Object 中的 key 只能是字符串和 Symbol（ES2015 新增），Map 中的 key 可以是任意数据类型：\n\n```js\nconst map = new Map();\nconst obj = { id: 123 };\n\nmap.set(obj, 'hi');\nmap.get(obj);\n// => 'hi'\n\nmap.has(obj);\n// true\nmap.delete(obj);\nmap.has(obj);\n// false\n\n// key 绑定内存地址\nmap.set({}, 'object');\nmap.get({});\n// => undefined\n```\n\n下面在 Map 初始化的时候传入一个二维数组创建 Map：\n\n```js\nconst map = new Map([\n    [1, 'one'],\n    [2, 'two'],\n    [3, 'three']\n]);\n\nfor ( let key of map.keys() ) {\n    console.log(key);\n}\n// => 1\n// => 2\n// => 3\n\nfor ( let value of map.values() ) {\n    console.log(value);\n}\n// => one\n// => two\n// => three\n\nfor ( let [key, value] of map.entries() ) {\n    console.log([key, value]);\n}\n// => [1,\"one\"]\n// => [2,\"two\"]\n// => [3,\"three\"]\n```\n\nWeakMap 是弱引用的 Map 结构，而且 WeakMap 只能以对象作为键值，不接受其他类型的值作为键名。\n\n## Iterator\n\n现在，JS 中表示集合的数据结构包括 String、Array、Object、Map、Set、WeakMap、WeakSet 七种数据结构。Iterator 提供了一种接口，为各种不同的数据结构提供统一的接口，任何数据结构只要部署了 Iterator 结构，就可以完成遍历操作，目前，String、Array、Map 和 Set 是默认部署了该接口的数据结构，Array-like object 可以通过 Array.from() 转换为 Array 使用该接口。\n\nIterator 的作用主要有三点：\n\n- 为数据结构提供统一的访问接口\n- 使得数据接口的成员可以按照某种次序排列\n- 供 for...of 使用\n\n```js\nconst arr = [1, 2, 3];\nconst it = arr[Symbol.iterator]();\n\nit.next();\n// => Object { value: 1, done: false }\nit.next()\n// => Object { value: 2, done: false }\nit.next()\n// => Object { value: 3, done: false }\nit.next()\n// => Object { value: undefined, done: true }\n```\n\n凡是数据结构原生部署了 Symbol.iterator 属性，则具备 Iterator 接口，调用该接口，就可以得到一个遍历器对象。遍历器对象调用 next() 方法一次可以得到数据结构的所有成员，next() 返回一个对象，包括 value 和 done 属性。\n\nES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性上，部署该属性的数据结构都被认为是可遍历的。在某些场合会自动调用遍历器接口：\n\n```js\n// 解构赋值\n[x, y] = [x, y]\n\n// 扩展运算符\n[...'hello']\n// => [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\n// 其他\nfor ... of\nArray.from()\nMap() / Set() / WeakMap() / WeakSet()\nPromise.all()\nPromis.race()\n\n// yield*\nfunction* gen () {\n    yield* [1, 2, 3];\n}\n\nconst it = gen();\n\nit.next();\n// => Object { value: 1, done: false }\nit.next()\n// => Object { value: 2, done: false }\nit.next()\n// => Object { value: 3, done: false }\nit.next()\n// => Object { value: undefined, done: true }\n```\n\n遍历语法的发展：\n\n- for 遍历，语法繁琐\n- forEach()，不能使用 break、continue、return 退出循环\n- for...in，为对象设计，遍历数组时会自动将索引转换为字符串\n- for...of，修复上述问题，可以遍历实现 iterator 接口的数据接口，不支持对普通对象的遍历\n\n```js\nconst arr = ['a', 'b', 'c'];\n\nfor ( let key in arr ) {\n    console.log([key, arr[key]]);\n}\n// => [ \"0\", \"a\" ]\n// => [ \"1\", \"b\" ]\n// => [ \"2\", \"c\" ]\n\nfor ( let [key, value] of arr.entries() ) {\n    console.log([key, value]);\n} \n// => [ 0, \"a\" ]\n// => [ 1, \"b\" ]\n// => [ 2, \"c\" ]\n```\n\n## Generator\n\nGenerator 函数是 ES2015 提供的一种异步编程解决方案。可以将 Generator 视为一个有限状态机，内部封装了多个状态：\n\n```js\nfunction* gen () {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nconst it = gen();\n\nit.next();\n// => Object { value: 1, done: false }\nit.next()\n// => Object { value: 2, done: false }\nit.next()\n// => Object { value: 3, done: false }\nit.next()\n// => Object { value: undefined, done: true }\n```\n\nGenerator 函数返回的遍历器对象需要调用 next 函数才会遍历到下一个内部状态，并且通过函数内部的 yield 命名挂起函数。遍历器对象 next 方法的运行逻辑：\n\n1. 执行 next 函数，遇到 yield 命令挂起函数的执行，并且返回 yield 命令后表达式的值，作为返回的遍历器对象的 value 属性\n1. 继续执行 next 函数，直到遇到下一个 yield，然后挂起函数\n1. 如果没有再遇到 return，就运行到函数结束。函数结束时如果有 return，返回 return 后面表达式的值作为返回对象的 value 属性\n1. 如果没有 return 表达式，则返回对象的 value 属性为 undefined\n\n![es2015-generator-yield](/img/es2015-generator-yield.png)\n\n```js\nfunction* gen () {\n    const ret = yield 1;\n    yield ret;\n}\n\nconst g = gen();\n\ng.next();\n// => Object { value: 1, done: false }\ng.next(true)\n// => Object { value: true, done: false }\ng.next()\n// => Object { value: undefined, done: true }\n```\n\nGenerator 函数返回的对象都部署了 Iterator 接口 [Symbol.iterator]，所以，我们可以使用 for...of 循环来遍历 Generator 函数，当返回对象的 done 属性为 true 时，循环自动中止：\n\n```js\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nfor ( let v of gen() ) {\n    console.log(v);\n}\n// => 1\n// => 2\n// => 3\n```\n\nGenerator 返回的对象附带两个方法：throw() 和 return，用于手动抛出异常和结束 Generator 函数。\n\n如果要在 Generator 函数内调用另外一个 Generator 函数，需要使用 `yield*`，实际上如果 yield 后面跟的是一个遍历器对象，都可以使用 `yield*` 来解析：\n\n```js\nfunction* gen() {\n    yield 1;\n    yield* [2, 3, 4];\n    // 等同于 \n    // yield 2;\n    // yield 3;\n    // yield 4;\n    yield 5;\n}\n\nconst g = gen();\n\ng.next();\n// => Object { value: 1, done: false }\ng.next()\n// => Object { value: 2, done: false }\ng.next()\n// => Object { value: 3, done: false }\ng.next()\n// => Object { value: 4, done: false }\ng.next()\n// => Object { value: 5, done: false }\ng.next()\n// => Object { value: undefined, done: true }\n```\n\n如果对象的某个属性是 Generator 函数，形式上有所不同：\n\n```js\nconst obj = {\n    * gen () {\n        yield 1;\n        yield 2;\n    }\n};\n\nconst g = obj.gen();\n\ng.next();\n// => Object { value: 1, done: false }\ng.next()\n// => Object { value: 2, done: false }\ng.next()\n// => Object { value: undefined, done: true }\n```\n\n前面有数组推导，Generator 函数也有推导，Generator 函数推导的优势在于它是惰性求值：\n\n```js\nfunction* bigArr () {\n    for ( let i = 0; i < 1000000; i++ ) {\n        yield i;\n    }\n}\n\nconst ret = ( for ( n of bigArr() ) if ( n < 10 ) n * n );\n\n[...ret]\n// => [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]\n```\n\n下面是使用 Generator 函数实现的一个状态机：\n\n```js\nfunction* gen() {\n    while( true ) {\n        yield _;\n        console.log('on');\n\n        yield _;\n        console.log('off');\n    }\n}\n\nconst g = gen();\n\ng.next()\n// on\ng.next()\n// off\ng.next()\n// on\n// ...\n```\n\nJS 解析引擎是单线程，只能保持一个调用栈，为了保持多个任务独立的调用栈，引入了协程。Generator 函数是 ES2015 对协程的实现，但不是完整的实现，完整的协程应该可以通过任何函数实现暂停，但是只有 Generator 函数的调用者才能结束 Generator 函数。\n\n如果将 Generator 函数当做协程，可以将多个需要写作的任务都写成 Generator 函数，使用 yield 命令交换控制权。\n\n## Promise\n\n在 ES2015 之前，Promise 早有实现，ES2015 规范统一了 Promise 的用法。Promise 对象共有三个状态：Pending、Resolved 和 Rejected。Promise 对象的状态只能从 Pending 变为 Resolved 或者从 Pending 变为 Rejected。\n\nPromise 对象存在的价值是将异步操作以同步操作的流程表达出来，避免层层嵌套的回调函数，并且提供了统一的接口，便于控制异步操作。不过，Promise 也存在一些缺点：\n\n- 创建后立即执行，无法中途取消\n- 如果不设置回调函数，无法抛出内部错误\n- 处于 Pending 状态时，无法获得具体状态（刚刚开始还是即将完成）\n\nES2015 规定，Promise 对象是一个构造函数，用于生成 Promise 实例：\n\n```js\nconst p = new Promise( (resolve, reject) => {\n    setTimeout(resolve, 1000, 'done');\n});\n\np.then((value) => {\n    console.log(value);\n});\n// 1000ms 后\n// => 'done'\n```\n\nPromise 的原型对象上有两个方法：then() 和 catch()，这里的 catch() 相当于 then(null, reject)。Promise 对象提供的方法：\n\n- all()，用于将多个 Promise 实例打包成一个实例\n- race()，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 建议使用的特性\n\n\n\n\n###### 参考资料\n\n- [ECMAScript6 入门](http://es6.ruanyifeng.com/)\n- [MDN JavaScript](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)\n\n","slug":"ES2015","published":1,"updated":"2016-01-08T10:05:58.000Z","_id":"cij3q617h000bl9dirqjtqaix","comments":1,"layout":"post","photos":[],"link":""},{"title":"CSS Flexbox","date":"2015-12-02T02:42:39.000Z","_content":"\n如果你正在学习使用 CSS 布局，推荐来 [learnlayout](http://zh.learnlayout.com/toc.html) 了解一下这些年前端所用到的各类布局手法。这里之所以使用“手法”一词，意指其中多少有些偏激取巧，比如使用浮动（float）来定位、使用 margin 来伸缩空间等等。\n\nfloat、margin 本不应该用于布局，只是囿于早期的 CSS 布局模块发展缓慢且不合时宜，促使开发者另辟蹊径，借助其他样式来模拟布局效果。最近几年随着浏览器对布局模块的支持度越来越高，Flexible Box Layout（Flexbox）、Grid Layout、Multiple Column Layout 也逐渐为开发者所接受，其中以 Flexbox 的兼容性最好，拥护者也随之水涨船高。\n\n就个人感受而言，未来的布局方式会归纳为两类：一类是纯粹使用浏览器兼容性高的布局模块，比如 Flexbox，这也是未来的发展趋势；另一类是使用预处理器或者框架自定义的布局模块，这只是目前的缓兵过渡之计。\n\n<!-- more -->\n\n在几个月前，我曾经使用过一段时间的 [Susy](http://susy.oddbird.net/)。 Susy 是基于 Sass 的一款布局框架，其核心是使用非布局样式来模拟布局效果，最大的优点在于封装布局样式之后提供了一套简洁明了的布局接口。比如，在下面的 Sass 代码中，`.contianer` 被附加了一套容器样式，嵌套在其中的 `item` 占据总体宽度的 4 / 10。\n\n```scss\n.container {\n    @include container;  \n    .item {\n        @include span(4 of 10);\n    }\n}\n```\n\n> Susy 的理念是帮助开发者规避数学计算，所以它有一条大快人心的口号：YOUR MARKUP, YOUR DESIGN, YOUR OPINIONS, OUR MATH。\n\n## Flexbox\n\n在数学计算的问题上，我觉得 Flexbox 和 Susy 有异曲同工之妙，只是相比起来，原生的 Flexbox 更加简捷。在 Flexbox 中有两个核心元素：`container` 和 `item`，所有的样式也是围绕这两类元素计算的。下图中有两条红线，分别代表在水平方向和垂直方向进行布局的基线。\n\n![Flexbox](/img/flexbox.png)\n\nFlexbox 中的 contianer 元素需要解决两个问题：自身的类型以及内部 item 的排列方式。通过 `display: flex` 和 `display: inline-flex` 可以将 container 声明为块级或者行内块级，从而确定了 container 自身的类型。使用以下属性则可以确定 container 内部 item 的排列方式：\n\n- flex-flow：flex-direction 和 flex-wrap 的缩写\n- flex-direction：决定 item 的排列方向\n- flex-wrap：决定 item 的溢出容器后的处理方式\n- justify-content：决定 item 在水平方向上的对齐方式\n- align-item：决定 item 在垂直方向上的对齐方式\n- align-content：决定多个 main axis 在垂直方向上的对齐方式\n\n![flex-container](/img/flexbox-container.png)\n\nitem 元素需要解决的问题集中于自身上，包括自身在 container 中的顺序、缩放、对齐方式。使用以下属性可以设置 item 自身的布局样式：\n\n- order：决定 item 的顺序，默认值为 0，值越小越靠前\n- flex：flex-grow、flex-shrink 和 flex-basis 的缩写\n- flex-grow：决定 item 的放大比例，默认值为 0，0 表示不放大\n- flex-shrink：决定 item 的缩小比例，默认值为 1，0 表示不缩小\n- flex-basis：浏览器分配 container 剩余空间时，决定 item 获得的比重\n- align-self: 决定自身在垂直方向的对齐方式\n\n![flex-item](/img/flexbox-cell.png)\n\n## box-sizing\n\n话外提一下 `box-sizing`， 该属性用于声明 `width` 和 `height` 的约束范围：`border-box` 表示边框、内边距和内容块的宽高计入容器宽高；`content-box` 表示只有内容块的宽高计入容器宽高。此外，该属性可继承，可以通过设置 body 的 box-sizing 统一约束容器的宽高。\n\n## FlexFroggy\n\n这是一个寓教于乐的 Flexbox 布局小游戏，难度中下，很有意思：[http://flexboxfroggy.com](http://flexboxfroggy.com)。","source":"_posts/CSS-Flexbox.md","raw":"title: CSS Flexbox\ndate: 2015-12-02 10:42:39\n---\n\n如果你正在学习使用 CSS 布局，推荐来 [learnlayout](http://zh.learnlayout.com/toc.html) 了解一下这些年前端所用到的各类布局手法。这里之所以使用“手法”一词，意指其中多少有些偏激取巧，比如使用浮动（float）来定位、使用 margin 来伸缩空间等等。\n\nfloat、margin 本不应该用于布局，只是囿于早期的 CSS 布局模块发展缓慢且不合时宜，促使开发者另辟蹊径，借助其他样式来模拟布局效果。最近几年随着浏览器对布局模块的支持度越来越高，Flexible Box Layout（Flexbox）、Grid Layout、Multiple Column Layout 也逐渐为开发者所接受，其中以 Flexbox 的兼容性最好，拥护者也随之水涨船高。\n\n就个人感受而言，未来的布局方式会归纳为两类：一类是纯粹使用浏览器兼容性高的布局模块，比如 Flexbox，这也是未来的发展趋势；另一类是使用预处理器或者框架自定义的布局模块，这只是目前的缓兵过渡之计。\n\n<!-- more -->\n\n在几个月前，我曾经使用过一段时间的 [Susy](http://susy.oddbird.net/)。 Susy 是基于 Sass 的一款布局框架，其核心是使用非布局样式来模拟布局效果，最大的优点在于封装布局样式之后提供了一套简洁明了的布局接口。比如，在下面的 Sass 代码中，`.contianer` 被附加了一套容器样式，嵌套在其中的 `item` 占据总体宽度的 4 / 10。\n\n```scss\n.container {\n    @include container;  \n    .item {\n        @include span(4 of 10);\n    }\n}\n```\n\n> Susy 的理念是帮助开发者规避数学计算，所以它有一条大快人心的口号：YOUR MARKUP, YOUR DESIGN, YOUR OPINIONS, OUR MATH。\n\n## Flexbox\n\n在数学计算的问题上，我觉得 Flexbox 和 Susy 有异曲同工之妙，只是相比起来，原生的 Flexbox 更加简捷。在 Flexbox 中有两个核心元素：`container` 和 `item`，所有的样式也是围绕这两类元素计算的。下图中有两条红线，分别代表在水平方向和垂直方向进行布局的基线。\n\n![Flexbox](/img/flexbox.png)\n\nFlexbox 中的 contianer 元素需要解决两个问题：自身的类型以及内部 item 的排列方式。通过 `display: flex` 和 `display: inline-flex` 可以将 container 声明为块级或者行内块级，从而确定了 container 自身的类型。使用以下属性则可以确定 container 内部 item 的排列方式：\n\n- flex-flow：flex-direction 和 flex-wrap 的缩写\n- flex-direction：决定 item 的排列方向\n- flex-wrap：决定 item 的溢出容器后的处理方式\n- justify-content：决定 item 在水平方向上的对齐方式\n- align-item：决定 item 在垂直方向上的对齐方式\n- align-content：决定多个 main axis 在垂直方向上的对齐方式\n\n![flex-container](/img/flexbox-container.png)\n\nitem 元素需要解决的问题集中于自身上，包括自身在 container 中的顺序、缩放、对齐方式。使用以下属性可以设置 item 自身的布局样式：\n\n- order：决定 item 的顺序，默认值为 0，值越小越靠前\n- flex：flex-grow、flex-shrink 和 flex-basis 的缩写\n- flex-grow：决定 item 的放大比例，默认值为 0，0 表示不放大\n- flex-shrink：决定 item 的缩小比例，默认值为 1，0 表示不缩小\n- flex-basis：浏览器分配 container 剩余空间时，决定 item 获得的比重\n- align-self: 决定自身在垂直方向的对齐方式\n\n![flex-item](/img/flexbox-cell.png)\n\n## box-sizing\n\n话外提一下 `box-sizing`， 该属性用于声明 `width` 和 `height` 的约束范围：`border-box` 表示边框、内边距和内容块的宽高计入容器宽高；`content-box` 表示只有内容块的宽高计入容器宽高。此外，该属性可继承，可以通过设置 body 的 box-sizing 统一约束容器的宽高。\n\n## FlexFroggy\n\n这是一个寓教于乐的 Flexbox 布局小游戏，难度中下，很有意思：[http://flexboxfroggy.com](http://flexboxfroggy.com)。","slug":"CSS-Flexbox","published":1,"updated":"2015-12-27T09:32:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij3q617i000cl9di35dhfv8o"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}