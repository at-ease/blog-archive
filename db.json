{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0}],"Cache":[{"_id":"source/_posts/ES2015.md","shasum":"c596a16aa8ab122800f2a1e14f016b5f0e22bdc7","modified":1450159630000},{"_id":"source/_posts/React-组件的生命周期.md","shasum":"b17167d89deac05359005638fb4925ff45958e20","modified":1448706545000},{"_id":"source/_posts/Jade.md","shasum":"1dce5e6073654bcb9d6e987ce9f59667f4b2ed68","modified":1449811457000},{"_id":"source/_posts/CSS-Flexbox.md","shasum":"b7a52651b0b87d1847b14717be74ca042355cb4f","modified":1450156705000},{"_id":"source/CNAME","shasum":"ba64683b82f51c18f5419339a4ef75e195f7c402","modified":1445400313000},{"_id":"source/_posts/React-组件间的消息传递.md","shasum":"e42a662555129cf89dfd987846a54a15ed5f2746","modified":1448883626000},{"_id":"source/_posts/Sass.md","shasum":"4f240782101df70252fd3846fd6eca0fa340fa24","modified":1448505046000},{"_id":"source/_posts/inline-and-absolute.md","shasum":"4dae30f1d5bc887ea2c305e829c3b8347e97e83b","modified":1449460315000},{"_id":"source/_posts/void-and-undefined.md","shasum":"b1031feb4823f14e676fae1e6c2a70b14993a224","modified":1448887164000},{"_id":"source/_posts/数据类型的分类.md","shasum":"d3c000566260ffd3fc260f6ec620345a54443c0a","modified":1448191963000},{"_id":"source/_posts/求值策略.md","shasum":"e75ffcb0f571928ffee2918d95e85d14acf700ce","modified":1449734273000},{"_id":"themes/apollo/LICENSE","shasum":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1448672779000},{"_id":"themes/apollo/README.md","shasum":"1ba376ab25772656eb5af72f632ecff83cabf8cc","modified":1448672779000},{"_id":"themes/apollo/_config.yml","shasum":"cebf93a9f1ca539a3f0051fd862328aab26e8a38","modified":1448672779000},{"_id":"themes/apollo/layout/mixins/paginator.jade","shasum":"510ee0ba37b4522cca6c6204d641809454ba3ac6","modified":1448672779000},{"_id":"themes/apollo/gulpfile.babel.js","shasum":"ae6ba496e2672ed07050295954ca3da8b0ef423c","modified":1448672779000},{"_id":"themes/apollo/doc/custom-blocks.md","shasum":"78e9400714d0ff7c9b272d3ccc80fb18c3bf208f","modified":1448672779000},{"_id":"themes/apollo/layout/index.jade","shasum":"58c451042cad5beeb5a76852bba609c651ff3428","modified":1448672779000},{"_id":"themes/apollo/layout/partial/comment.jade","shasum":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1448672779000},{"_id":"themes/apollo/layout/partial/head.jade","shasum":"2ed7b73ad13b184e2bda9c80ba078ea33bbbbe4d","modified":1448672779000},{"_id":"themes/apollo/layout/partial/layout.jade","shasum":"d9c4f8933f6740f5159713ec69ab943db5fb7cae","modified":1448672779000},{"_id":"themes/apollo/layout/partial/nav.jade","shasum":"c35d3061da4b053b73150d9741c542d660798270","modified":1448672779000},{"_id":"themes/apollo/layout/post.jade","shasum":"7593ff041af04c387c457417237d9ab9e3cb467d","modified":1448672779000},{"_id":"themes/apollo/layout/mixins/post.jade","shasum":"37411bb13470bbfdb78b300ad4feffd2a2737086","modified":1448866817000},{"_id":"themes/apollo/package.json","shasum":"a872d0158d522612ccc0b300bdf27d0228de8428","modified":1448672779000},{"_id":"themes/apollo/layout/partial/scripts.jade","shasum":"4c83fec1e2fc5cffefafc2e31835e28122c0fdfd","modified":1448848041000},{"_id":"themes/apollo/source/favicon.png","shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1448672779000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","shasum":"60cf365489c0d93cd7e9f10eedd4aee702e1ef27","modified":1448672779000},{"_id":"themes/apollo/source/css/apollo.css","shasum":"aa4525e734cdd3e35bca7d8082b68440e8131b24","modified":1449460861000},{"_id":"themes/apollo/source/scss/_partial/base.scss","shasum":"88b361e68475caddbab763feed5e1db788ac2cd7","modified":1448674527000},{"_id":"themes/apollo/source/scss/_partial/header.scss","shasum":"d24cc6520f3faa7bb80610b858a92639eadcc289","modified":1448672779000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","shasum":"0b9c7097136ac8e4a07d9702fc4dbe0345ac7596","modified":1448672779000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","shasum":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1448672779000},{"_id":"themes/apollo/source/scss/_partial/post.scss","shasum":"8ca0ffea647c28ed0b158635a142e43ae052b2f2","modified":1449460861000},{"_id":"themes/apollo/source/scss/apollo.scss","shasum":"f8b40223ea647b7c5627c344ead5c1a493bdd576","modified":1448672779000},{"_id":"themes/apollo/source/scss/_partial/posts.scss","shasum":"92858015b8f3dcb4eb91b6dc41563b7aaa91b376","modified":1448867710000},{"_id":"public/CNAME","modified":1450159647072,"shasum":"ba64683b82f51c18f5419339a4ef75e195f7c402"},{"_id":"public/scss/apollo.scss","modified":1450159647079,"shasum":"f8b40223ea647b7c5627c344ead5c1a493bdd576"},{"_id":"public/favicon.png","modified":1450159647083,"shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c"},{"_id":"public/css/apollo.css","modified":1450159647085,"shasum":"aa4525e734cdd3e35bca7d8082b68440e8131b24"},{"_id":"public/2015/ES2015/index.html","modified":1450159647275,"shasum":"722b33a84a7eb6d0762dbcc669184e630c4d6708"},{"_id":"public/2015/求值策略/index.html","modified":1450159647382,"shasum":"20216d961440b57ca0b5372d959c28cffe871f75"},{"_id":"public/2015/inline-and-absolute/index.html","modified":1450159647466,"shasum":"b11e4d86844b99a683b499feece953975c657887"},{"_id":"public/2015/Jade/index.html","modified":1450159647542,"shasum":"ffe837e7ec6a9eca7daff41a700c99da70b54386"},{"_id":"public/2015/CSS-Flexbox/index.html","modified":1450159647629,"shasum":"e421d97dca8494a515ccf21909987be287dd4b63"},{"_id":"public/2015/void-and-undefined/index.html","modified":1450159647696,"shasum":"86889c1c33df36c5d775b65bb550534625414ced"},{"_id":"public/2015/React-组件间的消息传递/index.html","modified":1450159647764,"shasum":"5f71877b8fea8e889a3ceb955406ad135f740877"},{"_id":"public/2015/React-组件的生命周期/index.html","modified":1450159647834,"shasum":"51a2cee50a23317bc74cec76604e1f22aacf597b"},{"_id":"public/2015/Sass/index.html","modified":1450159647915,"shasum":"6b28207e6b2480bb86780b0c945fb42e718519ef"},{"_id":"public/2015/数据类型的分类/index.html","modified":1450159647988,"shasum":"d3393043542fe9629b4b9582578aac7c581afc13"},{"_id":"public/archives/index.html","modified":1450159648048,"shasum":"76f79ec0153325d46fccb924a85f945bc1739da3"},{"_id":"public/archives/2015/index.html","modified":1450159648122,"shasum":"76f79ec0153325d46fccb924a85f945bc1739da3"},{"_id":"public/archives/2015/11/index.html","modified":1450159648153,"shasum":"7e9534215c76581e54a7e6b924483d0a31336aca"},{"_id":"public/archives/2015/12/index.html","modified":1450159648187,"shasum":"1c5541309da38d584085f0f9c28d5696a7e47cc3"},{"_id":"public/atom.xml","modified":1450159648191,"shasum":"0ae4fced4118d9adae8df14f2d7d52dae5782d46"},{"_id":"public/index.html","modified":1450159648218,"shasum":"444faccdf30c88091df99cd14b2d70bd5534c17c"},{"_id":"public/sitemap.xml","modified":1450159648220,"shasum":"d5eff3a869779ae5d08341ff6b4d88f3da8e75d7"}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"求值策略","date":"2015-12-10T05:43:07.000Z","_content":"\n> 须知参差多态乃是幸福本源。\n\n求值策略所要解决的问题是：何时求值。之所以要控制求值的时间，往往是出于对内存占用和执行效率的考虑。在维基百科的求值策略词条中，列出了五种求值策略：\n\n- 预先求值，表达式绑定到变量时，立即求值并附加给变量\n- 延迟求值，表达式绑定到变量后，并不求值，直到变量被调用时才求值\n- 局部求值，又称柯里化\n- 分布求值，map/reduce，典型应用是分布式计算\n- 短路求值，与 (&&) 、或 (||) 逻辑运算\n\n顾名思义，预先求值和延迟求值是一对对立的求值策略。在下面的 js 代码段中，声明了变量 x，x 赋值后又被调用了三次：\n\n```js\n// 1\nvar x = 5 + 3 * (1 + 5 ^ 2);\n// 2\nconsole.log(x);\nconsole.log(x + 2);\n// 3\nfunc(x);\n```\n\n<!-- more -->\n\n在 1 处，变量 x 完成了声明和赋值等初始化工作，它的值由表达式 (5 + 3 * (1 + 5 ^ 2)) 决定。在 2 处，console.log() 函数调用了变量 x 两次。让我们暂时忽略 js 编译器的求值策略，从个人主观的理性思维来思考一下：面对预先求值和延迟求值，你会怎么选择呢？\n\n做出选择之前，我们需要对变量 x 有一个复杂度的认知：如果表达式的复杂度高，那么该表达式所占用的内存空间也就越高，在变量 x 和表达式解绑前这段内存空间都无法释放掉，意味着 x 的间接内存占用了越高，此外，高复杂度也意味着较长的执行时间，所以复杂度和内存占用、执行效率至少是一种线性相关。\n\n如此说来，那么我们应该选择预先求值的求值策略，这样的好处是：变量 x 初始化时表达式立即计算，x 被重新赋值为 83，重新赋值后表达式所占用的内存空间被释放掉，达到了节省内存空间的目的；多次调用变量 x 时，x 的值已经是可以直接用于运算的数值，而不是需要计算的表达式，减少了重复运算，提高了执行效率。\n\n如果事情按照上面描述的美好愿景发展的话，就没有延迟求值策略出现的必要了。在 3 处，我们向函数 func() 传递了变量 x。这里的 func() 类似于一个黑盒，我们不了解其内部的处理机制，也无法确定 x 是否会被使用。这个时候延迟求值的价值就体现出来了，如果变量 x 在函数内部没有被使用，就不会执行求值，避免了预先求值所要执行的求值运算。\n\n随着表达式的复杂度逐渐提高，预先求值和延迟求值在内存占用、执行效率上的差异就会愈发明显。所以根据数据类型的复杂度，js 将数据类型分为原始值和引用值，传递参数时，原始值按值传递，引用值按引用传递。","source":"_posts/求值策略.md","raw":"title: 求值策略\ndate: 2015-12-10 13:43:07\n---\n\n> 须知参差多态乃是幸福本源。\n\n求值策略所要解决的问题是：何时求值。之所以要控制求值的时间，往往是出于对内存占用和执行效率的考虑。在维基百科的求值策略词条中，列出了五种求值策略：\n\n- 预先求值，表达式绑定到变量时，立即求值并附加给变量\n- 延迟求值，表达式绑定到变量后，并不求值，直到变量被调用时才求值\n- 局部求值，又称柯里化\n- 分布求值，map/reduce，典型应用是分布式计算\n- 短路求值，与 (&&) 、或 (||) 逻辑运算\n\n顾名思义，预先求值和延迟求值是一对对立的求值策略。在下面的 js 代码段中，声明了变量 x，x 赋值后又被调用了三次：\n\n```js\n// 1\nvar x = 5 + 3 * (1 + 5 ^ 2);\n// 2\nconsole.log(x);\nconsole.log(x + 2);\n// 3\nfunc(x);\n```\n\n<!-- more -->\n\n在 1 处，变量 x 完成了声明和赋值等初始化工作，它的值由表达式 (5 + 3 * (1 + 5 ^ 2)) 决定。在 2 处，console.log() 函数调用了变量 x 两次。让我们暂时忽略 js 编译器的求值策略，从个人主观的理性思维来思考一下：面对预先求值和延迟求值，你会怎么选择呢？\n\n做出选择之前，我们需要对变量 x 有一个复杂度的认知：如果表达式的复杂度高，那么该表达式所占用的内存空间也就越高，在变量 x 和表达式解绑前这段内存空间都无法释放掉，意味着 x 的间接内存占用了越高，此外，高复杂度也意味着较长的执行时间，所以复杂度和内存占用、执行效率至少是一种线性相关。\n\n如此说来，那么我们应该选择预先求值的求值策略，这样的好处是：变量 x 初始化时表达式立即计算，x 被重新赋值为 83，重新赋值后表达式所占用的内存空间被释放掉，达到了节省内存空间的目的；多次调用变量 x 时，x 的值已经是可以直接用于运算的数值，而不是需要计算的表达式，减少了重复运算，提高了执行效率。\n\n如果事情按照上面描述的美好愿景发展的话，就没有延迟求值策略出现的必要了。在 3 处，我们向函数 func() 传递了变量 x。这里的 func() 类似于一个黑盒，我们不了解其内部的处理机制，也无法确定 x 是否会被使用。这个时候延迟求值的价值就体现出来了，如果变量 x 在函数内部没有被使用，就不会执行求值，避免了预先求值所要执行的求值运算。\n\n随着表达式的复杂度逐渐提高，预先求值和延迟求值在内存占用、执行效率上的差异就会愈发明显。所以根据数据类型的复杂度，js 将数据类型分为原始值和引用值，传递参数时，原始值按值传递，引用值按引用传递。","slug":"求值策略","published":1,"updated":"2015-12-10T07:57:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0oh000060dignnogpll"},{"title":"数据类型的分类","date":"2015-11-15T11:29:36.000Z","_content":"\n开始写作本文的时候，我已经顺利地度过了四个月的前端实习生活，其间经手的项目勉强称得上稳定和健壮。但是刚刚学习前端的那些日子，可没现在这么自信，回想起来仍然颇多感慨。\n\n《JavaScript 典型应用与最佳实践》是我学习 JavaScript 的启蒙书籍，初版于 2008 年，面色古老而又心思缜密。其中的原始值和引用值一节，让我对 JavaScript 中数据类型的理解豁然开朗。如果从写作的角度看这本书，它的亮点在于以一种结构化的思维由浅入深地引导读者，主干和分支条缕清晰。有趣的是，在我用谷歌为结构化思维（Structed Thinking）查找一些理论依据的时候，链接到了一本更古老的书籍《金字塔原理：思考、写作和解决问题的逻辑》，书中介绍的正是作者自 1963 年以来反复实践的一套结构化思维，具体的细节等我读完后再聊吧。\n\n<!-- more -->\n\n最近项目中使用到的技术都比较激进，比如 ES6 / React / Flux 等等。在 ES6 的代码中你能看到诸多其他语言的影子，比如 Python，所以上一周我决定重新回顾一下 Python 中的要点，选用的参考资料是由 Wesley J. Chun 编写的《Python 核心编程（第二版）》。\n\n当读到 4.8 节《标准类型的分类》时，我可以确定，这又是一次结构化思维在知识传播过程中华丽的表演。在高级程序设计语言中，数据类型是必不可少的一部分。理解一门语言的数据类型，也是最基础的一步。虽然下面的示例交错使用 Python 和 JavaScript，但其中所叙述的本质是具有广泛性的。\n\n## Python\n\nPython 中每个对象都有三个特性：id, type 和 value。这些特性在对象初始化时创建。Python 内建了多种数据类型，基本类型包括：\n\n- integer, long integer, float, complex number\n- string\n- list\n- tuple\n- dictionary\n\n对数据类型分类，可以让我们更清晰地理解类型之间的关系以及工作原理。首先，使用存储模型进行分类。存储类型的衡量标准就是看对象能保存多少个对象。对于只能存储单个基本类型的对象，我们称之为原子或标量存储；那些可以存储多个基本类型的对象，称之为容器存储。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n标量 / 原子存储| 数值、字符串\n容器类型       | 列表、元素、字典\n\n然后，使用更新模型进行分类，更新模型的分类依据是看对象是否允许多次赋值。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n可变类型       | 列表、字典\n不可变类型     | 数值、字符串、元组\n\n最后，使用访问模型进行分类，访问模型的分类依据是看访问方式：直接存取、顺序存取以及映射存取。直接存储通过地址直接访问内存获取数据，数值属于这一类型；顺序存取通过对象的索引从 0 顺序访问内部元素，字符串、列表和元组都属于这一类型；映射存储与顺序存取类型，不同点在于它使用哈希键来访问数据，字典属于这一类型。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n直接访问       | 数值\n顺序访问       | 字符串、列表、元组\n映射访问       | 字典\n\n> 文中使用这么多的模型对数据类型分类，将基本类型和扩展类型进行区别，描述了各种类型的具体特征。简而言之，文中调侃了一句话：“一个优秀的工匠应该知道自己的工具箱有什么宝贝”。\n\n## JavaScript\n\nECMAScript 规范中定义了变量的两种类型：原始值类型和引用值类型。用以区分的依据就是它们在内存中的存储类型：值存储和址存储。\n\n为什么要分值和地址两种方式？一般而言，值存储的变量（原始值类型）都具有占据空间小、大小固定的特点。只有 string 是个特例，虽然它不具备大小固定的要求，但它是不可变的，是稳定而又会被频繁调用的。在其他语言中，string 大多是可变的。\n\n址存储的类型，具有占据空间大、大小不固定的特点，因此如果使用值存储的方式放在内存中，将会影响程序运行的性能。","source":"_posts/数据类型的分类.md","raw":"title: 数据类型的分类\ndate: 2015-11-15 19:29:36\n---\n\n开始写作本文的时候，我已经顺利地度过了四个月的前端实习生活，其间经手的项目勉强称得上稳定和健壮。但是刚刚学习前端的那些日子，可没现在这么自信，回想起来仍然颇多感慨。\n\n《JavaScript 典型应用与最佳实践》是我学习 JavaScript 的启蒙书籍，初版于 2008 年，面色古老而又心思缜密。其中的原始值和引用值一节，让我对 JavaScript 中数据类型的理解豁然开朗。如果从写作的角度看这本书，它的亮点在于以一种结构化的思维由浅入深地引导读者，主干和分支条缕清晰。有趣的是，在我用谷歌为结构化思维（Structed Thinking）查找一些理论依据的时候，链接到了一本更古老的书籍《金字塔原理：思考、写作和解决问题的逻辑》，书中介绍的正是作者自 1963 年以来反复实践的一套结构化思维，具体的细节等我读完后再聊吧。\n\n<!-- more -->\n\n最近项目中使用到的技术都比较激进，比如 ES6 / React / Flux 等等。在 ES6 的代码中你能看到诸多其他语言的影子，比如 Python，所以上一周我决定重新回顾一下 Python 中的要点，选用的参考资料是由 Wesley J. Chun 编写的《Python 核心编程（第二版）》。\n\n当读到 4.8 节《标准类型的分类》时，我可以确定，这又是一次结构化思维在知识传播过程中华丽的表演。在高级程序设计语言中，数据类型是必不可少的一部分。理解一门语言的数据类型，也是最基础的一步。虽然下面的示例交错使用 Python 和 JavaScript，但其中所叙述的本质是具有广泛性的。\n\n## Python\n\nPython 中每个对象都有三个特性：id, type 和 value。这些特性在对象初始化时创建。Python 内建了多种数据类型，基本类型包括：\n\n- integer, long integer, float, complex number\n- string\n- list\n- tuple\n- dictionary\n\n对数据类型分类，可以让我们更清晰地理解类型之间的关系以及工作原理。首先，使用存储模型进行分类。存储类型的衡量标准就是看对象能保存多少个对象。对于只能存储单个基本类型的对象，我们称之为原子或标量存储；那些可以存储多个基本类型的对象，称之为容器存储。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n标量 / 原子存储| 数值、字符串\n容器类型       | 列表、元素、字典\n\n然后，使用更新模型进行分类，更新模型的分类依据是看对象是否允许多次赋值。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n可变类型       | 列表、字典\n不可变类型     | 数值、字符串、元组\n\n最后，使用访问模型进行分类，访问模型的分类依据是看访问方式：直接存取、顺序存取以及映射存取。直接存储通过地址直接访问内存获取数据，数值属于这一类型；顺序存取通过对象的索引从 0 顺序访问内部元素，字符串、列表和元组都属于这一类型；映射存储与顺序存取类型，不同点在于它使用哈希键来访问数据，字典属于这一类型。\n\n分类          | Python 类型\n:-----------:|:-------------------:\n直接访问       | 数值\n顺序访问       | 字符串、列表、元组\n映射访问       | 字典\n\n> 文中使用这么多的模型对数据类型分类，将基本类型和扩展类型进行区别，描述了各种类型的具体特征。简而言之，文中调侃了一句话：“一个优秀的工匠应该知道自己的工具箱有什么宝贝”。\n\n## JavaScript\n\nECMAScript 规范中定义了变量的两种类型：原始值类型和引用值类型。用以区分的依据就是它们在内存中的存储类型：值存储和址存储。\n\n为什么要分值和地址两种方式？一般而言，值存储的变量（原始值类型）都具有占据空间小、大小固定的特点。只有 string 是个特例，虽然它不具备大小固定的要求，但它是不可变的，是稳定而又会被频繁调用的。在其他语言中，string 大多是可变的。\n\n址存储的类型，具有占据空间大、大小不固定的特点，因此如果使用值存储的方式放在内存中，将会影响程序运行的性能。","slug":"数据类型的分类","published":1,"updated":"2015-11-22T11:32:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0ow000160difhft3h5v"},{"title":"void and undefined","date":"2015-11-30T12:18:37.000Z","_content":"\n一直以来，`undefined` 都不是 JavaScript 的关键字或保留字，这意味着我们可以修改 window.undefined 的值。由于 undefined 会被频繁调用作为比较运算的操作数，所以在 ES5 规范之后，window.undefined 被定义为不可写、不可配置的属性。常见的 undefined 列述如下:\n\n- 变量声明后未赋值，则变量会被自动赋值为 undefined\n- 函数中定义了一些形参，如果传入的实参少于预定义的形参，那么有一些形参就会匹配不到实参，继而会被自动赋值为 undefined\n- 没有返回值的函数，默认返回 undefined\n\n`void (expression)`，void 作为一个运算符，无论表达式的内容是什么，只要跟在 void 之后都会被调用执行，执行完毕后 void 操作符返回 undefined。简而言之，使用 void 运算符有三种用处：生成 undefined；让函数立即执行；充当 `javascript:` 协议的 URI。\n\n<!-- more -->\n\n## 生成 undefined\n\n使用 `void 0` 生成 undefined 的做法由来已久，既减少了在原形链上查找 window.undefined 的时间，也避免了误用被修改过的 undefined。\n\n```js\nfunction checkLogin (loginName) {\n    if (loginName === void 0) {\n        console.log('Wrong!');\n    } \n}\n\ncheckLogin();\n// => 'Wrong!'\n```\n\n## 立即执行函数\n\n**运算符和函数组合使用，可以让函数立即执行。**实际上，有许多运算符可以让函数立即执行，比如 +、-、!、~ 以及本文提到的 void 等运算符。此外，还有最常见的小括号（分组运算符）：\n\n```js\n(function(){\n    console.log('立即执行');\n})();\n// => '立即执行'\n```\n\n## 充当 `javascript:` 协议的 URI\n\n对于网页中的点赞、收藏等按钮，如果使用 a 标签来实现的话，往往会用到 `href=\"javascript:void(0)\"` 等类似的代码，这段代码的作用是点击链接时让页面不跳转。\n\n在 href=\"javascript:void(0)\" 中，使用了一个以 `javascript:` 协议开头的 URI，浏览器默认会对冒号后面的代码求值，然后将结果显示在新的页面，但有一种情况例外，如果结果是 undefined，浏览器就不会刷新页面渲染新值了。\n\n实际上，我们有很多方式实现点赞、收藏的效果，无需使用这么 Hack 的方式——虽然这确实很方便。\n\n> `javascript:` 协议声明了 URL 的主体是任意的 javascript 代码，由 javascript 解释器编译执行，通常使用 `javascript:URL` 执行某些不改变当前页面文档的代码，要做到这一点，必须确保 URL 的最后一条语句没有返回值，比如使用 `void 0`。\n\n## 参考资料\n\n- [undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)\n- [void 运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\n- [谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)\n- [JavaScript中伪协议 javascript:使用探讨](http://www.jb51.net/article/52358.htm)","source":"_posts/void-and-undefined.md","raw":"title: void and undefined\ndate: 2015-11-30 20:18:37\n---\n\n一直以来，`undefined` 都不是 JavaScript 的关键字或保留字，这意味着我们可以修改 window.undefined 的值。由于 undefined 会被频繁调用作为比较运算的操作数，所以在 ES5 规范之后，window.undefined 被定义为不可写、不可配置的属性。常见的 undefined 列述如下:\n\n- 变量声明后未赋值，则变量会被自动赋值为 undefined\n- 函数中定义了一些形参，如果传入的实参少于预定义的形参，那么有一些形参就会匹配不到实参，继而会被自动赋值为 undefined\n- 没有返回值的函数，默认返回 undefined\n\n`void (expression)`，void 作为一个运算符，无论表达式的内容是什么，只要跟在 void 之后都会被调用执行，执行完毕后 void 操作符返回 undefined。简而言之，使用 void 运算符有三种用处：生成 undefined；让函数立即执行；充当 `javascript:` 协议的 URI。\n\n<!-- more -->\n\n## 生成 undefined\n\n使用 `void 0` 生成 undefined 的做法由来已久，既减少了在原形链上查找 window.undefined 的时间，也避免了误用被修改过的 undefined。\n\n```js\nfunction checkLogin (loginName) {\n    if (loginName === void 0) {\n        console.log('Wrong!');\n    } \n}\n\ncheckLogin();\n// => 'Wrong!'\n```\n\n## 立即执行函数\n\n**运算符和函数组合使用，可以让函数立即执行。**实际上，有许多运算符可以让函数立即执行，比如 +、-、!、~ 以及本文提到的 void 等运算符。此外，还有最常见的小括号（分组运算符）：\n\n```js\n(function(){\n    console.log('立即执行');\n})();\n// => '立即执行'\n```\n\n## 充当 `javascript:` 协议的 URI\n\n对于网页中的点赞、收藏等按钮，如果使用 a 标签来实现的话，往往会用到 `href=\"javascript:void(0)\"` 等类似的代码，这段代码的作用是点击链接时让页面不跳转。\n\n在 href=\"javascript:void(0)\" 中，使用了一个以 `javascript:` 协议开头的 URI，浏览器默认会对冒号后面的代码求值，然后将结果显示在新的页面，但有一种情况例外，如果结果是 undefined，浏览器就不会刷新页面渲染新值了。\n\n实际上，我们有很多方式实现点赞、收藏的效果，无需使用这么 Hack 的方式——虽然这确实很方便。\n\n> `javascript:` 协议声明了 URL 的主体是任意的 javascript 代码，由 javascript 解释器编译执行，通常使用 `javascript:URL` 执行某些不改变当前页面文档的代码，要做到这一点，必须确保 URL 的最后一条语句没有返回值，比如使用 `void 0`。\n\n## 参考资料\n\n- [undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)\n- [void 运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void)\n- [谈谈Javascript中的void操作符](http://segmentfault.com/a/1190000000474941)\n- [JavaScript中伪协议 javascript:使用探讨](http://www.jb51.net/article/52358.htm)","slug":"void-and-undefined","published":1,"updated":"2015-11-30T12:39:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0ox000260dibs66zlof"},{"title":"inline* and absolute","date":"2015-12-06T03:32:17.000Z","_content":"\n在一个容器中，所有元素都是 inline / inline-block 类型，此时可以使用 absolute + margin 的方式实现相对定位，而且相对定位的位置就是脱离文档流之前的位置。\n\n![absolute and margin](https://cloud.githubusercontent.com/assets/9530963/11618643/7fe8737c-9cd8-11e5-9919-e47705faa3c7.png)\n\n<!-- more -->\n\n###### 在线示例\n\n- [absolute and marign](http://codepen.io/pinggod/pen/WrNJmE)","source":"_posts/inline-and-absolute.md","raw":"title: 'inline* and absolute'\ndate: 2015-12-06 11:32:17\n---\n\n在一个容器中，所有元素都是 inline / inline-block 类型，此时可以使用 absolute + margin 的方式实现相对定位，而且相对定位的位置就是脱离文档流之前的位置。\n\n![absolute and margin](https://cloud.githubusercontent.com/assets/9530963/11618643/7fe8737c-9cd8-11e5-9919-e47705faa3c7.png)\n\n<!-- more -->\n\n###### 在线示例\n\n- [absolute and marign](http://codepen.io/pinggod/pen/WrNJmE)","slug":"inline-and-absolute","published":1,"updated":"2015-12-07T03:51:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0oz000360dimpqbbf7o"},{"title":"Sass","date":"2015-11-19T09:19:52.000Z","_content":"\n从 [Ben Frain](http://benfrain.com/) 的书中可以看出，他是一个勇于实践、善于学习的开发者。一直以来都很关注他的动态，当他的新书《Sass 和 Compass 设计师指南》初版时，就迫不及待地入手了，这是我和 Sass 的第一次见面。后来机缘巧合翻译了 [Sass Guidelines](http://sass-guidelin.es/zh) 和其它一些颇具实践性的 Sass 文章，零零散散至今大概有了一年的时间。\n\n以前的翻译专注于“学习”，在这篇文章之后，我将会分配更多的精力到“实践”中，做一些共享性的库或工具回馈社区。\n\n<div class=\"tip\">\n    预处理器很强大，但它只是编写 CSS 的辅助工具。出于对扩展和维护等方面的考虑，在大型项目中有必要使用预处理器构建 CSS；但是对于小型项目，原生的 CSS 可能是一种更好的选择。不要肆意使用预处理器！\n</div>\n\n<!-- more -->\n\n## Quick Start\n\nSass 扩展了 CSS 的现有语法，并提供了一些新的语法糖。在下面的简短代码中，集合了 Sass 中最常用的模块引用 `@import`、变量和嵌套：\n\n```scss\n// 设置字符集\n@charset \"UTF-8\";\n\n// 引入模块\n@import \"reset\";\n\n// 创建变量\n$primary-color: #333;\n\n// 嵌套\nbody {\n    color: $primary-color;\n    ul {\n        list-style-type: none;\n    }\n}\n```\n\n## 插值字符串\n\nSass 中的插值字符串 `#{$var}` 有两方面的作用：动态拼接字符串和去除字符串首尾的引号。示例如下：\n\n```scss\n@mixin header($tag) {\n    #{$tag}:before {\n        content: \"#{$tag}\";\n        // 等同于 content: $tag;\n    }\n}\n\n.post-content {\n    @include header(\"h1\");\n}\n```\n\n编译结果：\n\n```css\n.post-content h1:before {\n    content: \"h1\";\n}\n```\n\n## 父级引用符：`&`\n\n可以将父级引用符 `&` 看做是一个值为父级选择器的插值语法：\n\n```scss\na {\n    text-decoration: none;\n    &:hover {\n        text-decoration: underline;\n    }\n}\n```\n\n编译结果：\n\n```css\na {\n    text-decoration: none;\n}\n\na:hover {\n    text-decoration: underline;\n}\n```\n\n## 占位符选择器\n\n占位符选择器是 Sass 特有的一种选择器，声明时以 `%` 开头，编译时不会输出到 CSS 文件中，主要用于抽象组件的公共部分，配合 `@extend` 指令实现样式的继承机制：\n\n```scss\n%font {\n    font-size: 14px;\n    font-family: \"Source Sans Pro\";\n}\n\nbody {\n    @extend %font;\n}\n```\n\n编译结果：\n\n```css\nbody {\n    font-size: 14px;\n    font-family: \"Source Sans Pro\";\n}\n```\n\n## 数据类型\n\n- 字符串 (string): \"foo\", foo\n- 数值 (number): 1.3, 13, 10px\n- 列表 (list): ( 1.5em 1em 0 2em, Helvetica, Arial, sa ns-serif )\n- 映射 (map): ( key1: value1, key2: value2 )\n- 颜色值 (color): blue, #FFFFFF, rgb, hsl, rgba, hsla\n- 布尔值 (bool): true, false\n- 空类型 (null): null\n\n## 操作符\n\n- 赋值 `:`\n- 计算 `+`、`-`、`*`、`/`、`%`\n- 比较 `==`、`!=`、`>`、`>=`、`<`、`<=`\n- 逻辑 `and`、`or`、`not`\n\n其中，`+` 除了用作算术运算之外，也可以用于拼接字符串和求取颜色值。在 Sass 中字符串分为两种：引用字符串（quoted string，外部被引号包裹）和未引用字符串（unquoted string，外部没有引号）。使用 `+` 拼接字符串时，最终生成的字符串类型为第一个运算子的字符串类型：\n\n```scss\nbody {\n    font-family: \"Source Sans \" + TC;\n    p {\n        font-family: sans- + \"serif\";\n    }\n}\n```\n\n编译结果：\n\n```css\nbody {\n  font-family: \"Source Sans TC\";\n}\n\nbody p {\n  font-family: sans-serif;\n}\n```\n\n使用 `+` 求取颜色值时，必须保证运算子具有相同的不透明度：\n\n```scss\nbody {\n    color: rgba(70, 132, 153, 1) + rgba(32, 68, 121, 1);\n    // => color: #66c8ff;\n\n    background-color: rgba(70, 132, 153, .9) + rgba(32, 68, 121, .7);\n    // alpha channels must be equal when combining colors \n    // 报错：不透明通道值必须相等\n}\n```\n\n<div class=\"tip\">\n    `/` 在 CSS 中是有意义的，为了避免和 Sass 除法运算的混淆，所有的除法操作都应该使用小括号 `()` 包裹，比如使用 `font-size: (10px / 2)` 产出 `font-size: 5px`。\n</div>\n\n## 变量标识符\n\nSass 中的变量有三种身份：普通变量、默认值变量（`!default`）和全局变量（`!global`），而且这些变量具有作用域的概念，每个代码块 `{}` 内一个作用域，整个代码文件内也有一个作用域。\n\n当我们引用普通变量时，Sass 首先会从当前作用域开始检索变量，如果找不到就上溯到父级作用域，直到递归到最顶层的作用域：\n\n```scss\n$color: orange;\n\ndiv {\n    // 对 $color 重新赋值\n    $color: blue;\n    color: $color;\n    p {\n        color: $color;\n    }\n}\n\na {\n    color: $color;\n}\n```\n\n编译结果：\n\n```css\ndiv {\n  color: blue;\n}\n\ndiv p {\n  color: blue;\n}\n\na {\n  color: orange;\n}\n```\n\n> 默认值变量往往用于主题的配置文件，起到标识默认值，方便后续的重写覆盖。在最顶层作用域下，变量默认具有全局性，此时使用 `!global` 并没有实际意义；在块级作用域中，可以通过 `!global` 将变量提升为全局变量，但这么做势必降低代码的可维护性，所以目前全局变量显得有些鸡肋。\n\n## `@` 指令\n\n- @import 模块引用\n- @media 媒体查询\n- @extend 选择器继承\n- @at-root 嵌套提取\n- @debug / @warn / @error 异常和测试\n\n`@extend` 的强大无可置疑，但是复杂性也一直为人诟病，稍微控制不当就会生成冗余的选择器。归根结底，使用 `@extend` 是为了继承组件的公有样式，所以在不影响功能的基础上，应该适当的束缚它的能力。到目前为止，最优秀的实践方式就是 `@extend` 搭配占位符选择器。\n\n```scss\n%btn {\n    color: white;\n    font-size: 20px;\n}\n\n.btn-danger {\n    @extend %btn;\n    background-color: red;\n}\n\n.btn-default {\n    @extend %btn;\n    background-color: gray;\n}\n```\n\n编译结果：\n\n```css\n.btn-danger, .btn-default {\n    color: white;\n    font-size: 20px;\n}\n\n.btn-danger {\n    background-color: red;\n}\n\n.btn-default {\n    background-color: gray;\n}\n```\n\n在这个组合中，占位符选择器本身不会被编译到 CSS 文件中，可以节省文件体积，而且 `@extend` 只继承了单一的占位符选择器，杜绝了选择器泛滥。此外，相比起 `@mixin` 来，`@extend` 搭配占位符选择器生成的结果会聚合在同一个样式集中：\n\n![@extend vs @mixin](https://cloud.githubusercontent.com/assets/9530963/11413823/93e5c6ee-9428-11e5-9c5f-4c360bda8da8.png)\n\n> 如果再上升一个层次分工的话，那就需要比较一下 `@mixin` 和 `@extend`。这两种方式都可以生成公有样式，但是仅此而已就是浪费了 `@mixin` 的能力。就目前的最佳实践来说，建议使用 `@extend` 搭配占位符选择器继承公有样式，使用 `@mixin` 产出动态样式。`@mixin` 的详细介绍见后续小节。\n\n\n## 控制指令\n\n- @if ... @else if ... @else ... 条件判断\n- @for $var from start through end [start, end] 循环\n- @for $var from start to end [start, end) 循环\n- @each ... in ... 遍历\n- @while\n\n`@each` 可以用来遍历 list 和 map 类型的数据，示例如下：\n\n```scss\n$btn: (\n    danger: red, \n    primary: blue, \n    warning: orange\n);\n\n@each $type, $color in $btn {\n    .btn-#{$type} {\n        color: $color;\n    }\n}\n```\n\n编译结果：\n\n```css\n.btn-danger {\n    color: red;\n}\n\n.btn-primary {\n    color: blue;\n}\n\n.btn-warning {\n    color: orange;\n}\n```\n\n## 混合宏 `@mixin`\n\n在 `@extend` 部分已经介绍到 `@mixin` 的一个功能是生成公有样式，但事实上，建议你避开使用该功能，而是着眼于使用 `@mixin` 动态生成共有样式，更优雅地实现组件复用：\n\n```scss\n@mixin btn($fontSize, $borderRadius) {\n    font-size: $fontSize;\n    border-radius: $borderRadius;\n}\n\n.btn-sm {\n    @include btn(14px, 3px);\n}\n\n.btn-lg {\n    @include btn(18px, 5px);\n}\n```\n\n编译结果：\n\n```css\n.btn-sm {\n    font-size: 14px;\n    border-radius: 3px;\n}\n\n.btn-lg {\n    font-size: 18px;\n    border-radius: 5px;\n}\n```\n\n`@mixin` 的参数除了上面示例的普通参数，还包括默认值参数和不定参数。默认值参数通过提供默认样式，可以在参数缺失时，保障代码的健壮性：\n\n```scss\n@mixin btn($fontSize, $borderRadius: 5px) {\n    font-size: $fontSize;\n    border-radius: $borderRadius;\n}\n\n.btn-lg {\n    @include btn(18px);\n}\n```\n\n编译结果：\n\n```css\n.btn-lg {\n    font-size: 18px;\n    border-radius: 5px;\n}\n```\n\n不定参数可以保存零个或多个值，最常用的地方就是为同一属性添加多个值，比如多重阴影：\n\n```scss\n@mixin box-shadow($shadows...) {\n    -moz-box-shadow: $shadows;\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n}\n\n.shadows {\n    @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n编译结果：\n\n```css\n.shadows {\n    -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n    -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n    box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n}\n```\n\n此外，在传参时也可以使用不定参数：\n\n```scss\n@mixin colors($text, $background, $border) {\n    color: $text;\n    background-color: $background;\n    border-color: $border;\n}\n\n$values: #ff0000, #00ff00, #0000ff;\n.primary {\n    @include colors($values...);\n}\n\n$value-map: (text: #00ff00, background: #0000ff, border: #ff0000);\n.secondary {\n    @include colors($value-map...);\n}\n```\n\n编译结果：\n\n```css\n.primary {\n    color: #ff0000;\n    background-color: #00ff00;\n    border-color: #0000ff;\n}\n\n.secondary {\n    color: #00ff00;\n    background-color: #0000ff;\n    border-color: #ff0000;\n}\n```\n\n<div class=\"tip\">\n    在 `@mixin` 中配置参数时，先写普通参数，然后是默认值参数，最后是不定参数。\n</div>\n\n## 函数指令 `@function`\n\n相比起上面的继承和动态生成，`@function` 在生成方式上自由度更高。此外，还可以嵌套上面的各种指令和操作符，对数据进行筛选、在加工，生成特定样式。在下面的代码中，混合宏根据栅格的数量，动态生成容器的宽度：\n\n```scss\n$grid-width: 40px;\n$gutter-width: 10px;\n\n@function width($n) {\n    @return $n * $grid-width + ($n - 1) * $gutter-width;\n}\n\n.container { \n    width: width(5); \n}\n```\n\n编译结果：\n\n```css\n.container {\n    width: 240px;\n}\n```\n\n###### 参考资料\n\n- [Sass 内建函数](http://sass-lang.com/documentation/Sass/Script/Functions.html#blue-instance_method)","source":"_posts/Sass.md","raw":"title: Sass\ndate: 2015-11-19 17:19:52\ntags:\n---\n\n从 [Ben Frain](http://benfrain.com/) 的书中可以看出，他是一个勇于实践、善于学习的开发者。一直以来都很关注他的动态，当他的新书《Sass 和 Compass 设计师指南》初版时，就迫不及待地入手了，这是我和 Sass 的第一次见面。后来机缘巧合翻译了 [Sass Guidelines](http://sass-guidelin.es/zh) 和其它一些颇具实践性的 Sass 文章，零零散散至今大概有了一年的时间。\n\n以前的翻译专注于“学习”，在这篇文章之后，我将会分配更多的精力到“实践”中，做一些共享性的库或工具回馈社区。\n\n<div class=\"tip\">\n    预处理器很强大，但它只是编写 CSS 的辅助工具。出于对扩展和维护等方面的考虑，在大型项目中有必要使用预处理器构建 CSS；但是对于小型项目，原生的 CSS 可能是一种更好的选择。不要肆意使用预处理器！\n</div>\n\n<!-- more -->\n\n## Quick Start\n\nSass 扩展了 CSS 的现有语法，并提供了一些新的语法糖。在下面的简短代码中，集合了 Sass 中最常用的模块引用 `@import`、变量和嵌套：\n\n```scss\n// 设置字符集\n@charset \"UTF-8\";\n\n// 引入模块\n@import \"reset\";\n\n// 创建变量\n$primary-color: #333;\n\n// 嵌套\nbody {\n    color: $primary-color;\n    ul {\n        list-style-type: none;\n    }\n}\n```\n\n## 插值字符串\n\nSass 中的插值字符串 `#{$var}` 有两方面的作用：动态拼接字符串和去除字符串首尾的引号。示例如下：\n\n```scss\n@mixin header($tag) {\n    #{$tag}:before {\n        content: \"#{$tag}\";\n        // 等同于 content: $tag;\n    }\n}\n\n.post-content {\n    @include header(\"h1\");\n}\n```\n\n编译结果：\n\n```css\n.post-content h1:before {\n    content: \"h1\";\n}\n```\n\n## 父级引用符：`&`\n\n可以将父级引用符 `&` 看做是一个值为父级选择器的插值语法：\n\n```scss\na {\n    text-decoration: none;\n    &:hover {\n        text-decoration: underline;\n    }\n}\n```\n\n编译结果：\n\n```css\na {\n    text-decoration: none;\n}\n\na:hover {\n    text-decoration: underline;\n}\n```\n\n## 占位符选择器\n\n占位符选择器是 Sass 特有的一种选择器，声明时以 `%` 开头，编译时不会输出到 CSS 文件中，主要用于抽象组件的公共部分，配合 `@extend` 指令实现样式的继承机制：\n\n```scss\n%font {\n    font-size: 14px;\n    font-family: \"Source Sans Pro\";\n}\n\nbody {\n    @extend %font;\n}\n```\n\n编译结果：\n\n```css\nbody {\n    font-size: 14px;\n    font-family: \"Source Sans Pro\";\n}\n```\n\n## 数据类型\n\n- 字符串 (string): \"foo\", foo\n- 数值 (number): 1.3, 13, 10px\n- 列表 (list): ( 1.5em 1em 0 2em, Helvetica, Arial, sa ns-serif )\n- 映射 (map): ( key1: value1, key2: value2 )\n- 颜色值 (color): blue, #FFFFFF, rgb, hsl, rgba, hsla\n- 布尔值 (bool): true, false\n- 空类型 (null): null\n\n## 操作符\n\n- 赋值 `:`\n- 计算 `+`、`-`、`*`、`/`、`%`\n- 比较 `==`、`!=`、`>`、`>=`、`<`、`<=`\n- 逻辑 `and`、`or`、`not`\n\n其中，`+` 除了用作算术运算之外，也可以用于拼接字符串和求取颜色值。在 Sass 中字符串分为两种：引用字符串（quoted string，外部被引号包裹）和未引用字符串（unquoted string，外部没有引号）。使用 `+` 拼接字符串时，最终生成的字符串类型为第一个运算子的字符串类型：\n\n```scss\nbody {\n    font-family: \"Source Sans \" + TC;\n    p {\n        font-family: sans- + \"serif\";\n    }\n}\n```\n\n编译结果：\n\n```css\nbody {\n  font-family: \"Source Sans TC\";\n}\n\nbody p {\n  font-family: sans-serif;\n}\n```\n\n使用 `+` 求取颜色值时，必须保证运算子具有相同的不透明度：\n\n```scss\nbody {\n    color: rgba(70, 132, 153, 1) + rgba(32, 68, 121, 1);\n    // => color: #66c8ff;\n\n    background-color: rgba(70, 132, 153, .9) + rgba(32, 68, 121, .7);\n    // alpha channels must be equal when combining colors \n    // 报错：不透明通道值必须相等\n}\n```\n\n<div class=\"tip\">\n    `/` 在 CSS 中是有意义的，为了避免和 Sass 除法运算的混淆，所有的除法操作都应该使用小括号 `()` 包裹，比如使用 `font-size: (10px / 2)` 产出 `font-size: 5px`。\n</div>\n\n## 变量标识符\n\nSass 中的变量有三种身份：普通变量、默认值变量（`!default`）和全局变量（`!global`），而且这些变量具有作用域的概念，每个代码块 `{}` 内一个作用域，整个代码文件内也有一个作用域。\n\n当我们引用普通变量时，Sass 首先会从当前作用域开始检索变量，如果找不到就上溯到父级作用域，直到递归到最顶层的作用域：\n\n```scss\n$color: orange;\n\ndiv {\n    // 对 $color 重新赋值\n    $color: blue;\n    color: $color;\n    p {\n        color: $color;\n    }\n}\n\na {\n    color: $color;\n}\n```\n\n编译结果：\n\n```css\ndiv {\n  color: blue;\n}\n\ndiv p {\n  color: blue;\n}\n\na {\n  color: orange;\n}\n```\n\n> 默认值变量往往用于主题的配置文件，起到标识默认值，方便后续的重写覆盖。在最顶层作用域下，变量默认具有全局性，此时使用 `!global` 并没有实际意义；在块级作用域中，可以通过 `!global` 将变量提升为全局变量，但这么做势必降低代码的可维护性，所以目前全局变量显得有些鸡肋。\n\n## `@` 指令\n\n- @import 模块引用\n- @media 媒体查询\n- @extend 选择器继承\n- @at-root 嵌套提取\n- @debug / @warn / @error 异常和测试\n\n`@extend` 的强大无可置疑，但是复杂性也一直为人诟病，稍微控制不当就会生成冗余的选择器。归根结底，使用 `@extend` 是为了继承组件的公有样式，所以在不影响功能的基础上，应该适当的束缚它的能力。到目前为止，最优秀的实践方式就是 `@extend` 搭配占位符选择器。\n\n```scss\n%btn {\n    color: white;\n    font-size: 20px;\n}\n\n.btn-danger {\n    @extend %btn;\n    background-color: red;\n}\n\n.btn-default {\n    @extend %btn;\n    background-color: gray;\n}\n```\n\n编译结果：\n\n```css\n.btn-danger, .btn-default {\n    color: white;\n    font-size: 20px;\n}\n\n.btn-danger {\n    background-color: red;\n}\n\n.btn-default {\n    background-color: gray;\n}\n```\n\n在这个组合中，占位符选择器本身不会被编译到 CSS 文件中，可以节省文件体积，而且 `@extend` 只继承了单一的占位符选择器，杜绝了选择器泛滥。此外，相比起 `@mixin` 来，`@extend` 搭配占位符选择器生成的结果会聚合在同一个样式集中：\n\n![@extend vs @mixin](https://cloud.githubusercontent.com/assets/9530963/11413823/93e5c6ee-9428-11e5-9c5f-4c360bda8da8.png)\n\n> 如果再上升一个层次分工的话，那就需要比较一下 `@mixin` 和 `@extend`。这两种方式都可以生成公有样式，但是仅此而已就是浪费了 `@mixin` 的能力。就目前的最佳实践来说，建议使用 `@extend` 搭配占位符选择器继承公有样式，使用 `@mixin` 产出动态样式。`@mixin` 的详细介绍见后续小节。\n\n\n## 控制指令\n\n- @if ... @else if ... @else ... 条件判断\n- @for $var from start through end [start, end] 循环\n- @for $var from start to end [start, end) 循环\n- @each ... in ... 遍历\n- @while\n\n`@each` 可以用来遍历 list 和 map 类型的数据，示例如下：\n\n```scss\n$btn: (\n    danger: red, \n    primary: blue, \n    warning: orange\n);\n\n@each $type, $color in $btn {\n    .btn-#{$type} {\n        color: $color;\n    }\n}\n```\n\n编译结果：\n\n```css\n.btn-danger {\n    color: red;\n}\n\n.btn-primary {\n    color: blue;\n}\n\n.btn-warning {\n    color: orange;\n}\n```\n\n## 混合宏 `@mixin`\n\n在 `@extend` 部分已经介绍到 `@mixin` 的一个功能是生成公有样式，但事实上，建议你避开使用该功能，而是着眼于使用 `@mixin` 动态生成共有样式，更优雅地实现组件复用：\n\n```scss\n@mixin btn($fontSize, $borderRadius) {\n    font-size: $fontSize;\n    border-radius: $borderRadius;\n}\n\n.btn-sm {\n    @include btn(14px, 3px);\n}\n\n.btn-lg {\n    @include btn(18px, 5px);\n}\n```\n\n编译结果：\n\n```css\n.btn-sm {\n    font-size: 14px;\n    border-radius: 3px;\n}\n\n.btn-lg {\n    font-size: 18px;\n    border-radius: 5px;\n}\n```\n\n`@mixin` 的参数除了上面示例的普通参数，还包括默认值参数和不定参数。默认值参数通过提供默认样式，可以在参数缺失时，保障代码的健壮性：\n\n```scss\n@mixin btn($fontSize, $borderRadius: 5px) {\n    font-size: $fontSize;\n    border-radius: $borderRadius;\n}\n\n.btn-lg {\n    @include btn(18px);\n}\n```\n\n编译结果：\n\n```css\n.btn-lg {\n    font-size: 18px;\n    border-radius: 5px;\n}\n```\n\n不定参数可以保存零个或多个值，最常用的地方就是为同一属性添加多个值，比如多重阴影：\n\n```scss\n@mixin box-shadow($shadows...) {\n    -moz-box-shadow: $shadows;\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n}\n\n.shadows {\n    @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n编译结果：\n\n```css\n.shadows {\n    -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n    -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n    box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n}\n```\n\n此外，在传参时也可以使用不定参数：\n\n```scss\n@mixin colors($text, $background, $border) {\n    color: $text;\n    background-color: $background;\n    border-color: $border;\n}\n\n$values: #ff0000, #00ff00, #0000ff;\n.primary {\n    @include colors($values...);\n}\n\n$value-map: (text: #00ff00, background: #0000ff, border: #ff0000);\n.secondary {\n    @include colors($value-map...);\n}\n```\n\n编译结果：\n\n```css\n.primary {\n    color: #ff0000;\n    background-color: #00ff00;\n    border-color: #0000ff;\n}\n\n.secondary {\n    color: #00ff00;\n    background-color: #0000ff;\n    border-color: #ff0000;\n}\n```\n\n<div class=\"tip\">\n    在 `@mixin` 中配置参数时，先写普通参数，然后是默认值参数，最后是不定参数。\n</div>\n\n## 函数指令 `@function`\n\n相比起上面的继承和动态生成，`@function` 在生成方式上自由度更高。此外，还可以嵌套上面的各种指令和操作符，对数据进行筛选、在加工，生成特定样式。在下面的代码中，混合宏根据栅格的数量，动态生成容器的宽度：\n\n```scss\n$grid-width: 40px;\n$gutter-width: 10px;\n\n@function width($n) {\n    @return $n * $grid-width + ($n - 1) * $gutter-width;\n}\n\n.container { \n    width: width(5); \n}\n```\n\n编译结果：\n\n```css\n.container {\n    width: 240px;\n}\n```\n\n###### 参考资料\n\n- [Sass 内建函数](http://sass-lang.com/documentation/Sass/Script/Functions.html#blue-instance_method)","slug":"Sass","published":1,"updated":"2015-11-26T02:30:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0p1000460dixnrs3cvs"},{"title":"React 组件间的消息传递","date":"2015-11-28T10:34:42.000Z","_content":"\n当我们封装了可复用的组件之后，用来驱动组件渲染内容的数据就变得愈发灵活，组件之间数据通信的问题就摆在了桌面上。React 组件间的消息传递主要集中于三种关系中：\n\n- 从父组件向子组件的消息传递\n- 从子组件向父组件的消息传递\n- 无关联组件之间的消息传递\n\n前两种关系都可以使用 React 内建的 `this.props` 对象来处理：\n\n![父子组件之间的消息传递](https://cloud.githubusercontent.com/assets/9530963/11470593/0647f04e-979a-11e5-9c1c-883f5825f9e2.png)\n\n<!-- more -->\n\n## 无关联组件之间的消息传递\n\n这里的“无关联”，是指两个组件既不是父子关系，也不是兄弟关系。对于这种关系，可以用一个简单的发布订阅模型来实现，这种模型又被称为观察者模式。\n\n这里选用的是基于全局对象的发布订阅模型，需要自定义事件名称：\n\n```js\n// 事件集合\nlet events = {};\n\n// 发布事件\nconst trigger = (event, ...data) => {\n    const fns = events[event];\n\n    // 如果没有对应方法\n    if (!fns || fns.length === 0) {\n        return false;\n    }\n    // 如果存在对应方法，依次执行\n    for ( let i = 0; i <= fns.length - 1; i++) {\n        fns[i](...data);\n    }\n};\n\n// 监听事件\nconst on = (event, fn) => {\n    // 如果尚没有该事件，创建一个数组来存储对应的方法\n    if (!events[event]) {\n        events[event] = [];\n    }\n    events[event].push(fn);\n};\n\n// 取消监听事件\nconst off = (event, fn) => {\n    const fns = events[event];\n\n    // 如果不存在事件集合\n    if (!fns) {\n        return false;\n    }\n    // 如果不存在事件\n    if (!fn && fns) {\n        fns.length = 0;\n    }\n    // 取消指定事件\n    else {\n        for (let i = fns.length - 1; i >= 0; i--) {\n            if (fn === fns[i]) {\n                fns.splice(i, 1);\n            }\n        }\n    }\n};\n\nconst PubSub = {\n    on: on,\n    off: off,\n    trigger: trigger\n};\n\nexport default PubSub;\n```","source":"_posts/React-组件间的消息传递.md","raw":"title: React 组件间的消息传递\ndate: 2015-11-28 18:34:42\n---\n\n当我们封装了可复用的组件之后，用来驱动组件渲染内容的数据就变得愈发灵活，组件之间数据通信的问题就摆在了桌面上。React 组件间的消息传递主要集中于三种关系中：\n\n- 从父组件向子组件的消息传递\n- 从子组件向父组件的消息传递\n- 无关联组件之间的消息传递\n\n前两种关系都可以使用 React 内建的 `this.props` 对象来处理：\n\n![父子组件之间的消息传递](https://cloud.githubusercontent.com/assets/9530963/11470593/0647f04e-979a-11e5-9c1c-883f5825f9e2.png)\n\n<!-- more -->\n\n## 无关联组件之间的消息传递\n\n这里的“无关联”，是指两个组件既不是父子关系，也不是兄弟关系。对于这种关系，可以用一个简单的发布订阅模型来实现，这种模型又被称为观察者模式。\n\n这里选用的是基于全局对象的发布订阅模型，需要自定义事件名称：\n\n```js\n// 事件集合\nlet events = {};\n\n// 发布事件\nconst trigger = (event, ...data) => {\n    const fns = events[event];\n\n    // 如果没有对应方法\n    if (!fns || fns.length === 0) {\n        return false;\n    }\n    // 如果存在对应方法，依次执行\n    for ( let i = 0; i <= fns.length - 1; i++) {\n        fns[i](...data);\n    }\n};\n\n// 监听事件\nconst on = (event, fn) => {\n    // 如果尚没有该事件，创建一个数组来存储对应的方法\n    if (!events[event]) {\n        events[event] = [];\n    }\n    events[event].push(fn);\n};\n\n// 取消监听事件\nconst off = (event, fn) => {\n    const fns = events[event];\n\n    // 如果不存在事件集合\n    if (!fns) {\n        return false;\n    }\n    // 如果不存在事件\n    if (!fn && fns) {\n        fns.length = 0;\n    }\n    // 取消指定事件\n    else {\n        for (let i = fns.length - 1; i >= 0; i--) {\n            if (fn === fns[i]) {\n                fns.splice(i, 1);\n            }\n        }\n    }\n};\n\nconst PubSub = {\n    on: on,\n    off: off,\n    trigger: trigger\n};\n\nexport default PubSub;\n```","slug":"React-组件间的消息传递","published":1,"updated":"2015-11-30T11:40:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0p3000560dirks2eb26"},{"title":"React 组件的生命周期","date":"2015-11-23T01:56:00.000Z","_content":"\n在 React 所实践的组件化中，非常重要的一点就是组件的生命周期，简而言之是组件的挂载、更新和卸载流程。下图详细列述了 React 组件在整个生命周期中所涉及的方法和行为：\n\n![React 组件的生命周期](https://cloud.githubusercontent.com/assets/9530963/11421184/409f144a-946e-11e5-8132-3f65ba56aab9.png)\n\n<!-- more -->\n\n在组件实例创建之初，会依序调用 `getDefaultProps()`、`getInitialState()` 方法初始化数据。在 ES6 中，可以简写为：\n\n```js\nstatic defaultProps = {\n    key: value\n};\n\nstate = {\n    key: value\n};\n```\n\n对于从父组件传递来的 props，React 提供了 `propTypes` 配置对象来校验数据类型或格式，常用类型如下：\n\n```js\n// 布尔值\nReact.PropTypes.bool                              \n// 数值\nReact.PropTypes.number                            \n// 字符串\nReact.PropTypes.string                            \n// 函数\nReact.PropTypes.func                              \n// 数组\nReact.PropTypes.array                             \n// 对象\nReact.PropTypes.object                            \n// 数值、字符串、DOM 元素及包含这些类型的数组\nReact.PropTypes.node                              \n// React 元素\nReact.PropTypes.element                           \n// 对象实例\nReact.PropTypes.instanceOf(Message)               \n// 数组包含的值之一\nReact.PropTypes.oneOf(['News' 'Photos'])          \n// 数组包含的类型之一\nReact.PropTypes.oneOfType([                       \n    React.PropTypes.string,         \n    React.PropTypes.number,         \n    React.PropTypes.instanceOf(Message)                                  \n])                                               \n// 数值数组\nReact.PropTypes.arrayOf(React.PropTypes.number)   \n// 对象的属性值为数值类型\nReact.PropTypes.objectOf(React.PropTypes.number)  \n// 组合类型\nReact.PropTypes.shape({                           \n    React.PropTypes.string                                   \n    React.PropTypes.number                                   \n})                                                 \n// 任何类型，必填\nReact.PropTypes.any.isRequired                    \n// 自定义规则\ncustomProp: function(props propName componentName) {\n    if (!/matchme/.test(props[propName])) {\n        return new Error('Validation failed!');\n    }\n}\n```\n\n## mount\n\n在组件的挂载过程中，会依次调用 componentWillMount()、render() 和 componentDidMount()。挂载完成后，`componentWillMount()` 和 `componentDidMount()` 将不会再被触发，`render()` 则会根据 props 和 state 的变化多次执行。\n\n在 componentDidMount() 调用之前，只能得到由 render() 返回的虚拟 DOM；在该方法执行时，真实 DOM 的渲染已经完成，此时，可以通过 React 内建的 `getDOMNode()` 访问真实的 DOM。\n\n## update\n\n挂载结束后，组件处于监听状态，监听 props 和 state 的变化。props 和 state 的差异在于：state 用于配置组件内的状态，props 则用于在组件间传递数据。\n\n在实际开发中，这一阶段调用的核心都是围绕 state 展开的。state changed 之后，系统会立即调用 `boolean shouldComponentUpdate(object nextProps, object nextState)` 方法来决定是否重新渲染页面。当遭遇性能瓶颈时，适当地通过该方法控制页面渲染的频率是为提升性能不二法门。\n\n当 props changed 时，系统会立即调用 `componentWillReciveProps(object nextProps)` 方法。该方法常被用来执行 props -> state 的更新，继而触发整个页面的渲染。\n\n在这一阶段重新渲染页面所需要的同样是 will -> render -> did 三个方法。不同之处在于，此处的 did 和 will 附加了 props 和 state 信息：\n\n```js\ncomponentWillUpdate(object nextProps, object nextState) {\n    ...\n}\n\ncomponentDidUpdate(object prevProps, object prevState) {\n    ...\n}\n```\n\n## unmount\n\n组件卸载前会执行 `componentWillUnmount()`，用于清理 `componentDidMount()` 之后创建的组件。此外，对于组件生命周期内累积的监听事件和定时器，也应当在该方法内执行解绑、清除操作。\n\n## 组件化\n\n目前组内正在构建一套 React 基础组件，方法和思路与 AlloyTeam [《致我们终将组件化的 Web》](http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/)一文类似。其中，作者对组件提出了五点要求，如下图所示，值得参考：\n\n![组件化的要求](https://cloud.githubusercontent.com/assets/9530963/11451335/7cd052fe-95fd-11e5-8120-d094eb4ee823.png)\n\n其中“规范化的接口”，也可更改为可管理的生命周期。","source":"_posts/React-组件的生命周期.md","raw":"title: React 组件的生命周期\ndate: 2015-11-23 09:56:00\n---\n\n在 React 所实践的组件化中，非常重要的一点就是组件的生命周期，简而言之是组件的挂载、更新和卸载流程。下图详细列述了 React 组件在整个生命周期中所涉及的方法和行为：\n\n![React 组件的生命周期](https://cloud.githubusercontent.com/assets/9530963/11421184/409f144a-946e-11e5-8132-3f65ba56aab9.png)\n\n<!-- more -->\n\n在组件实例创建之初，会依序调用 `getDefaultProps()`、`getInitialState()` 方法初始化数据。在 ES6 中，可以简写为：\n\n```js\nstatic defaultProps = {\n    key: value\n};\n\nstate = {\n    key: value\n};\n```\n\n对于从父组件传递来的 props，React 提供了 `propTypes` 配置对象来校验数据类型或格式，常用类型如下：\n\n```js\n// 布尔值\nReact.PropTypes.bool                              \n// 数值\nReact.PropTypes.number                            \n// 字符串\nReact.PropTypes.string                            \n// 函数\nReact.PropTypes.func                              \n// 数组\nReact.PropTypes.array                             \n// 对象\nReact.PropTypes.object                            \n// 数值、字符串、DOM 元素及包含这些类型的数组\nReact.PropTypes.node                              \n// React 元素\nReact.PropTypes.element                           \n// 对象实例\nReact.PropTypes.instanceOf(Message)               \n// 数组包含的值之一\nReact.PropTypes.oneOf(['News' 'Photos'])          \n// 数组包含的类型之一\nReact.PropTypes.oneOfType([                       \n    React.PropTypes.string,         \n    React.PropTypes.number,         \n    React.PropTypes.instanceOf(Message)                                  \n])                                               \n// 数值数组\nReact.PropTypes.arrayOf(React.PropTypes.number)   \n// 对象的属性值为数值类型\nReact.PropTypes.objectOf(React.PropTypes.number)  \n// 组合类型\nReact.PropTypes.shape({                           \n    React.PropTypes.string                                   \n    React.PropTypes.number                                   \n})                                                 \n// 任何类型，必填\nReact.PropTypes.any.isRequired                    \n// 自定义规则\ncustomProp: function(props propName componentName) {\n    if (!/matchme/.test(props[propName])) {\n        return new Error('Validation failed!');\n    }\n}\n```\n\n## mount\n\n在组件的挂载过程中，会依次调用 componentWillMount()、render() 和 componentDidMount()。挂载完成后，`componentWillMount()` 和 `componentDidMount()` 将不会再被触发，`render()` 则会根据 props 和 state 的变化多次执行。\n\n在 componentDidMount() 调用之前，只能得到由 render() 返回的虚拟 DOM；在该方法执行时，真实 DOM 的渲染已经完成，此时，可以通过 React 内建的 `getDOMNode()` 访问真实的 DOM。\n\n## update\n\n挂载结束后，组件处于监听状态，监听 props 和 state 的变化。props 和 state 的差异在于：state 用于配置组件内的状态，props 则用于在组件间传递数据。\n\n在实际开发中，这一阶段调用的核心都是围绕 state 展开的。state changed 之后，系统会立即调用 `boolean shouldComponentUpdate(object nextProps, object nextState)` 方法来决定是否重新渲染页面。当遭遇性能瓶颈时，适当地通过该方法控制页面渲染的频率是为提升性能不二法门。\n\n当 props changed 时，系统会立即调用 `componentWillReciveProps(object nextProps)` 方法。该方法常被用来执行 props -> state 的更新，继而触发整个页面的渲染。\n\n在这一阶段重新渲染页面所需要的同样是 will -> render -> did 三个方法。不同之处在于，此处的 did 和 will 附加了 props 和 state 信息：\n\n```js\ncomponentWillUpdate(object nextProps, object nextState) {\n    ...\n}\n\ncomponentDidUpdate(object prevProps, object prevState) {\n    ...\n}\n```\n\n## unmount\n\n组件卸载前会执行 `componentWillUnmount()`，用于清理 `componentDidMount()` 之后创建的组件。此外，对于组件生命周期内累积的监听事件和定时器，也应当在该方法内执行解绑、清除操作。\n\n## 组件化\n\n目前组内正在构建一套 React 基础组件，方法和思路与 AlloyTeam [《致我们终将组件化的 Web》](http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/)一文类似。其中，作者对组件提出了五点要求，如下图所示，值得参考：\n\n![组件化的要求](https://cloud.githubusercontent.com/assets/9530963/11451335/7cd052fe-95fd-11e5-8120-d094eb4ee823.png)\n\n其中“规范化的接口”，也可更改为可管理的生命周期。","slug":"React-组件的生命周期","published":1,"updated":"2015-11-28T10:29:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0p4000660dilti1znw2"},{"title":"Jade","date":"2015-12-03T05:24:27.000Z","_content":"\n如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Jade 也会是你的菜。Jade 类似于 Python，都采用了对缩进敏感的语法形式，比如下面这段代码创建了一个无序列表：\n\n```javascript\nul(class=\"inline\")\n    li  Item C\n    li  Item A\n    li  Item B\n```\n\n\n<!-- more -->\n\n\n## 属性\n\nJade 的另一大特点就是和 JavaScript 的融合度很高，比如设置属性：\n\n```javascript\n- var authenticated = true\nbody(class= authenticated ? 'authed' : 'anon')\n- var currentUrl = '/about'\na(class={active: currentUrl === '/'} href='/') Home\na(class={active: currentUrl === '/about'} href='/about') About\n```\n\n此外，给标签设置行内样式时，需要以对象的形式赋值给 style：\n\n```javascript\na(style={color: 'red', background: 'green'})\n```\n\n## 插值\n\nJade 提供了字符串插值和标签插值。其中，字符串插值由于要考虑到安全性问题，所以又分成了转义和不转义两种情况：\n\n```javascript\n// 转义插值 #{}\n- var theGreat = \"<span>escape!</span>\";\np This will be safe: #{theGreat}\n\n// 不转义插值 !{}\n- var theGreat = \"<span>escape!</span>\";\np This will be safe: !{theGreat}\n\n// 标签插值\np #[a(href=\"jade-lang.com\") Jade]\n```\n\n编译结果：\n\n```html\n<!-- 转义插值 #{}-->\n<p>This will be safe: &lt;span&gt;escape!&lt;/span&gt;</p>\n\n<!-- 不转义插值 !{}-->\n<p>This will be safe: <span>escape!</span></p>\n\n<!-- 标签插值-->\n<p><a href=\"jade-lang.com\">Jade</a></p>\n```\n\n## 逻辑语句\n\nJade 提供了条件、分支、循环、遍历四种逻辑语句，这四种语句继承自 JavaScript，只是语法上有些差异:\n\n- 条件语句：if ... else if ... else\n- 分支语句：case ... when ... default\n- 循环语句：while\n- 遍历数组：each $elem in [elem...]\n- 遍历对象：each $key, $value in {key: value}\n\n```javascript\n// 分支语句\n- var friends = 10\ncase friends\n    when 0\n        p you have no friends\n    when 1\n        p you have a friend\n    default\n        p you have #{friends} friends\n```\n\n## mixin\n\nJade 和 Sass 都提供了 mixin 语法来实现代码的复用，两者语法也很相似：\n\n```javascript\nmixin list(id, ...items)\n    ul(id=id)\n        each item in items\n            li= item\n\n+list('my-list', 1, 2, 3, 4)\n```\n\nmixin 一般放在独立的文件中，需要使用 `include` 指令导入到其他文件中。\n\n## extends\n\n`extends` 是 Jade 的模板继承语法，通过 `extends filename.jade` 可以将模板文件导入到其他文件中。继承机制基本上是一个复制代码片段的过程，为了能够动态修改其中的部分内容，Jade 提供了 `block` 语法：\n\n```javascript\n// 声明 block\nblock content\n    p Hello\n\n// 修改 block\n// 同名重新赋值\nblock content\n    p Hi\n\n// 前置追加\nblock append content\n    p APPEND\n\n// 后置追加\nblock prepend content\n    p PREPEND\n```\n","source":"_posts/Jade.md","raw":"title: Jade\ndate: 2015-12-03 13:24:27\n---\n\n如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Jade 也会是你的菜。Jade 类似于 Python，都采用了对缩进敏感的语法形式，比如下面这段代码创建了一个无序列表：\n\n```javascript\nul(class=\"inline\")\n    li  Item C\n    li  Item A\n    li  Item B\n```\n\n\n<!-- more -->\n\n\n## 属性\n\nJade 的另一大特点就是和 JavaScript 的融合度很高，比如设置属性：\n\n```javascript\n- var authenticated = true\nbody(class= authenticated ? 'authed' : 'anon')\n- var currentUrl = '/about'\na(class={active: currentUrl === '/'} href='/') Home\na(class={active: currentUrl === '/about'} href='/about') About\n```\n\n此外，给标签设置行内样式时，需要以对象的形式赋值给 style：\n\n```javascript\na(style={color: 'red', background: 'green'})\n```\n\n## 插值\n\nJade 提供了字符串插值和标签插值。其中，字符串插值由于要考虑到安全性问题，所以又分成了转义和不转义两种情况：\n\n```javascript\n// 转义插值 #{}\n- var theGreat = \"<span>escape!</span>\";\np This will be safe: #{theGreat}\n\n// 不转义插值 !{}\n- var theGreat = \"<span>escape!</span>\";\np This will be safe: !{theGreat}\n\n// 标签插值\np #[a(href=\"jade-lang.com\") Jade]\n```\n\n编译结果：\n\n```html\n<!-- 转义插值 #{}-->\n<p>This will be safe: &lt;span&gt;escape!&lt;/span&gt;</p>\n\n<!-- 不转义插值 !{}-->\n<p>This will be safe: <span>escape!</span></p>\n\n<!-- 标签插值-->\n<p><a href=\"jade-lang.com\">Jade</a></p>\n```\n\n## 逻辑语句\n\nJade 提供了条件、分支、循环、遍历四种逻辑语句，这四种语句继承自 JavaScript，只是语法上有些差异:\n\n- 条件语句：if ... else if ... else\n- 分支语句：case ... when ... default\n- 循环语句：while\n- 遍历数组：each $elem in [elem...]\n- 遍历对象：each $key, $value in {key: value}\n\n```javascript\n// 分支语句\n- var friends = 10\ncase friends\n    when 0\n        p you have no friends\n    when 1\n        p you have a friend\n    default\n        p you have #{friends} friends\n```\n\n## mixin\n\nJade 和 Sass 都提供了 mixin 语法来实现代码的复用，两者语法也很相似：\n\n```javascript\nmixin list(id, ...items)\n    ul(id=id)\n        each item in items\n            li= item\n\n+list('my-list', 1, 2, 3, 4)\n```\n\nmixin 一般放在独立的文件中，需要使用 `include` 指令导入到其他文件中。\n\n## extends\n\n`extends` 是 Jade 的模板继承语法，通过 `extends filename.jade` 可以将模板文件导入到其他文件中。继承机制基本上是一个复制代码片段的过程，为了能够动态修改其中的部分内容，Jade 提供了 `block` 语法：\n\n```javascript\n// 声明 block\nblock content\n    p Hello\n\n// 修改 block\n// 同名重新赋值\nblock content\n    p Hi\n\n// 前置追加\nblock append content\n    p APPEND\n\n// 后置追加\nblock prepend content\n    p PREPEND\n```\n","slug":"Jade","published":1,"updated":"2015-12-11T05:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0p5000760diiqrvi5r7"},{"title":"ES2015","date":"2015-12-15T06:07:10.000Z","_content":"\n\n\n\n<!-- more -->\n","source":"_posts/ES2015.md","raw":"title: ES2015\ndate: 2015-12-15 14:07:10\n---\n\n\n\n\n<!-- more -->\n","slug":"ES2015","published":1,"updated":"2015-12-15T06:07:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0p7000860di79s3uk39"},{"title":"CSS Flexbox","date":"2015-12-02T02:42:39.000Z","_content":"\n如果你正在学习使用 CSS 布局，推荐来 [learnlayout](http://zh.learnlayout.com/toc.html) 了解一下这些年前端所用到的各类布局手法。这里之所以使用“手法”一词，意指其中多少有些偏激取巧，比如使用浮动（float）来定位、使用 margin 来伸缩空间等等。\n\nfloat、margin 本不应该用于布局，只是囿于早期的 CSS 布局模块发展缓慢且不合时宜，促使开发者另辟蹊径，借助其他样式来模拟布局效果。最近几年随着浏览器对布局模块的支持度越来越高，Flexible Box Layout（Flexbox）、Grid Layout、Multiple Column Layout 也逐渐为开发者所接受，其中以 Flexbox 的兼容性最好，拥护者也随之水涨船高。\n\n就个人感受而言，未来的布局方式会归纳为两类：一类是纯粹使用浏览器兼容性高的布局模块，比如 Flexbox，这也是未来的发展趋势；另一类是使用预处理器或者框架自定义的布局模块，这只是目前的缓兵过渡之计。\n\n<!-- more -->\n\n在几个月前，我曾经使用过一段时间的 [Susy](http://susy.oddbird.net/)。 Susy 是基于 Sass 的一款布局框架，其核心是使用非布局样式来模拟布局效果，最大的优点在于封装布局样式之后提供了一套简洁明了的布局接口。比如，在下面的 Sass 代码中，`.contianer` 被附加了一套容器样式，嵌套在其中的 `item` 占据总体宽度的 4 / 10。\n\n```scss\n.container {\n    @include container;  \n    .item {\n        @include span(4 of 10);\n    }\n}\n```\n\n> Susy 的理念是帮助开发者规避数学计算，所以它有一条大快人心的口号：YOUR MARKUP, YOUR DESIGN, YOUR OPINIONS, OUR MATH。\n\n## Flexbox\n\n在数学计算的问题上，我觉得 Flexbox 和 Susy 有异曲同工之妙，只是相比起来，原生的 Flexbox 更加简捷。在 Flexbox 中有两个核心元素：`container` 和 `item`，所有的样式也是围绕这两类元素计算的。下图中有两条红线，分别代表在水平方向和垂直方向进行布局的基线。\n\n![Flexbox](https://cloud.githubusercontent.com/assets/9530963/11552213/009b2d44-99bd-11e5-88c8-8bdcb72fcd8d.png)\n\nFlexbox 中的 contianer 元素需要解决两个问题：自身的类型以及内部 item 的排列方式。通过 `display: flex` 和 `display: inline-flex` 可以将 container 声明为块级或者行内块级，从而确定了 container 自身的类型。使用以下属性则可以确定 container 内部 item 的排列方式：\n\n- flex-flow：flex-direction 和 flex-wrap 的缩写\n- flex-direction：决定 item 的排列方向\n- flex-wrap：决定 item 的溢出容器后的处理方式\n- justify-content：决定 item 在水平方向上的对齐方式\n- align-item：决定 item 在垂直方向上的对齐方式\n- align-content：决定多个 main axis 在垂直方向上的对齐方式\n\n![flex-container](https://cloud.githubusercontent.com/assets/9530963/11552230/2b8a9f8a-99bd-11e5-8b71-35164bc6d091.png)\n\nitem 元素需要解决的问题集中于自身上，包括自身在 container 中的顺序、缩放、对齐方式。使用以下属性可以设置 item 自身的布局样式：\n\n- order：决定 item 的顺序，默认值为 0，值越小越靠前\n- flex：flex-grow、flex-shrink 和 flex-basis 的缩写\n- flex-grow：决定 item 的放大比例，默认值为 0，0 表示不放大\n- flex-shrink：决定 item 的缩小比例，默认值为 1，0 表示不缩小\n- flex-basis：浏览器分配 container 剩余空间时，决定 item 获得的比重\n- align-self: 决定自身在垂直方向的对齐方式\n\n![flex-item](https://cloud.githubusercontent.com/assets/9530963/11552236/38ab72c0-99bd-11e5-884d-cea1dfc0af1c.png)\n\n## box-sizing\n\n话外提一下 `box-sizing`， 该属性用于声明 `width` 和 `height` 的约束范围：`border-box` 表示边框、内边距和内容块的宽高计入容器宽高；`content-box` 表示只有内容块的宽高计入容器宽高。此外，该属性可继承，可以通过设置 body 的 box-sizing 统一约束容器的宽高。\n\n## FlexFroggy\n\n这是一个寓教于乐的 Flexbox 布局小游戏，难度中下，很有意思：[http://flexboxfroggy.com](http://flexboxfroggy.com)。","source":"_posts/CSS-Flexbox.md","raw":"title: CSS Flexbox\ndate: 2015-12-02 10:42:39\n---\n\n如果你正在学习使用 CSS 布局，推荐来 [learnlayout](http://zh.learnlayout.com/toc.html) 了解一下这些年前端所用到的各类布局手法。这里之所以使用“手法”一词，意指其中多少有些偏激取巧，比如使用浮动（float）来定位、使用 margin 来伸缩空间等等。\n\nfloat、margin 本不应该用于布局，只是囿于早期的 CSS 布局模块发展缓慢且不合时宜，促使开发者另辟蹊径，借助其他样式来模拟布局效果。最近几年随着浏览器对布局模块的支持度越来越高，Flexible Box Layout（Flexbox）、Grid Layout、Multiple Column Layout 也逐渐为开发者所接受，其中以 Flexbox 的兼容性最好，拥护者也随之水涨船高。\n\n就个人感受而言，未来的布局方式会归纳为两类：一类是纯粹使用浏览器兼容性高的布局模块，比如 Flexbox，这也是未来的发展趋势；另一类是使用预处理器或者框架自定义的布局模块，这只是目前的缓兵过渡之计。\n\n<!-- more -->\n\n在几个月前，我曾经使用过一段时间的 [Susy](http://susy.oddbird.net/)。 Susy 是基于 Sass 的一款布局框架，其核心是使用非布局样式来模拟布局效果，最大的优点在于封装布局样式之后提供了一套简洁明了的布局接口。比如，在下面的 Sass 代码中，`.contianer` 被附加了一套容器样式，嵌套在其中的 `item` 占据总体宽度的 4 / 10。\n\n```scss\n.container {\n    @include container;  \n    .item {\n        @include span(4 of 10);\n    }\n}\n```\n\n> Susy 的理念是帮助开发者规避数学计算，所以它有一条大快人心的口号：YOUR MARKUP, YOUR DESIGN, YOUR OPINIONS, OUR MATH。\n\n## Flexbox\n\n在数学计算的问题上，我觉得 Flexbox 和 Susy 有异曲同工之妙，只是相比起来，原生的 Flexbox 更加简捷。在 Flexbox 中有两个核心元素：`container` 和 `item`，所有的样式也是围绕这两类元素计算的。下图中有两条红线，分别代表在水平方向和垂直方向进行布局的基线。\n\n![Flexbox](https://cloud.githubusercontent.com/assets/9530963/11552213/009b2d44-99bd-11e5-88c8-8bdcb72fcd8d.png)\n\nFlexbox 中的 contianer 元素需要解决两个问题：自身的类型以及内部 item 的排列方式。通过 `display: flex` 和 `display: inline-flex` 可以将 container 声明为块级或者行内块级，从而确定了 container 自身的类型。使用以下属性则可以确定 container 内部 item 的排列方式：\n\n- flex-flow：flex-direction 和 flex-wrap 的缩写\n- flex-direction：决定 item 的排列方向\n- flex-wrap：决定 item 的溢出容器后的处理方式\n- justify-content：决定 item 在水平方向上的对齐方式\n- align-item：决定 item 在垂直方向上的对齐方式\n- align-content：决定多个 main axis 在垂直方向上的对齐方式\n\n![flex-container](https://cloud.githubusercontent.com/assets/9530963/11552230/2b8a9f8a-99bd-11e5-8b71-35164bc6d091.png)\n\nitem 元素需要解决的问题集中于自身上，包括自身在 container 中的顺序、缩放、对齐方式。使用以下属性可以设置 item 自身的布局样式：\n\n- order：决定 item 的顺序，默认值为 0，值越小越靠前\n- flex：flex-grow、flex-shrink 和 flex-basis 的缩写\n- flex-grow：决定 item 的放大比例，默认值为 0，0 表示不放大\n- flex-shrink：决定 item 的缩小比例，默认值为 1，0 表示不缩小\n- flex-basis：浏览器分配 container 剩余空间时，决定 item 获得的比重\n- align-self: 决定自身在垂直方向的对齐方式\n\n![flex-item](https://cloud.githubusercontent.com/assets/9530963/11552236/38ab72c0-99bd-11e5-884d-cea1dfc0af1c.png)\n\n## box-sizing\n\n话外提一下 `box-sizing`， 该属性用于声明 `width` 和 `height` 的约束范围：`border-box` 表示边框、内边距和内容块的宽高计入容器宽高；`content-box` 表示只有内容块的宽高计入容器宽高。此外，该属性可继承，可以通过设置 body 的 box-sizing 统一约束容器的宽高。\n\n## FlexFroggy\n\n这是一个寓教于乐的 Flexbox 布局小游戏，难度中下，很有意思：[http://flexboxfroggy.com](http://flexboxfroggy.com)。","slug":"CSS-Flexbox","published":1,"updated":"2015-12-15T05:18:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cii6zm0p8000960dihc9dthr8"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}